/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */

using Aas = AasCore.Aas3_0_RC02;  // renamed
using CodeAnalysis = System.Diagnostics.CodeAnalysis;
using Regex = System.Text.RegularExpressions.Regex;

using System.Collections.Generic;  // can't alias
using System.Linq;  // can't alias

namespace AasCore.Aas3_0_RC02
{
    /// <summary>
    /// Verify that the instances of the meta-model satisfy the invariants.
    /// </summary>
    /// <example>
    /// Here is an example how to verify an instance of IHasSemantics:
    /// <code>
    /// var anInstance = new Aas.IHasSemantics(
    ///     // ... some constructor arguments ...
    /// );
    /// foreach (var error in Verification.Verify(anInstance))
    /// {
    ///     System.Console.Writeln(
    ///         $"{error.Cause} at: " +
    ///         Reporting.GenerateJsonPath(error.PathSegments));
    /// }
    /// </code>
    /// </example>
    public static class Verification
    {
        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesIdShort()
        {
            var pattern = "^[a-zA-Z][a-zA-Z0-9_]+$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesIdShort = _constructMatchesIdShort();

        /// <summary>
        /// Check that <paramref name="text" /> is a valid short ID.
        /// </summary>
        public static bool MatchesIdShort(string text)
        {
            return RegexMatchesIdShort.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsDateTimeStampUtc()
        {
            var digit = "[0-9]";
            var yearFrag = $"-?(([1-9]{digit}{digit}{digit}+)|(0{digit}{digit}{digit}))";
            var monthFrag = "((0[1-9])|(1[0-2]))";
            var dayFrag = $"((0[1-9])|([12]{digit})|(3[01]))";
            var hourFrag = $"(([01]{digit})|(2[0-3]))";
            var minuteFrag = $"[0-5]{digit}";
            var secondFrag = $"([0-5]{digit})(\\.{digit}+)?";
            var endOfDayFrag = "24:00:00(\\.0+)?";
            var timezoneFrag = "Z";
            var dateTimeStampLexicalRep = $"{yearFrag}-{monthFrag}-{dayFrag}T(({hourFrag}:{minuteFrag}:{secondFrag})|{endOfDayFrag}){timezoneFrag}";
            var pattern = $"^{dateTimeStampLexicalRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsDateTimeStampUtc = _constructMatchesXsDateTimeStampUtc();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:dateTimeStamp</c>.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The time zone must be fixed to UTC. We verify only that the <c>text</c> matches
        /// a pre-defined pattern. We <em>do not</em> verify that the day of month is
        /// correct nor do we check for leap seconds.
        /// </para>
        /// <para>
        /// See: https://www.w3.org/TR/xmlschema11-2/#dateTimeStamp
        /// </para>
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsDateTimeStampUtc(string text)
        {
            return RegexMatchesXsDateTimeStampUtc.IsMatch(text);
        }

        private static readonly Regex RegexDatePrefix = (
            new Regex("^(-?[0-9]+)-([0-9]{2})-([0-9]{2})"));

        /// <summary>
        /// Check whether the given year is a leap year.
        /// </summary>
        /// <remarks>Year 1 BCE is a leap year.</remarks>
        /// <param name="year">to be checked</param>
        /// <returns>True if <paramref name="year"/> is a leap year</returns>
        public static bool IsLeapYear(System.Numerics.BigInteger year)
        {
            // NOTE (mristin, 2022-11-02):
            // We consider the years B.C. to be one-off.
            // See the note at: https://www.w3.org/TR/xmlschema-2/#dateTime:
            // "'-0001' is the lexical representation of the year 1 Before Common Era
            // (1 BCE, sometimes written "1 BC")."
            //
            // Hence, -1 year in XML is 1 BCE, which is 0 year in astronomical years.
            if (year < 0)
            {
                year = -year - 1;
            }

            // See: See: https://en.wikipedia.org/wiki/Leap_year#Algorithm
            if (year % 4 > 0)
            {
                return false;
            }

            if (year % 100 > 0)
            {
                return true;
            }

            if (year % 400 > 0)
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Check that the value starts with a valid date.
        /// </summary>
        /// <param name="value">
        ///     an <c>xs:date</c>, an <c>xs:dateTime</c>,
        ///     or an <c>xs:dateTimeStamp</c></param>
        /// <returns>
        ///     <c>true</c> if the value starts with a valid date
        /// </returns>
        private static bool IsPrefixedWithValidDate(string value)
        {
            // NOTE (mristin, 2022-11-02):
            // We can not use System.DateTime.ParseExact since it does not handle the zero and
            // BCE years correctly. Therefore, we have to roll out our own date validator.
            var match = RegexDatePrefix.Match(value);
            if (!match.Success)
            {
                return false;
            }

            bool ok = System.Numerics.BigInteger.TryParse(
                match.Groups[1].Value,
                out System.Numerics.BigInteger year);
            if (!ok)
            {
                throw new System.InvalidOperationException(
                    $"Expected to parse the year from {match.Groups[1].Value}, " +
                    "but the parsing failed");
            }

            ok = System.SByte.TryParse(match.Groups[2].Value, out sbyte month);
            if (!ok)
            {
                throw new System.InvalidOperationException(
                    $"Expected to parse the month from {match.Groups[2].Value}, " +
                    "but the parsing failed");
            }

            ok = System.SByte.TryParse(match.Groups[3].Value, out sbyte day);
            if (!ok)
            {
                throw new System.InvalidOperationException(
                    $"Expected to parse the day from {match.Groups[3].Value}, " +
                    "but the parsing failed");
            }

            // Year zero does not exist, see: https://www.w3.org/TR/xmlschema-2/#dateTime
            if (year == 0)
            {
                return false;
            }

            if (day <= 0 || day > 31)
            {
                return false;
            }

            if (month <= 0 || month >= 13)
            {
                return false;
            }

            sbyte maxDaysInMonth;
            switch (month)
            {
                case 1:
                    maxDaysInMonth = 31;
                    break;
                case 2:
                    maxDaysInMonth = (IsLeapYear(year)) ? (sbyte)29 : (sbyte)28;
                    break;
                case 3:
                    maxDaysInMonth = 31;
                    break;
                case 4:
                    maxDaysInMonth = 30;
                    break;
                case 5:
                    maxDaysInMonth = 31;
                    break;
                case 6:
                    maxDaysInMonth = 30;
                    break;
                case 7:
                    maxDaysInMonth = 31;
                    break;
                case 8:
                    maxDaysInMonth = 31;
                    break;
                case 9:
                    maxDaysInMonth = 30;
                    break;
                case 10:
                    maxDaysInMonth = 31;
                    break;
                case 11:
                    maxDaysInMonth = 30;
                    break;
                case 12:
                    maxDaysInMonth = 31;
                    break;
                default:
                    throw new System.InvalidOperationException($"Unexpected month: {month}");
            }

            if (day > maxDaysInMonth)
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Check that <paramref name="value" /> is a <c>xs:dateTimeStamp</c> with
        /// the time zone set to UTC.
        /// </summary>
        public static bool IsXsDateTimeStampUtc(
            string value
        )
        {
            if (!MatchesXsDateTimeStampUtc(value))
            {
                return false;
            }

            return IsPrefixedWithValidDate(value);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesMimeType()
        {
            var tchar = "[!#$%&'*+\\-.^_`|~0-9a-zA-Z]";
            var token = $"({tchar})+";
            var type = $"{token}";
            var subtype = $"{token}";
            var ows = "[ \\t]*";
            var obsText = "[\\x80-\\xff]";
            var qdText = $"([\\t !#-\\[\\]-~]|{obsText})";
            var quotedPair = $"\\\\([\\t !-~]|{obsText})";
            var quotedString = $"\"({qdText}|{quotedPair})*\"";
            var parameter = $"{token}=({token}|{quotedString})";
            var mediaType = $"^{type}/{subtype}({ows};{ows}{parameter})*$";

            return new Regex(mediaType);
        }

        private static readonly Regex RegexMatchesMimeType = _constructMatchesMimeType();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of MIME type.
        /// </summary>
        /// <remarks>
        /// The definition has been taken from:
        /// https://www.rfc-editor.org/rfc/rfc7231#section-3.1.1.1,
        /// https://www.rfc-editor.org/rfc/rfc7230#section-3.2.3 and
        /// https://www.rfc-editor.org/rfc/rfc7230#section-3.2.6.
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesMimeType(string text)
        {
            return RegexMatchesMimeType.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesRfc8089Path()
        {
            var h16 = "[0-9A-Fa-f]{1,4}";
            var decOctet = "([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])";
            var ipv4address = $"{decOctet}\\.{decOctet}\\.{decOctet}\\.{decOctet}";
            var ls32 = $"({h16}:{h16}|{ipv4address})";
            var ipv6address = $"(({h16}:){{6}}{ls32}|::({h16}:){{5}}{ls32}|({h16})?::({h16}:){{4}}{ls32}|(({h16}:)?{h16})?::({h16}:){{3}}{ls32}|(({h16}:){{2}}{h16})?::({h16}:){{2}}{ls32}|(({h16}:){{3}}{h16})?::{h16}:{ls32}|(({h16}:){{4}}{h16})?::{ls32}|(({h16}:){{5}}{h16})?::{h16}|(({h16}:){{6}}{h16})?::)";
            var unreserved = "[a-zA-Z0-9\\-._~]";
            var subDelims = "[!$&'()*+,;=]";
            var ipvfuture = $"[vV][0-9A-Fa-f]+\\.({unreserved}|{subDelims}|:)+";
            var ipLiteral = $"\\[({ipv6address}|{ipvfuture})\\]";
            var pctEncoded = "%[0-9A-Fa-f][0-9A-Fa-f]";
            var regName = $"({unreserved}|{pctEncoded}|{subDelims})*";
            var host = $"({ipLiteral}|{ipv4address}|{regName})";
            var fileAuth = $"(localhost|{host})";
            var pchar = $"({unreserved}|{pctEncoded}|{subDelims}|[:@])";
            var segmentNz = $"({pchar})+";
            var segment = $"({pchar})*";
            var pathAbsolute = $"/({segmentNz}(/{segment})*)?";
            var authPath = $"({fileAuth})?{pathAbsolute}";
            var localPath = $"{pathAbsolute}";
            var fileHierPart = $"(//{authPath}|{localPath})";
            var fileScheme = "file";
            var fileUri = $"{fileScheme}:{fileHierPart}";
            var pattern = $"^{fileUri}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesRfc8089Path = _constructMatchesRfc8089Path();

        /// <summary>
        /// Check that <paramref name="text" /> is a path conforming to the pattern of RFC 8089.
        /// </summary>
        /// <remarks>
        /// The definition has been taken from:
        /// https://datatracker.ietf.org/doc/html/rfc8089
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesRfc8089Path(string text)
        {
            return RegexMatchesRfc8089Path.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesBcp47()
        {
            var alphanum = "[a-zA-Z0-9]";
            var singleton = "[0-9A-WY-Za-wy-z]";
            var extension = $"{singleton}(-({alphanum}){{2,8}})+";
            var extlang = "[a-zA-Z]{3}(-[a-zA-Z]{3}){2}";
            var irregular = "(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)";
            var regular = "(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)";
            var grandfathered = $"({irregular}|{regular})";
            var language = $"([a-zA-Z]{{2,3}}(-{extlang})?|[a-zA-Z]{{4}}|[a-zA-Z]{{5,8}})";
            var script = "[a-zA-Z]{4}";
            var region = "([a-zA-Z]{2}|[0-9]{3})";
            var variant = $"(({alphanum}){{5,8}}|[0-9]({alphanum}){{3}})";
            var privateuse = $"[xX](-({alphanum}){{1,8}})+";
            var langtag = $"{language}(-{script})?(-{region})?(-{variant})*(-{extension})*(-{privateuse})?";
            var languageTag = $"({langtag}|{privateuse}|{grandfathered})";
            var pattern = $"^{languageTag}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesBcp47 = _constructMatchesBcp47();

        /// <summary>
        /// Check that <paramref name="text" /> is a valid BCP 47 language tag.
        /// </summary>
        /// <remarks>
        /// See: https://en.wikipedia.org/wiki/IETF_language_tag
        /// </remarks>
        public static bool MatchesBcp47(string text)
        {
            return RegexMatchesBcp47.IsMatch(text);
        }

        /// <summary>
        /// Check that <paramref name="langStrings" /> are specified each for a unique
        /// language.
        /// </summary>
        public static bool LangStringsHaveUniqueLanguages(
            IEnumerable<Aas.LangString> langStrings
        )
        {
            var languageSet = new HashSet<string>();
            foreach (var langString in langStrings)
            {
                if (languageSet.Contains(langString.Language))
                {
                    return false;
                }
                languageSet.Add(langString.Language);
            }
            return true;
        }

        /// <summary>
        /// Check that there are no duplicate <see cref="Aas.Qualifier.Type" />'s
        /// in the <paramref name="qualifiers" />.
        /// </summary>
        public static bool QualifierTypesAreUnique(
            IEnumerable<Aas.Qualifier> qualifiers
        )
        {
            var typeSet = new HashSet<string>();
            foreach (var qualifier in qualifiers)
            {
                if (typeSet.Contains(qualifier.Type))
                {
                    return false;
                }
                typeSet.Add(qualifier.Type);
            }
            return true;
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsAnyUri()
        {
            var scheme = "[a-zA-Z][a-zA-Z0-9+\\-.]*";
            var ucschar = "([\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef]|\\ud800[\\udc00-\\udfff]|[\\ud801-\\ud83e][\\udc00-\\udfff]|\\ud83f[\\udc00-\\udffd]|\\ud840[\\udc00-\\udfff]|[\\ud841-\\ud87e][\\udc00-\\udfff]|\\ud87f[\\udc00-\\udffd]|\\ud880[\\udc00-\\udfff]|[\\ud881-\\ud8be][\\udc00-\\udfff]|\\ud8bf[\\udc00-\\udffd]|\\ud8c0[\\udc00-\\udfff]|[\\ud8c1-\\ud8fe][\\udc00-\\udfff]|\\ud8ff[\\udc00-\\udffd]|\\ud900[\\udc00-\\udfff]|[\\ud901-\\ud93e][\\udc00-\\udfff]|\\ud93f[\\udc00-\\udffd]|\\ud940[\\udc00-\\udfff]|[\\ud941-\\ud97e][\\udc00-\\udfff]|\\ud97f[\\udc00-\\udffd]|\\ud980[\\udc00-\\udfff]|[\\ud981-\\ud9be][\\udc00-\\udfff]|\\ud9bf[\\udc00-\\udffd]|\\ud9c0[\\udc00-\\udfff]|[\\ud9c1-\\ud9fe][\\udc00-\\udfff]|\\ud9ff[\\udc00-\\udffd]|\\uda00[\\udc00-\\udfff]|[\\uda01-\\uda3e][\\udc00-\\udfff]|\\uda3f[\\udc00-\\udffd]|\\uda40[\\udc00-\\udfff]|[\\uda41-\\uda7e][\\udc00-\\udfff]|\\uda7f[\\udc00-\\udffd]|\\uda80[\\udc00-\\udfff]|[\\uda81-\\udabe][\\udc00-\\udfff]|\\udabf[\\udc00-\\udffd]|\\udac0[\\udc00-\\udfff]|[\\udac1-\\udafe][\\udc00-\\udfff]|\\udaff[\\udc00-\\udffd]|\\udb00[\\udc00-\\udfff]|[\\udb01-\\udb3e][\\udc00-\\udfff]|\\udb3f[\\udc00-\\udffd]|\\udb44[\\udc00-\\udfff]|[\\udb45-\\udb7e][\\udc00-\\udfff]|\\udb7f[\\udc00-\\udffd])";
            var iunreserved = $"([a-zA-Z0-9\\-._~]|{ucschar})";
            var pctEncoded = "%[0-9A-Fa-f][0-9A-Fa-f]";
            var subDelims = "[!$&'()*+,;=]";
            var iuserinfo = $"({iunreserved}|{pctEncoded}|{subDelims}|:)*";
            var h16 = "[0-9A-Fa-f]{1,4}";
            var decOctet = "([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])";
            var ipv4address = $"{decOctet}\\.{decOctet}\\.{decOctet}\\.{decOctet}";
            var ls32 = $"({h16}:{h16}|{ipv4address})";
            var ipv6address = $"(({h16}:){{6}}{ls32}|::({h16}:){{5}}{ls32}|({h16})?::({h16}:){{4}}{ls32}|(({h16}:)?{h16})?::({h16}:){{3}}{ls32}|(({h16}:){{2}}{h16})?::({h16}:){{2}}{ls32}|(({h16}:){{3}}{h16})?::{h16}:{ls32}|(({h16}:){{4}}{h16})?::{ls32}|(({h16}:){{5}}{h16})?::{h16}|(({h16}:){{6}}{h16})?::)";
            var unreserved = "[a-zA-Z0-9\\-._~]";
            var ipvfuture = $"[vV][0-9A-Fa-f]+\\.({unreserved}|{subDelims}|:)+";
            var ipLiteral = $"\\[({ipv6address}|{ipvfuture})\\]";
            var iregName = $"({iunreserved}|{pctEncoded}|{subDelims})*";
            var ihost = $"({ipLiteral}|{ipv4address}|{iregName})";
            var port = "[0-9]*";
            var iauthority = $"({iuserinfo}@)?{ihost}(:{port})?";
            var ipchar = $"({iunreserved}|{pctEncoded}|{subDelims}|[:@])";
            var isegment = $"({ipchar})*";
            var ipathAbempty = $"(/{isegment})*";
            var isegmentNz = $"({ipchar})+";
            var ipathAbsolute = $"/({isegmentNz}(/{isegment})*)?";
            var ipathRootless = $"{isegmentNz}(/{isegment})*";
            var ipathEmpty = $"({ipchar}){{0}}";
            var ihierPart = $"(//{iauthority}{ipathAbempty}|{ipathAbsolute}|{ipathRootless}|{ipathEmpty})";
            var iprivate = "([\\ue000-\\uf8ff]|\\udb80[\\udc00-\\udfff]|[\\udb81-\\udbbe][\\udc00-\\udfff]|\\udbbf[\\udc00-\\udffd]|\\udbc0[\\udc00-\\udfff]|[\\udbc1-\\udbfe][\\udc00-\\udfff]|\\udbff[\\udc00-\\udffd])";
            var iquery = $"({ipchar}|{iprivate}|[/?])*";
            var ifragment = $"({ipchar}|[/?])*";
            var isegmentNzNc = $"({iunreserved}|{pctEncoded}|{subDelims}|@)+";
            var ipathNoscheme = $"{isegmentNzNc}(/{isegment})*";
            var irelativePart = $"(//{iauthority}{ipathAbempty}|{ipathAbsolute}|{ipathNoscheme}|{ipathEmpty})";
            var irelativeRef = $"{irelativePart}(\\?{iquery})?(#{ifragment})?";
            var iri = $"{scheme}:{ihierPart}(\\?{iquery})?(#{ifragment})?";
            var iriReference = $"({iri}|{irelativeRef})";
            var pattern = $"^{iriReference}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsAnyUri = _constructMatchesXsAnyUri();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:anyURI</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#anyURI and
        /// https://datatracker.ietf.org/doc/html/rfc3987
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsAnyUri(string text)
        {
            return RegexMatchesXsAnyUri.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsBase64Binary()
        {
            var b04Char = "[AQgw]";
            var b04 = $"{b04Char}\\x20?";
            var b16Char = "[AEIMQUYcgkosw048]";
            var b16 = $"{b16Char}\\x20?";
            var b64Char = "[A-Za-z0-9+/]";
            var b64 = $"{b64Char}\\x20?";
            var b64quad = $"({b64}{b64}{b64}{b64})";
            var b64FinalQuad = $"({b64}{b64}{b64}{b64Char})";
            var padded8 = $"{b64}{b04}= ?=";
            var padded16 = $"{b64}{b64}{b16}=";
            var b64final = $"({b64FinalQuad}|{padded16}|{padded8})";
            var base64Binary = $"({b64quad}*{b64final})?";
            var pattern = $"^{base64Binary}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsBase64Binary = _constructMatchesXsBase64Binary();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:base64Binary</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#base64Binary
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsBase64Binary(string text)
        {
            return RegexMatchesXsBase64Binary.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsBoolean()
        {
            var pattern = "^(true|false|1|0)$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsBoolean = _constructMatchesXsBoolean();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:boolean</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#boolean
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsBoolean(string text)
        {
            return RegexMatchesXsBoolean.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsDate()
        {
            var digit = "[0-9]";
            var yearFrag = $"-?(([1-9]{digit}{digit}{digit}+)|(0{digit}{digit}{digit}))";
            var monthFrag = "((0[1-9])|(1[0-2]))";
            var dayFrag = $"((0[1-9])|([12]{digit})|(3[01]))";
            var minuteFrag = $"[0-5]{digit}";
            var timezoneFrag = $"(Z|(\\+|-)(0{digit}|1[0-3]):{minuteFrag}|14:00)";
            var dateLexicalRep = $"{yearFrag}-{monthFrag}-{dayFrag}{timezoneFrag}?";
            var pattern = $"^{dateLexicalRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsDate = _constructMatchesXsDate();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:date</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#date
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsDate(string text)
        {
            return RegexMatchesXsDate.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsDateTime()
        {
            var digit = "[0-9]";
            var yearFrag = $"-?(([1-9]{digit}{digit}{digit}+)|(0{digit}{digit}{digit}))";
            var monthFrag = "((0[1-9])|(1[0-2]))";
            var dayFrag = $"((0[1-9])|([12]{digit})|(3[01]))";
            var hourFrag = $"(([01]{digit})|(2[0-3]))";
            var minuteFrag = $"[0-5]{digit}";
            var secondFrag = $"([0-5]{digit})(\\.{digit}+)?";
            var endOfDayFrag = "24:00:00(\\.0+)?";
            var timezoneFrag = $"(Z|(\\+|-)(0{digit}|1[0-3]):{minuteFrag}|14:00)";
            var dateTimeLexicalRep = $"{yearFrag}-{monthFrag}-{dayFrag}T(({hourFrag}:{minuteFrag}:{secondFrag})|{endOfDayFrag}){timezoneFrag}?";
            var pattern = $"^{dateTimeLexicalRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsDateTime = _constructMatchesXsDateTime();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:dateTime</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#dateTime
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsDateTime(string text)
        {
            return RegexMatchesXsDateTime.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsDateTimeStamp()
        {
            var digit = "[0-9]";
            var yearFrag = $"-?(([1-9]{digit}{digit}{digit}+)|(0{digit}{digit}{digit}))";
            var monthFrag = "((0[1-9])|(1[0-2]))";
            var dayFrag = $"((0[1-9])|([12]{digit})|(3[01]))";
            var hourFrag = $"(([01]{digit})|(2[0-3]))";
            var minuteFrag = $"[0-5]{digit}";
            var secondFrag = $"([0-5]{digit})(\\.{digit}+)?";
            var endOfDayFrag = "24:00:00(\\.0+)?";
            var timezoneFrag = $"(Z|(\\+|-)(0{digit}|1[0-3]):{minuteFrag}|14:00)";
            var dateTimeStampLexicalRep = $"{yearFrag}-{monthFrag}-{dayFrag}T(({hourFrag}:{minuteFrag}:{secondFrag})|{endOfDayFrag}){timezoneFrag}";
            var pattern = $"^{dateTimeStampLexicalRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsDateTimeStamp = _constructMatchesXsDateTimeStamp();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:dateTimeStamp</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#dateTimeStamp
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsDateTimeStamp(string text)
        {
            return RegexMatchesXsDateTimeStamp.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsDecimal()
        {
            var digit = "[0-9]";
            var unsignedNoDecimalPtNumeral = $"{digit}+";
            var noDecimalPtNumeral = $"(\\+|-)?{unsignedNoDecimalPtNumeral}";
            var fracFrag = $"{digit}+";
            var unsignedDecimalPtNumeral = $"({unsignedNoDecimalPtNumeral}\\.{fracFrag}|\\.{fracFrag})";
            var decimalPtNumeral = $"(\\+|-)?{unsignedDecimalPtNumeral}";
            var decimalLexicalRep = $"({decimalPtNumeral}|{noDecimalPtNumeral})";
            var pattern = $"^{decimalLexicalRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsDecimal = _constructMatchesXsDecimal();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:decimal</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#decimal
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsDecimal(string text)
        {
            return RegexMatchesXsDecimal.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsDouble()
        {
            var doubleRep = "((\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|-?INF|NaN)";
            var pattern = $"^{doubleRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsDouble = _constructMatchesXsDouble();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:double</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#double
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsDouble(string text)
        {
            return RegexMatchesXsDouble.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsDuration()
        {
            var durationRep = "-?P((([0-9]+Y([0-9]+M)?([0-9]+D)?|([0-9]+M)([0-9]+D)?|([0-9]+D))(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S))))";
            var pattern = $"^{durationRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsDuration = _constructMatchesXsDuration();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:duration</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#duration
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsDuration(string text)
        {
            return RegexMatchesXsDuration.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsFloat()
        {
            var floatRep = "((\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|-?INF|NaN)";
            var pattern = $"^{floatRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsFloat = _constructMatchesXsFloat();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:float</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#float
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsFloat(string text)
        {
            return RegexMatchesXsFloat.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsGDay()
        {
            var gDayLexicalRep = "---(0[1-9]|[12][0-9]|3[01])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?";
            var pattern = $"^{gDayLexicalRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsGDay = _constructMatchesXsGDay();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:gDay</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#gDay
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsGDay(string text)
        {
            return RegexMatchesXsGDay.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsGMonth()
        {
            var gMonthLexicalRep = "--(0[1-9]|1[0-2])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?";
            var pattern = $"^{gMonthLexicalRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsGMonth = _constructMatchesXsGMonth();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:gMonth</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#gMonth
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsGMonth(string text)
        {
            return RegexMatchesXsGMonth.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsGMonthDay()
        {
            var gMonthDayRep = "--(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?";
            var pattern = $"^{gMonthDayRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsGMonthDay = _constructMatchesXsGMonthDay();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:gMonthDay</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#gMonthDay
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsGMonthDay(string text)
        {
            return RegexMatchesXsGMonthDay.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsGYear()
        {
            var gYearRep = "-?([1-9][0-9]{3,}|0[0-9]{3})(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?";
            var pattern = $"^{gYearRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsGYear = _constructMatchesXsGYear();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:gYear</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#gYear
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsGYear(string text)
        {
            return RegexMatchesXsGYear.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsGYearMonth()
        {
            var gYearMonthRep = "-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?";
            var pattern = $"^{gYearMonthRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsGYearMonth = _constructMatchesXsGYearMonth();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:gYearMonth</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#gYearMonth
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsGYearMonth(string text)
        {
            return RegexMatchesXsGYearMonth.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsHexBinary()
        {
            var hexBinary = "([0-9a-fA-F]{2})*";
            var pattern = $"^{hexBinary}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsHexBinary = _constructMatchesXsHexBinary();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:hexBinary</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#hexBinary
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsHexBinary(string text)
        {
            return RegexMatchesXsHexBinary.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsTime()
        {
            var timeRep = "(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?|(24:00:00(\\.0+)?))(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?";
            var pattern = $"^{timeRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsTime = _constructMatchesXsTime();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:time</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#time
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsTime(string text)
        {
            return RegexMatchesXsTime.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsDayTimeDuration()
        {
            var dayTimeDurationRep = "-?P((([0-9]+D)(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S))))";
            var pattern = $"^{dayTimeDurationRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsDayTimeDuration = _constructMatchesXsDayTimeDuration();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:dayTimeDuration</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#dayTimeDuration
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsDayTimeDuration(string text)
        {
            return RegexMatchesXsDayTimeDuration.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsYearMonthDuration()
        {
            var yearMonthDurationRep = "-?P((([0-9]+Y)([0-9]+M)?)|([0-9]+M))";
            var pattern = $"^{yearMonthDurationRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsYearMonthDuration = _constructMatchesXsYearMonthDuration();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:yearMonthDuration</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#yearMonthDuration
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsYearMonthDuration(string text)
        {
            return RegexMatchesXsYearMonthDuration.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsInteger()
        {
            var integerRep = "[-+]?[0-9]+";
            var pattern = $"^{integerRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsInteger = _constructMatchesXsInteger();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:integer</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#integer
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsInteger(string text)
        {
            return RegexMatchesXsInteger.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsLong()
        {
            var longRep = "[-+]?0*[0-9]{1,20}";
            var pattern = $"^{longRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsLong = _constructMatchesXsLong();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:long</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#long
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsLong(string text)
        {
            return RegexMatchesXsLong.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsInt()
        {
            var intRep = "[-+]?0*[0-9]{1,10}";
            var pattern = $"^{intRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsInt = _constructMatchesXsInt();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:int</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#int
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsInt(string text)
        {
            return RegexMatchesXsInt.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsShort()
        {
            var shortRep = "[-+]?0*[0-9]{1,5}";
            var pattern = $"^{shortRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsShort = _constructMatchesXsShort();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:short</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#short
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsShort(string text)
        {
            return RegexMatchesXsShort.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsByte()
        {
            var byteRep = "[-+]?0*[0-9]{1,3}";
            var pattern = $"^{byteRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsByte = _constructMatchesXsByte();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:byte</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#byte
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsByte(string text)
        {
            return RegexMatchesXsByte.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsNonNegativeInteger()
        {
            var nonNegativeIntegerRep = "(-0|\\+?[0-9]+)";
            var pattern = $"^{nonNegativeIntegerRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsNonNegativeInteger = _constructMatchesXsNonNegativeInteger();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:nonNegativeInteger</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#nonNegativeInteger
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsNonNegativeInteger(string text)
        {
            return RegexMatchesXsNonNegativeInteger.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsPositiveInteger()
        {
            var positiveIntegerRep = "\\+?0*[1-9][0-9]*";
            var pattern = $"^{positiveIntegerRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsPositiveInteger = _constructMatchesXsPositiveInteger();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:positiveInteger</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#positiveInteger
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsPositiveInteger(string text)
        {
            return RegexMatchesXsPositiveInteger.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsUnsignedLong()
        {
            var unsignedLongRep = "(-0|\\+?0*[0-9]{1,20})";
            var pattern = $"^{unsignedLongRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsUnsignedLong = _constructMatchesXsUnsignedLong();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:unsignedLong</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#unsignedLong
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsUnsignedLong(string text)
        {
            return RegexMatchesXsUnsignedLong.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsUnsignedInt()
        {
            var unsignedIntRep = "(-0|\\+?0*[0-9]{1,10})";
            var pattern = $"^{unsignedIntRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsUnsignedInt = _constructMatchesXsUnsignedInt();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:unsignedInt</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#unsignedInt
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsUnsignedInt(string text)
        {
            return RegexMatchesXsUnsignedInt.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsUnsignedShort()
        {
            var unsignedShortRep = "(-0|\\+?0*[0-9]{1,5})";
            var pattern = $"^{unsignedShortRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsUnsignedShort = _constructMatchesXsUnsignedShort();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:unsignedShort</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#unsignedShort
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsUnsignedShort(string text)
        {
            return RegexMatchesXsUnsignedShort.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsUnsignedByte()
        {
            var unsignedByteRep = "(-0|\\+?0*[0-9]{1,3})";
            var pattern = $"^{unsignedByteRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsUnsignedByte = _constructMatchesXsUnsignedByte();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:unsignedByte</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#unsignedByte
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsUnsignedByte(string text)
        {
            return RegexMatchesXsUnsignedByte.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsNonPositiveInteger()
        {
            var nonPositiveIntegerRep = "(\\+0|0|-[0-9]+)";
            var pattern = $"^{nonPositiveIntegerRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsNonPositiveInteger = _constructMatchesXsNonPositiveInteger();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:nonPositiveInteger</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#nonPositiveInteger
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsNonPositiveInteger(string text)
        {
            return RegexMatchesXsNonPositiveInteger.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsNegativeInteger()
        {
            var negativeIntegerRep = "(-0*[1-9][0-9]*)";
            var pattern = $"^{negativeIntegerRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsNegativeInteger = _constructMatchesXsNegativeInteger();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:negativeInteger</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#negativeInteger
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsNegativeInteger(string text)
        {
            return RegexMatchesXsNegativeInteger.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsString()
        {
            var pattern = "^([\\x01-\\ud7ff\\ue000-\\ufffd]|\\ud800[\\udc00-\\udfff]|[\\ud801-\\udbfe][\\udc00-\\udfff]|\\udbff[\\udc00-\\udfff])*$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsString = _constructMatchesXsString();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:string</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#string
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsString(string text)
        {
            return RegexMatchesXsString.IsMatch(text);
        }

        /// <summary>
        /// Check that the <paramref name="value" /> is consistent with
        /// the given <paramref name="valueType" />.
        /// </summary>
        public static bool ValueConsistentWithXsdType(
            string value,
            Aas.DataTypeDefXsd valueType
        )
        {
            switch (valueType)
            {
                case Aas.DataTypeDefXsd.AnyUri:
                    {
                        return MatchesXsAnyUri(value);
                    }
                case Aas.DataTypeDefXsd.Base64Binary:
                    {
                        return MatchesXsBase64Binary(value);
                    }
                case Aas.DataTypeDefXsd.Boolean:
                    {
                        return MatchesXsBoolean(value);
                    }
                case Aas.DataTypeDefXsd.Date:
                    {
                        if (!MatchesXsDate(value))
                        {
                            return false;
                        }

                        return IsPrefixedWithValidDate(value);
                    }
                case Aas.DataTypeDefXsd.DateTime:
                    {
                        if (!MatchesXsDateTime(value))
                        {
                            return false;
                        }

                        // The time part and the time zone part will be checked by
                        // MatchesXsDateTime. We need to check that the date part is
                        // correct in sense of the day/month combination.
                        return IsPrefixedWithValidDate(value);
                    }
                case Aas.DataTypeDefXsd.DateTimeStamp:
                    {
                        if (!MatchesXsDateTimeStamp(value))
                        {
                            return false;
                        }

                        // The time part and the time zone part will be checked by
                        // MatchesXsDateTimeStamp. We need to check that the date part is
                        // correct in sense of the day/month combination.
                        return IsPrefixedWithValidDate(value);
                    }
                case Aas.DataTypeDefXsd.Decimal:
                    {
                        return MatchesXsDecimal(value);
                    }
                case Aas.DataTypeDefXsd.Double:
                    {
                        // We need to check explicitly for the regular expression since
                        // System.Xml.XmlConvert.ToDouble is too permissive. For example,
                        // it accepts "nan" although only "NaN" is valid.
                        // See: https://www.w3.org/TR/xmlschema-2/#double
                        if (!MatchesXsDouble(value))
                        {
                            return false;
                        }

                        double converted;
                        try
                        {
                            converted = System.Xml.XmlConvert.ToDouble(value);
                        }
                        catch (System.FormatException)
                        {
                            return false;
                        }

                        if (System.Double.IsInfinity(converted))
                        {
                            // Check that the value is either "INF" or "-INF".
                            // Otherwise, the value is a decimal which is too big
                            // to be represented as a double-precision floating point
                            // number.
                            //
                            // Earlier C# used to throw an exception in this case. Today it
                            // simply rounds the parsed value to infinity. In the context
                            // of data exchange formats (such as AAS), this can cause
                            // critical errors, so we check for this edge case explicitly.
                            if (value.Length == 3)
                            {
                                return value == "INF";
                            }
                            else if (value.Length == 4)
                            {
                                return value == "-INF";
                            }
                            else
                            {
                                return false;
                            }
                        }
                        return true;
                    }
                case Aas.DataTypeDefXsd.Duration:
                    {
                        return MatchesXsDuration(value);
                    }
                case Aas.DataTypeDefXsd.Float:
                    {
                        // We need to check explicitly for the regular expression since
                        // System.Xml.XmlConvert.ToSingle is too permissive. For example,
                        // it accepts "nan" although only "NaN" is valid.
                        // See: https://www.w3.org/TR/xmlschema-2/#float
                        if (!MatchesXsFloat(value))
                        {
                            return false;
                        }

                        float converted;
                        try
                        {
                            converted = System.Xml.XmlConvert.ToSingle(value);
                        }
                        catch (System.FormatException)
                        {
                            return false;
                        }

                        if (System.Single.IsInfinity(converted))
                        {
                            // Check that the value is either "INF" or "-INF".
                            // Otherwise, the value is a decimal which is too big
                            // to be represented as a single-precision floating point
                            // number.
                            //
                            // Earlier C# used to throw an exception in this case. Today it
                            // simply rounds the parsed value to infinity. In the context
                            // of data exchange formats (such as AAS), this can cause
                            // critical errors, so we check for this edge case explicitly.
                            if (value.Length == 3)
                            {
                                return value == "INF";
                            }
                            else if (value.Length == 4)
                            {
                                return value == "-INF";
                            }
                            else
                            {
                                return false;
                            }
                        }
                        return true;
                    }
                case Aas.DataTypeDefXsd.GDay:
                    {
                        return MatchesXsGDay(value);
                    }
                case Aas.DataTypeDefXsd.GMonth:
                    {
                        return MatchesXsGMonth(value);
                    }
                case Aas.DataTypeDefXsd.GMonthDay:
                    {
                        if (!MatchesXsGMonthDay(value))
                        {
                            return false;
                        }

                        var month = int.Parse(value.Substring(2, 2));
                        var day = int.Parse(value.Substring(5, 2));
                        switch (month)
                        {
                            case 1:
                            case 3:
                            case 5:
                            case 7:
                            case 8:
                            case 10:
                            case 12:
                                return day <= 31;
                            case 4:
                            case 6:
                            case 9:
                            case 11:
                                return day <= 30;
                            case 2:
                                return day <= 29;
                            default:
                                throw new System.InvalidOperationException(
                                    $"Unhandled month: {month}; " +
                                    "is there maybe a bug in MatchesXsGMonthDay?"
                                );
                        }
                    }
                case Aas.DataTypeDefXsd.GYear:
                    {
                        return MatchesXsGYear(value);
                    }
                case Aas.DataTypeDefXsd.GYearMonth:
                    {
                        return MatchesXsGYearMonth(value);
                    }
                case Aas.DataTypeDefXsd.HexBinary:
                    {
                        return MatchesXsHexBinary(value);
                    }
                case Aas.DataTypeDefXsd.String:
                    {
                        return MatchesXsString(value);
                    }
                case Aas.DataTypeDefXsd.Time:
                    {
                        return MatchesXsTime(value);
                    }
                case Aas.DataTypeDefXsd.DayTimeDuration:
                    {
                        return MatchesXsDayTimeDuration(value);
                    }
                case Aas.DataTypeDefXsd.YearMonthDuration:
                    {
                        return MatchesXsYearMonthDuration(value);
                    }
                case Aas.DataTypeDefXsd.Integer:
                    {
                        return MatchesXsInteger(value);
                    }
                case Aas.DataTypeDefXsd.Long:
                    {
                        try
                        {
                            // ReSharper disable once ReturnValueOfPureMethodIsNotUsed
                            System.Xml.XmlConvert.ToInt64(value);
                            return true;
                        }
                        catch (System.OverflowException)
                        {
                            return false;
                        }
                        catch (System.FormatException)
                        {
                            return false;
                        }
                    }
                case Aas.DataTypeDefXsd.Int:
                    {
                        try
                        {
                            // ReSharper disable once ReturnValueOfPureMethodIsNotUsed
                            System.Xml.XmlConvert.ToInt32(value);
                            return true;
                        }
                        catch (System.OverflowException)
                        {
                            return false;
                        }
                        catch (System.FormatException)
                        {
                            return false;
                        }
                    }
                case Aas.DataTypeDefXsd.Short:
                    {
                        try
                        {
                            // ReSharper disable once ReturnValueOfPureMethodIsNotUsed
                            System.Xml.XmlConvert.ToInt16(value);
                            return true;
                        }
                        catch (System.OverflowException)
                        {
                            return false;
                        }
                        catch (System.FormatException)
                        {
                            return false;
                        }
                    }
                case Aas.DataTypeDefXsd.Byte:
                    {
                        try
                        {
                            // ReSharper disable once ReturnValueOfPureMethodIsNotUsed
                            System.Xml.XmlConvert.ToSByte(value);
                            return true;
                        }
                        catch (System.OverflowException)
                        {
                            return false;
                        }
                        catch (System.FormatException)
                        {
                            return false;
                        }
                    }
                case Aas.DataTypeDefXsd.NonNegativeInteger:
                    {
                        return MatchesXsNonNegativeInteger(value);
                    }
                case Aas.DataTypeDefXsd.PositiveInteger:
                    {
                        return MatchesXsPositiveInteger(value);
                    }
                case Aas.DataTypeDefXsd.UnsignedLong:
                    {
                        if (value.Length == 0)
                        {
                            return false;
                        }

                        // We need to allow negative zeros which are allowed in the lexical
                        // representation of an unsigned long, but System.Xml.XmlConvert.ToUInt64
                        // rejects it.
                        // See: https://www.w3.org/TR/xmlschema11-2/#unsignedLong
                        if (value == "-0")
                        {
                            return true;
                        }

                        // We need to strip the prefix positive sign since
                        // System.Xml.XmlConvert.ToUInt64 does not adhere to lexical representation
                        // of an unsigned long.
                        //
                        // The positive sign is indeed allowed in the lexical representation, see:
                        // https://www.w3.org/TR/xmlschema11-2/#unsignedLong
                        string clipped = (value[0] == '+')
                            ? value.Substring(1, value.Length - 1)
                            : value;

                        try
                        {
                            // ReSharper disable once ReturnValueOfPureMethodIsNotUsed
                            System.Xml.XmlConvert.ToUInt64(clipped);
                            return true;
                        }
                        catch (System.OverflowException)
                        {
                            return false;
                        }
                        catch (System.FormatException)
                        {
                            return false;
                        }
                    }
                case Aas.DataTypeDefXsd.UnsignedInt:
                    {
                        if (value.Length == 0)
                        {
                            return false;
                        }

                        // We need to allow negative zeros which are allowed in the lexical
                        // representation of an unsigned int, but System.Xml.XmlConvert.ToUInt32
                        // rejects it.
                        // See: https://www.w3.org/TR/xmlschema11-2/#unsignedInt
                        if (value == "-0")
                        {
                            return true;
                        }

                        // We need to strip the prefix positive sign since
                        // System.Xml.XmlConvert.ToUInt32 does not adhere to lexical representation
                        // of an unsigned int.
                        //
                        // The positive sign is indeed allowed in the lexical representation, see:
                        // https://www.w3.org/TR/xmlschema11-2/#unsignedInt
                        string clipped = (value[0] == '+')
                            ? value.Substring(1, value.Length - 1)
                            : value;

                        try
                        {
                            // ReSharper disable once ReturnValueOfPureMethodIsNotUsed
                            System.Xml.XmlConvert.ToUInt32(clipped);
                            return true;
                        }
                        catch (System.OverflowException)
                        {
                            return false;
                        }
                        catch (System.FormatException)
                        {
                            return false;
                        }
                    }
                case Aas.DataTypeDefXsd.UnsignedShort:
                    {
                        if (value.Length == 0)
                        {
                            return false;
                        }

                        // We need to allow negative zeros which are allowed in the lexical
                        // representation of an unsigned short, but System.Xml.XmlConvert.ToUInt16
                        // rejects it.
                        // See: https://www.w3.org/TR/xmlschema11-2/#unsignedShort
                        if (value == "-0")
                        {
                            return true;
                        }

                        // We need to strip the prefix positive sign since
                        // System.Xml.XmlConvert.ToUInt16 does not adhere to lexical representation
                        // of an unsigned short.
                        //
                        // The positive sign is indeed allowed in the lexical representation, see:
                        // https://www.w3.org/TR/xmlschema11-2/#unsignedShort
                        string clipped = (value[0] == '+')
                            ? value.Substring(1, value.Length - 1)
                            : value;

                        try
                        {
                            // ReSharper disable once ReturnValueOfPureMethodIsNotUsed
                            System.Xml.XmlConvert.ToUInt16(clipped);
                            return true;
                        }
                        catch (System.OverflowException)
                        {
                            return false;
                        }
                        catch (System.FormatException)
                        {
                            return false;
                        }
                    }
                case Aas.DataTypeDefXsd.UnsignedByte:
                    {
                        if (value.Length == 0)
                        {
                            return false;
                        }

                        // We need to allow negative zeros which are allowed in the lexical
                        // representation of an unsigned byte, but System.Xml.XmlConvert.ToByte
                        // rejects it.
                        // See: https://www.w3.org/TR/xmlschema11-2/#unsignedByte
                        if (value == "-0")
                        {
                            return true;
                        }

                        // We need to strip the prefix positive sign since
                        // System.Xml.XmlConvert.ToByte does not adhere to lexical representation
                        // of an unsigned byte.
                        //
                        // The positive sign is indeed allowed in the lexical representation, see:
                        // https://www.w3.org/TR/xmlschema11-2/#unsignedByte
                        string clipped = (value[0] == '+')
                            ? value.Substring(1, value.Length - 1)
                            : value;

                        try
                        {
                            // ReSharper disable once ReturnValueOfPureMethodIsNotUsed
                            System.Xml.XmlConvert.ToByte(clipped);
                            return true;
                        }
                        catch (System.OverflowException)
                        {
                            return false;
                        }
                        catch (System.FormatException)
                        {
                            return false;
                        }
                    }
                case Aas.DataTypeDefXsd.NonPositiveInteger:
                    {
                        return MatchesXsNonPositiveInteger(value);
                    }
                case Aas.DataTypeDefXsd.NegativeInteger:
                    {
                        return MatchesXsNegativeInteger(value);
                    }
                default:
                    throw new System.ArgumentException(
                        $"valueType is an invalid  DataTypeDefXsd: {valueType}"
                    );
            }
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesGlobalAssetIdLiterally()
        {
            var pattern = "^[gG][lL][oO][bB][aA][lL][aA][sS][sS][eE][tT][iI][dD]$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesGlobalAssetIdLiterally = _constructMatchesGlobalAssetIdLiterally();

        /// <summary>
        /// Check that the <paramref name="text" /> matches <c>globalAssetId</c> case-insensitive.
        /// </summary>
        /// <remarks>
        /// The case-insensitivity depends on the culture. For example in Turkish, uppercase
        /// "i" is "İ", not "I". We assume the culture to be English, and explicitly check
        /// for English case-folding.
        /// </remarks>
        /// <param name="text">
        /// which needs to match <c>globalAssetId</c> literally
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> matches case-insensitive
        /// </returns>
        public static bool MatchesGlobalAssetIdLiterally(string text)
        {
            return RegexMatchesGlobalAssetIdLiterally.IsMatch(text);
        }

        /// <summary>
        /// Check that the target of the model reference matches the <paramref name="expectedType" />.
        /// </summary>
        public static bool IsModelReferenceTo(
            Reference reference,
            KeyTypes expectedType
        )
        {
            return reference.Type == ReferenceTypes.ModelReference
            && reference.Keys.Count != 0
            && reference.Keys[^1].Type == expectedType;
        }  // public static bool IsModelReferenceTo

        /// <summary>
        /// Check that the target of the reference matches a <see cref="Aas.Constants.AasReferables" />.
        /// </summary>
        public static bool IsModelReferenceToReferable(
            Reference reference
        )
        {
            return reference.Type == ReferenceTypes.ModelReference
            && reference.Keys.Count != 0
            && Aas.Constants.AasReferables.Contains(reference.Keys[^1].Type);
        }  // public static bool IsModelReferenceToReferable

        /// <summary>
        /// Check that all <see cref="Aas.IReferable.IdShort" /> are unique among
        /// <paramref name="referables" />.
        /// </summary>
        public static bool IdShortsAreUnique(
            IEnumerable<Aas.IReferable> referables
        )
        {
            var idShortSet = new HashSet<string>();
            foreach (var referable in referables)
            {
                if (referable.IdShort != null)
                {
                    if (idShortSet.Contains(referable.IdShort))
                    {
                        return false;
                    }
                    idShortSet.Add(referable.IdShort);
                }
            }
            return true;
        }

        /// <summary>
        /// Check that all <see cref="Aas.Extension.Name" /> are unique among
        /// <paramref name="extensions" />.
        /// </summary>
        public static bool ExtensionNamesAreUnique(
            IEnumerable<Aas.Extension> extensions
        )
        {
            var nameSet = new HashSet<string>();
            foreach (var extension in extensions)
            {
                if (nameSet.Contains(extension.Name))
                {
                    return false;
                }
                nameSet.Add(extension.Name);
            }
            return true;
        }

        /// <summary>
        /// Check that all <paramref name="elements" /> have the identical
        /// <see cref="Aas.IHasSemantics.SemanticId" />'s.
        /// </summary>
        public static bool SubmodelElementsHaveIdenticalSemanticIds(
            IEnumerable<Aas.ISubmodelElement> elements
        )
        {
            Aas.Reference? thatSemanticId = null;

            foreach (var element in elements)
            {
                if (element.SemanticId == null)
                {
                    continue;
                }

                if (thatSemanticId == null)
                {
                    thatSemanticId = element.SemanticId;
                    continue;
                }

                var thisSemanticId = element.SemanticId;

                if (thatSemanticId.Keys.Count != thisSemanticId.Keys.Count)
                {
                    return false;
                }

                for (int i = 0; i < thisSemanticId.Keys.Count; i++)
                {
                    if (thatSemanticId.Keys[i].Value != thisSemanticId.Keys[i].Value)
                    {
                        return false;
                    }
                }
            }

            return true;
        }

        public static bool SubmodelElementIsOfType(
            Aas.ISubmodelElement element,
            Aas.AasSubmodelElements expectedType
        )
        {
            switch (expectedType)
            {
                case Aas.AasSubmodelElements.AnnotatedRelationshipElement:
                    return element is Aas.AnnotatedRelationshipElement;

                case Aas.AasSubmodelElements.BasicEventElement:
                    return element is Aas.BasicEventElement;

                case Aas.AasSubmodelElements.Blob:
                    return element is Aas.Blob;

                case Aas.AasSubmodelElements.Capability:
                    return element is Aas.Capability;

                case Aas.AasSubmodelElements.DataElement:
                    return element is Aas.IDataElement;

                case Aas.AasSubmodelElements.Entity:
                    return element is Aas.Entity;

                case Aas.AasSubmodelElements.EventElement:
                    return element is Aas.IEventElement;

                case Aas.AasSubmodelElements.File:
                    return element is Aas.File;

                case Aas.AasSubmodelElements.MultiLanguageProperty:
                    return element is Aas.MultiLanguageProperty;

                case Aas.AasSubmodelElements.Operation:
                    return element is Aas.Operation;

                case Aas.AasSubmodelElements.Property:
                    return element is Aas.Property;

                case Aas.AasSubmodelElements.Range:
                    return element is Aas.Range;

                case Aas.AasSubmodelElements.ReferenceElement:
                    return element is Aas.ReferenceElement;

                case Aas.AasSubmodelElements.RelationshipElement:
                    return element is Aas.IRelationshipElement;

                case Aas.AasSubmodelElements.SubmodelElement:
                    // ReSharper disable once IsExpressionAlwaysTrue
                    // ReSharper disable once ConvertTypeCheckToNullCheck
                    return element is Aas.ISubmodelElement;

                case Aas.AasSubmodelElements.SubmodelElementList:
                    return element is Aas.SubmodelElementList;

                case Aas.AasSubmodelElements.SubmodelElementCollection:
                    return element is Aas.SubmodelElementCollection;

                default:
                    throw new System.ArgumentException(
                        $"expectedType is not a valid AasSubmodelElements: {expectedType}"
                    );
            }
        }

        /// <summary>
        /// Check that the <paramref name="elements" /> which are
        /// <see cref="Aas.Property" /> or <see cref="Aas.Range" />
        /// have the given <paramref name="valueType" />.
        /// </summary>
        /// <remarks>
        /// We have to use nullable valueType since the compiler does not really handle
        /// nullable C# value types.
        ///
        /// See https://endjin.com/blog/2022/02/csharp-10-generics-nullable-references-improvements-allownull
        /// </remarks>
        public static bool PropertiesOrRangesHaveValueType(
            IEnumerable<Aas.ISubmodelElement> elements,
            Aas.DataTypeDefXsd? valueType
        )
        {
            foreach (var element in elements)
            {
                switch (element)
                {
                    case Aas.Property prop:
                        if (prop.ValueType != valueType)
                        {
                            return false;
                        }
                        break;
                    case Aas.Range range:
                        if (range.ValueType != valueType)
                        {
                            return false;
                        }
                        break;
                }
            }
            return true;
        }

        /// <summary>
        /// Check that the two references, <paramref name="that" /> and
        /// <paramref name="other" />, are equal by comparing
        /// their <see cref="Aas.Reference.Keys" /> by
        /// <see cref="Aas.Key.Value" />'s.
        /// </summary>
        public static bool ReferenceKeyValuesEqual(
            Aas.Reference that,
            Aas.Reference other
        )
        {
            if (that.Keys.Count != other.Keys.Count)
            {
                return false;
            }

            for (int i = 0; i < that.Keys.Count; i++)
            {
                if (that.Keys[i].Value != other.Keys[i].Value)
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Check that the <see cref="Aas.DataSpecificationIec61360.DataType" /> is defined
        /// appropriately for all data specifications whose content is given as IEC 61360.
        /// </summary>
        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        public static bool DataSpecificationIec61360sForPropertyOrValueHaveAppropriateDataType(
            IEnumerable<Aas.EmbeddedDataSpecification> embeddedDataSpecifications
        )
        {
            foreach (var embeddedDataSpecification in embeddedDataSpecifications)
            {
                var iec61360 = (
                    embeddedDataSpecification.DataSpecificationContent
                        as DataSpecificationIec61360
                );
                if (iec61360 != null)
                {
                    if (
                        iec61360.DataType == null
                        || !Constants.DataTypeIec61360ForPropertyOrValue.Contains(
                            iec61360.DataType)
                    )
                    {
                        return false;
                    }
                }
            }

            return true;
        }

        /// <summary>
        /// Check that the <see cref="Aas.DataSpecificationIec61360.DataType" /> is defined
        /// appropriately for all data specifications whose content is given as IEC 61360.
        /// </summary>
        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        public static bool DataSpecificationIec61360sForReferenceHaveAppropriateDataType(
            IEnumerable<Aas.EmbeddedDataSpecification> embeddedDataSpecifications
        )
        {
            foreach (var embeddedDataSpecification in embeddedDataSpecifications)
            {
                var iec61360 = (
                    embeddedDataSpecification.DataSpecificationContent
                        as DataSpecificationIec61360
                );
                if (iec61360 != null)
                {
                    if (
                        iec61360.DataType == null
                        || !Constants.DataTypeIec61360ForReference.Contains(
                            iec61360.DataType)
                    )
                    {
                        return false;
                    }
                }
            }

            return true;
        }

        /// <summary>
        /// Check that the <see cref="Aas.DataSpecificationIec61360.DataType" /> is defined
        /// appropriately for all data specifications whose content is given as IEC 61360.
        /// </summary>
        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        public static bool DataSpecificationIec61360sForDocumentHaveAppropriateDataType(
            IEnumerable<Aas.EmbeddedDataSpecification> embeddedDataSpecifications
        )
        {
            foreach (var embeddedDataSpecification in embeddedDataSpecifications)
            {
                var iec61360 = (
                    embeddedDataSpecification.DataSpecificationContent
                        as DataSpecificationIec61360
                );
                if (iec61360 != null)
                {
                    if (
                        iec61360.DataType == null
                        || !Constants.DataTypeIec61360ForDocument.Contains(
                            iec61360.DataType)
                    )
                    {
                        return false;
                    }
                }
            }

            return true;
        }

        /// <summary>
        /// Check that the <see cref="Aas.DataSpecificationIec61360.DataType" /> is defined
        /// for all data specifications whose content is given as IEC 61360.
        /// </summary>
        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        public static bool DataSpecificationIec61360sHaveDataType(
            IEnumerable<Aas.EmbeddedDataSpecification> embeddedDataSpecifications
        )
        {
            foreach (var embeddedDataSpecification in embeddedDataSpecifications)
            {
                var iec61360 = (
                    embeddedDataSpecification.DataSpecificationContent
                        as DataSpecificationIec61360
                );
                if (iec61360 != null)
                {
                    if (iec61360.DataType == null)
                    {
                        return false;
                    }
                }
            }

            return true;
        }

        /// <summary>
        /// Check that the <see cref="Aas.DataSpecificationIec61360.Value" /> is defined
        /// for all data specifications whose content is given as IEC 61360.
        /// </summary>
        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        public static bool DataSpecificationIec61360sHaveValue(
            IEnumerable<Aas.EmbeddedDataSpecification> embeddedDataSpecifications
        )
        {
            foreach (var embeddedDataSpecification in embeddedDataSpecifications)
            {
                var iec61360 = (
                    embeddedDataSpecification.DataSpecificationContent
                        as DataSpecificationIec61360
                );
                if (iec61360 != null)
                {
                    if (iec61360.Value == null)
                    {
                        return false;
                    }
                }
            }

            return true;
        }

        /// <summary>
        /// Check that the <see cref="Aas.DataSpecificationIec61360.Definition" /> is defined
        /// for all data specifications whose content is given as IEC 61360 at least in English.
        /// </summary>
        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        public static bool DataSpecificationIec61360sHaveDefinitionAtLeastInEnglish(
            IEnumerable<Aas.EmbeddedDataSpecification> embeddedDataSpecifications
        )
        {
            foreach (var embeddedDataSpecification in embeddedDataSpecifications)
            {
                var iec61360 = (
                    embeddedDataSpecification.DataSpecificationContent
                        as DataSpecificationIec61360
                );
                if (iec61360 != null)
                {
                    if (iec61360.Definition == null)
                    {
                        return false;
                    }

                    var noDefinitionInEnglish = true;
                    foreach (var langString in iec61360.Definition)
                    {
                        if (IsBcp47ForEnglish(langString.Language))
                        {
                            noDefinitionInEnglish = false;
                            break;
                        }
                    }

                    if (noDefinitionInEnglish)
                    {
                        return false;
                    }
                }
            }

            return true;
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructIsBcp47ForEnglish()
        {
            var pattern = "^(en|EN)(-.*)?$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexIsBcp47ForEnglish = _constructIsBcp47ForEnglish();

        /// <summary>
        /// Check that the <paramref name="text" /> corresponds to a BCP47 code for english.
        /// </summary>
        public static bool IsBcp47ForEnglish(string text)
        {
            return RegexIsBcp47ForEnglish.IsMatch(text);
        }

        /// <summary>
        /// Hash allowed enum values for efficient validation of enums.
        /// </summary>
        internal static class EnumValueSet
        {
            internal static readonly HashSet<int> ForModelingKind = new HashSet<int>
            {

                (int)Aas.ModelingKind.Template,
                (int)Aas.ModelingKind.Instance
            };

            internal static readonly HashSet<int> ForQualifierKind = new HashSet<int>
            {

                (int)Aas.QualifierKind.ValueQualifier,
                (int)Aas.QualifierKind.ConceptQualifier,
                (int)Aas.QualifierKind.TemplateQualifier
            };

            internal static readonly HashSet<int> ForAssetKind = new HashSet<int>
            {

                (int)Aas.AssetKind.Type,
                (int)Aas.AssetKind.Instance
            };

            internal static readonly HashSet<int> ForAasSubmodelElements = new HashSet<int>
            {

                (int)Aas.AasSubmodelElements.AnnotatedRelationshipElement,
                (int)Aas.AasSubmodelElements.BasicEventElement,
                (int)Aas.AasSubmodelElements.Blob,
                (int)Aas.AasSubmodelElements.Capability,
                (int)Aas.AasSubmodelElements.DataElement,
                (int)Aas.AasSubmodelElements.Entity,
                (int)Aas.AasSubmodelElements.EventElement,
                (int)Aas.AasSubmodelElements.File,
                (int)Aas.AasSubmodelElements.MultiLanguageProperty,
                (int)Aas.AasSubmodelElements.Operation,
                (int)Aas.AasSubmodelElements.Property,
                (int)Aas.AasSubmodelElements.Range,
                (int)Aas.AasSubmodelElements.ReferenceElement,
                (int)Aas.AasSubmodelElements.RelationshipElement,
                (int)Aas.AasSubmodelElements.SubmodelElement,
                (int)Aas.AasSubmodelElements.SubmodelElementList,
                (int)Aas.AasSubmodelElements.SubmodelElementCollection
            };

            internal static readonly HashSet<int> ForEntityType = new HashSet<int>
            {

                (int)Aas.EntityType.CoManagedEntity,
                (int)Aas.EntityType.SelfManagedEntity
            };

            internal static readonly HashSet<int> ForDirection = new HashSet<int>
            {

                (int)Aas.Direction.Input,
                (int)Aas.Direction.Output
            };

            internal static readonly HashSet<int> ForStateOfEvent = new HashSet<int>
            {

                (int)Aas.StateOfEvent.On,
                (int)Aas.StateOfEvent.Off
            };

            internal static readonly HashSet<int> ForReferenceTypes = new HashSet<int>
            {

                (int)Aas.ReferenceTypes.GlobalReference,
                (int)Aas.ReferenceTypes.ModelReference
            };

            internal static readonly HashSet<int> ForKeyTypes = new HashSet<int>
            {

                (int)Aas.KeyTypes.FragmentReference,
                (int)Aas.KeyTypes.GlobalReference,
                (int)Aas.KeyTypes.AnnotatedRelationshipElement,
                (int)Aas.KeyTypes.AssetAdministrationShell,
                (int)Aas.KeyTypes.BasicEventElement,
                (int)Aas.KeyTypes.Blob,
                (int)Aas.KeyTypes.Capability,
                (int)Aas.KeyTypes.ConceptDescription,
                (int)Aas.KeyTypes.Identifiable,
                (int)Aas.KeyTypes.DataElement,
                (int)Aas.KeyTypes.Entity,
                (int)Aas.KeyTypes.EventElement,
                (int)Aas.KeyTypes.File,
                (int)Aas.KeyTypes.MultiLanguageProperty,
                (int)Aas.KeyTypes.Operation,
                (int)Aas.KeyTypes.Property,
                (int)Aas.KeyTypes.Range,
                (int)Aas.KeyTypes.ReferenceElement,
                (int)Aas.KeyTypes.Referable,
                (int)Aas.KeyTypes.RelationshipElement,
                (int)Aas.KeyTypes.Submodel,
                (int)Aas.KeyTypes.SubmodelElement,
                (int)Aas.KeyTypes.SubmodelElementList,
                (int)Aas.KeyTypes.SubmodelElementCollection
            };

            internal static readonly HashSet<int> ForDataTypeDefXsd = new HashSet<int>
            {

                (int)Aas.DataTypeDefXsd.AnyUri,
                (int)Aas.DataTypeDefXsd.Base64Binary,
                (int)Aas.DataTypeDefXsd.Boolean,
                (int)Aas.DataTypeDefXsd.Date,
                (int)Aas.DataTypeDefXsd.DateTime,
                (int)Aas.DataTypeDefXsd.DateTimeStamp,
                (int)Aas.DataTypeDefXsd.Decimal,
                (int)Aas.DataTypeDefXsd.Double,
                (int)Aas.DataTypeDefXsd.Duration,
                (int)Aas.DataTypeDefXsd.Float,
                (int)Aas.DataTypeDefXsd.GDay,
                (int)Aas.DataTypeDefXsd.GMonth,
                (int)Aas.DataTypeDefXsd.GMonthDay,
                (int)Aas.DataTypeDefXsd.GYear,
                (int)Aas.DataTypeDefXsd.GYearMonth,
                (int)Aas.DataTypeDefXsd.HexBinary,
                (int)Aas.DataTypeDefXsd.String,
                (int)Aas.DataTypeDefXsd.Time,
                (int)Aas.DataTypeDefXsd.DayTimeDuration,
                (int)Aas.DataTypeDefXsd.YearMonthDuration,
                (int)Aas.DataTypeDefXsd.Integer,
                (int)Aas.DataTypeDefXsd.Long,
                (int)Aas.DataTypeDefXsd.Int,
                (int)Aas.DataTypeDefXsd.Short,
                (int)Aas.DataTypeDefXsd.Byte,
                (int)Aas.DataTypeDefXsd.NonNegativeInteger,
                (int)Aas.DataTypeDefXsd.PositiveInteger,
                (int)Aas.DataTypeDefXsd.UnsignedLong,
                (int)Aas.DataTypeDefXsd.UnsignedInt,
                (int)Aas.DataTypeDefXsd.UnsignedShort,
                (int)Aas.DataTypeDefXsd.UnsignedByte,
                (int)Aas.DataTypeDefXsd.NonPositiveInteger,
                (int)Aas.DataTypeDefXsd.NegativeInteger
            };

            internal static readonly HashSet<int> ForDataTypeIec61360 = new HashSet<int>
            {

                (int)Aas.DataTypeIec61360.Date,
                (int)Aas.DataTypeIec61360.String,
                (int)Aas.DataTypeIec61360.StringTranslatable,
                (int)Aas.DataTypeIec61360.IntegerMeasure,
                (int)Aas.DataTypeIec61360.IntegerCount,
                (int)Aas.DataTypeIec61360.IntegerCurrency,
                (int)Aas.DataTypeIec61360.RealMeasure,
                (int)Aas.DataTypeIec61360.RealCount,
                (int)Aas.DataTypeIec61360.RealCurrency,
                (int)Aas.DataTypeIec61360.Boolean,
                (int)Aas.DataTypeIec61360.Iri,
                (int)Aas.DataTypeIec61360.Irdi,
                (int)Aas.DataTypeIec61360.Rational,
                (int)Aas.DataTypeIec61360.RationalMeasure,
                (int)Aas.DataTypeIec61360.Time,
                (int)Aas.DataTypeIec61360.Timestamp,
                (int)Aas.DataTypeIec61360.File,
                (int)Aas.DataTypeIec61360.Html,
                (int)Aas.DataTypeIec61360.Blob
            };

            internal static readonly HashSet<int> ForLevelType = new HashSet<int>
            {

                (int)Aas.LevelType.Min,
                (int)Aas.LevelType.Max,
                (int)Aas.LevelType.Nom,
                (int)Aas.LevelType.Typ
            };
        }  // internal static class EnumValueSet

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        private static readonly Verification.Transformer _transformer = (
            new Verification.Transformer());

        private class Transformer
            : Visitation.AbstractTransformer<IEnumerable<Reporting.Error>>
        {
            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.Extension that)
            {
                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SupplementalSemanticIds.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Supplemental semantic IDs must be either not set or have at " +
                        "least one item");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.");
                }

                if (!(
                    !(that.Value != null)
                    || Verification.ValueConsistentWithXsdType(that.Value, that.ValueTypeOrDefault())))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "The value must match the value type.");
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                foreach (var error in Verification.VerifyNonEmptyString(that.Name))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "name"));
                    yield return error;
                }

                if (that.ValueType != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.DataTypeDefXsd value = that.ValueType
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyDataTypeDefXsd(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "valueType"));
                        yield return error;
                    }
                }

                if (that.Value != null)
                {
                    foreach (var error in Verification.VerifyValueDataType(that.Value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "value"));
                        yield return error;
                    }
                }

                if (that.RefersTo != null)
                {
                    foreach (var error in Verification.Verify(that.RefersTo))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "refersTo"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.AdministrativeInformation that)
            {
                if (!(
                    !(that.EmbeddedDataSpecifications != null)
                    || (that.EmbeddedDataSpecifications.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Embedded data specifications must be either not set or have " +
                        "at least one item");
                }

                if (!(
                    !(that.Revision != null)
                    || (that.Version != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-005: If version is not specified then also " +
                        "revision shall be unspecified. This means, a revision " +
                        "requires a version. If there is no version there is no " +
                        "revision either. Revision is optional.");
                }

                if (that.EmbeddedDataSpecifications != null)
                {
                    int indexEmbeddedDataSpecifications = 0;
                    foreach (var item in that.EmbeddedDataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexEmbeddedDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "embeddedDataSpecifications"));
                            yield return error;
                        }
                        indexEmbeddedDataSpecifications++;
                    }
                }

                if (that.Version != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Version))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "version"));
                        yield return error;
                    }
                }

                if (that.Revision != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Revision))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "revision"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.Qualifier that)
            {
                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SupplementalSemanticIds.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Supplemental semantic IDs must be either not set or have at " +
                        "least one item");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.");
                }

                if (!(
                    !(that.Value != null)
                    || Verification.ValueConsistentWithXsdType(that.Value, that.ValueType)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-020: The value shall be consistent to " +
                        "the data type as defined in value type.");
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.QualifierKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyQualifierKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                foreach (var error in Verification.VerifyQualifierType(that.Type))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "type"));
                    yield return error;
                }

                foreach (var error in Verification.VerifyDataTypeDefXsd(that.ValueType))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "valueType"));
                    yield return error;
                }

                if (that.Value != null)
                {
                    foreach (var error in Verification.VerifyValueDataType(that.Value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "value"));
                        yield return error;
                    }
                }

                if (that.ValueId != null)
                {
                    foreach (var error in Verification.Verify(that.ValueId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "valueId"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.AssetAdministrationShell that)
            {
                if (!(
                    !(that.Extensions != null)
                    || (that.Extensions.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Extensions must be either not set or have at least one item");
                }

                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.");
                }

                if (!(
                    !(that.Description != null)
                    || (that.Description.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description must be either not set or have at least one item");
                }

                if (!(
                    !(that.Description != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.Description)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description specifies no duplicate languages");
                }

                if (!(
                    !(that.DisplayName != null)
                    || (that.DisplayName.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name must be either not set or have at least one " +
                        "item");
                }

                if (!(
                    !(that.DisplayName != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.DisplayName)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name specifies no duplicate languages");
                }

                if (!(
                    !(that.EmbeddedDataSpecifications != null)
                    || (that.EmbeddedDataSpecifications.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Embedded data specifications must be either not set or have " +
                        "at least one item");
                }

                if (!(
                    !(that.Submodels != null)
                    || (that.Submodels.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Submodels must be either not set or have at least one item");
                }

                if (!(
                    !(that.DerivedFrom != null)
                    || Verification.IsModelReferenceTo(
                        that.DerivedFrom,
                        KeyTypes.AssetAdministrationShell)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Derived-from must be a model reference to an asset " +
                        "administration shell.");
                }

                if (!(
                    !(that.Submodels != null)
                    || (
                        that.Submodels.All(
                            reference => Verification.IsModelReferenceTo(reference, KeyTypes.Submodel))
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "All submodels must be model references to a submodel.");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    int indexDisplayName = 0;
                    foreach (var item in that.DisplayName)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDisplayName));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "displayName"));
                            yield return error;
                        }
                        indexDisplayName++;
                    }
                }

                if (that.Description != null)
                {
                    int indexDescription = 0;
                    foreach (var item in that.Description)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDescription));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "description"));
                            yield return error;
                        }
                        indexDescription++;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Administration != null)
                {
                    foreach (var error in Verification.Verify(that.Administration))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "administration"));
                        yield return error;
                    }
                }

                foreach (var error in Verification.VerifyIdentifier(that.Id))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "id"));
                    yield return error;
                }

                if (that.EmbeddedDataSpecifications != null)
                {
                    int indexEmbeddedDataSpecifications = 0;
                    foreach (var item in that.EmbeddedDataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexEmbeddedDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "embeddedDataSpecifications"));
                            yield return error;
                        }
                        indexEmbeddedDataSpecifications++;
                    }
                }

                if (that.DerivedFrom != null)
                {
                    foreach (var error in Verification.Verify(that.DerivedFrom))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "derivedFrom"));
                        yield return error;
                    }
                }

                foreach (var error in Verification.Verify(that.AssetInformation))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "assetInformation"));
                    yield return error;
                }

                if (that.Submodels != null)
                {
                    int indexSubmodels = 0;
                    foreach (var item in that.Submodels)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSubmodels));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "submodels"));
                            yield return error;
                        }
                        indexSubmodels++;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.AssetInformation that)
            {
                if (!(
                    !(that.SpecificAssetIds != null)
                    || (that.SpecificAssetIds.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Specific asset IDs must be either not set or have at least " +
                        "one item");
                }

                foreach (var error in Verification.VerifyAssetKind(that.AssetKind))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "assetKind"));
                    yield return error;
                }

                if (that.GlobalAssetId != null)
                {
                    foreach (var error in Verification.Verify(that.GlobalAssetId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "globalAssetId"));
                        yield return error;
                    }
                }

                if (that.SpecificAssetIds != null)
                {
                    int indexSpecificAssetIds = 0;
                    foreach (var item in that.SpecificAssetIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSpecificAssetIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "specificAssetIds"));
                            yield return error;
                        }
                        indexSpecificAssetIds++;
                    }
                }

                if (that.DefaultThumbnail != null)
                {
                    foreach (var error in Verification.Verify(that.DefaultThumbnail))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "defaultThumbnail"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.Resource that)
            {
                foreach (var error in Verification.VerifyPathType(that.Path))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "path"));
                    yield return error;
                }

                if (that.ContentType != null)
                {
                    foreach (var error in Verification.VerifyContentType(that.ContentType))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "contentType"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.SpecificAssetId that)
            {
                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SupplementalSemanticIds.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Supplemental semantic IDs must be either not set or have at " +
                        "least one item");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.");
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                foreach (var error in Verification.VerifyNonEmptyString(that.Name))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "name"));
                    yield return error;
                }

                foreach (var error in Verification.VerifyNonEmptyString(that.Value))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "value"));
                    yield return error;
                }

                foreach (var error in Verification.Verify(that.ExternalSubjectId))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "externalSubjectId"));
                    yield return error;
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.Submodel that)
            {
                if (!(
                    !(that.Extensions != null)
                    || (that.Extensions.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Extensions must be either not set or have at least one item");
                }

                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.");
                }

                if (!(
                    !(that.Description != null)
                    || (that.Description.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description must be either not set or have at least one item");
                }

                if (!(
                    !(that.Description != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.Description)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description specifies no duplicate languages");
                }

                if (!(
                    !(that.DisplayName != null)
                    || (that.DisplayName.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name must be either not set or have at least one " +
                        "item");
                }

                if (!(
                    !(that.DisplayName != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.DisplayName)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name specifies no duplicate languages");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SupplementalSemanticIds.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Supplemental semantic IDs must be either not set or have at " +
                        "least one item");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (that.Qualifiers.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Qualifiers must be either not set or have at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.");
                }

                if (!(
                    !(that.EmbeddedDataSpecifications != null)
                    || (that.EmbeddedDataSpecifications.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Embedded data specifications must be either not set or have " +
                        "at least one item");
                }

                if (!(
                    !(that.SubmodelElements != null)
                    || (that.SubmodelElements.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Submodel elements must be either not set or have at least " +
                        "one item");
                }

                if (!(
                    !(that.SubmodelElements != null)
                    || (
                        that.SubmodelElements.All(
                            element => element.IdShort != null)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "ID-shorts need to be defined for all the submodel elements.");
                }

                if (!(
                    !(that.SubmodelElements != null)
                    || Verification.IdShortsAreUnique(that.SubmodelElements)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-120: ID-short of non-identifiable " +
                        "referables shall be unique in its namespace.");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    int indexDisplayName = 0;
                    foreach (var item in that.DisplayName)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDisplayName));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "displayName"));
                            yield return error;
                        }
                        indexDisplayName++;
                    }
                }

                if (that.Description != null)
                {
                    int indexDescription = 0;
                    foreach (var item in that.Description)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDescription));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "description"));
                            yield return error;
                        }
                        indexDescription++;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Administration != null)
                {
                    foreach (var error in Verification.Verify(that.Administration))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "administration"));
                        yield return error;
                    }
                }

                foreach (var error in Verification.VerifyIdentifier(that.Id))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "id"));
                    yield return error;
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.EmbeddedDataSpecifications != null)
                {
                    int indexEmbeddedDataSpecifications = 0;
                    foreach (var item in that.EmbeddedDataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexEmbeddedDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "embeddedDataSpecifications"));
                            yield return error;
                        }
                        indexEmbeddedDataSpecifications++;
                    }
                }

                if (that.SubmodelElements != null)
                {
                    int indexSubmodelElements = 0;
                    foreach (var item in that.SubmodelElements)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSubmodelElements));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "submodelElements"));
                            yield return error;
                        }
                        indexSubmodelElements++;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.RelationshipElement that)
            {
                if (!(
                    !(that.Extensions != null)
                    || (that.Extensions.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Extensions must be either not set or have at least one item");
                }

                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.");
                }

                if (!(
                    !(that.Description != null)
                    || (that.Description.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description must be either not set or have at least one item");
                }

                if (!(
                    !(that.Description != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.Description)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description specifies no duplicate languages");
                }

                if (!(
                    !(that.DisplayName != null)
                    || (that.DisplayName.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name must be either not set or have at least one " +
                        "item");
                }

                if (!(
                    !(that.DisplayName != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.DisplayName)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name specifies no duplicate languages");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SupplementalSemanticIds.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Supplemental semantic IDs must be either not set or have at " +
                        "least one item");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (that.Qualifiers.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Qualifiers must be either not set or have at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.");
                }

                if (!(
                    !(that.EmbeddedDataSpecifications != null)
                    || (that.EmbeddedDataSpecifications.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Embedded data specifications must be either not set or have " +
                        "at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    int indexDisplayName = 0;
                    foreach (var item in that.DisplayName)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDisplayName));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "displayName"));
                            yield return error;
                        }
                        indexDisplayName++;
                    }
                }

                if (that.Description != null)
                {
                    int indexDescription = 0;
                    foreach (var item in that.Description)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDescription));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "description"));
                            yield return error;
                        }
                        indexDescription++;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.EmbeddedDataSpecifications != null)
                {
                    int indexEmbeddedDataSpecifications = 0;
                    foreach (var item in that.EmbeddedDataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexEmbeddedDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "embeddedDataSpecifications"));
                            yield return error;
                        }
                        indexEmbeddedDataSpecifications++;
                    }
                }

                foreach (var error in Verification.Verify(that.First))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "first"));
                    yield return error;
                }

                foreach (var error in Verification.Verify(that.Second))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "second"));
                    yield return error;
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.SubmodelElementList that)
            {
                if (!(
                    !(that.Extensions != null)
                    || (that.Extensions.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Extensions must be either not set or have at least one item");
                }

                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.");
                }

                if (!(
                    !(that.Description != null)
                    || (that.Description.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description must be either not set or have at least one item");
                }

                if (!(
                    !(that.Description != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.Description)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description specifies no duplicate languages");
                }

                if (!(
                    !(that.DisplayName != null)
                    || (that.DisplayName.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name must be either not set or have at least one " +
                        "item");
                }

                if (!(
                    !(that.DisplayName != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.DisplayName)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name specifies no duplicate languages");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SupplementalSemanticIds.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Supplemental semantic IDs must be either not set or have at " +
                        "least one item");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (that.Qualifiers.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Qualifiers must be either not set or have at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.");
                }

                if (!(
                    !(that.EmbeddedDataSpecifications != null)
                    || (that.EmbeddedDataSpecifications.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Embedded data specifications must be either not set or have " +
                        "at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.");
                }

                if (!(
                    !(that.Value != null)
                    || (that.Value.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Value must be either not set or have at least one item");
                }

                if (!(
                    !(
                        (that.Value != null)
                        && (that.SemanticIdListElement != null)
                    )
                    || (
                        that.Value.All(
                            child => !(child.SemanticId != null)
                                || Verification.ReferenceKeyValuesEqual(child.SemanticId, that.SemanticIdListElement))
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-107: If a first level child element has " +
                        "a semantic ID it shall be identical to semantic ID list " +
                        "element.");
                }

                if (!(
                    !(that.Value != null)
                    || Verification.SubmodelElementsHaveIdenticalSemanticIds(that.Value)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-114: If two first level child elements have " +
                        "a semantic ID then they shall be identical.");
                }

                if (!(
                    !(that.Value != null)
                    || (
                        that.Value.All(
                            element => Verification.SubmodelElementIsOfType(element, that.TypeValueListElement))
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-108: All first level child elements shall " +
                        "have the same submodel element type as specified in type " +
                        "value list element.");
                }

                if (!(
                    !(
                        (that.Value != null)
                        && (
                            that.TypeValueListElement == AasSubmodelElements.Property
                            || that.TypeValueListElement == AasSubmodelElements.Range
                        )
                    )
                    || (
                        (that.ValueTypeListElement != null)
                        && Verification.PropertiesOrRangesHaveValueType(that.Value, that.ValueTypeListElement)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-109: If type value list element is equal to " +
                        "Property or Range value type list element shall be set and " +
                        "all first level child elements shall have the value type as " +
                        "specified in value type list element.");
                }

                if (!(
                    !(that.Value != null)
                    || (
                        that.Value.All(
                            element => element.IdShort == null)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-120: ID-shorts of submodel elements within " +
                        "a SubmodelElementList shall not be specified.");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    int indexDisplayName = 0;
                    foreach (var item in that.DisplayName)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDisplayName));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "displayName"));
                            yield return error;
                        }
                        indexDisplayName++;
                    }
                }

                if (that.Description != null)
                {
                    int indexDescription = 0;
                    foreach (var item in that.Description)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDescription));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "description"));
                            yield return error;
                        }
                        indexDescription++;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.EmbeddedDataSpecifications != null)
                {
                    int indexEmbeddedDataSpecifications = 0;
                    foreach (var item in that.EmbeddedDataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexEmbeddedDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "embeddedDataSpecifications"));
                            yield return error;
                        }
                        indexEmbeddedDataSpecifications++;
                    }
                }

                if (that.Value != null)
                {
                    int indexValue = 0;
                    foreach (var item in that.Value)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexValue));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "value"));
                            yield return error;
                        }
                        indexValue++;
                    }
                }

                if (that.SemanticIdListElement != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticIdListElement))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticIdListElement"));
                        yield return error;
                    }
                }

                foreach (
                        var error in Verification.VerifyAasSubmodelElements(
                            that.TypeValueListElement))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "typeValueListElement"));
                    yield return error;
                }

                if (that.ValueTypeListElement != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.DataTypeDefXsd value = that.ValueTypeListElement
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyDataTypeDefXsd(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "valueTypeListElement"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.SubmodelElementCollection that)
            {
                if (!(
                    !(that.Extensions != null)
                    || (that.Extensions.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Extensions must be either not set or have at least one item");
                }

                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.");
                }

                if (!(
                    !(that.Description != null)
                    || (that.Description.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description must be either not set or have at least one item");
                }

                if (!(
                    !(that.Description != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.Description)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description specifies no duplicate languages");
                }

                if (!(
                    !(that.DisplayName != null)
                    || (that.DisplayName.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name must be either not set or have at least one " +
                        "item");
                }

                if (!(
                    !(that.DisplayName != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.DisplayName)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name specifies no duplicate languages");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SupplementalSemanticIds.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Supplemental semantic IDs must be either not set or have at " +
                        "least one item");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (that.Qualifiers.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Qualifiers must be either not set or have at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.");
                }

                if (!(
                    !(that.EmbeddedDataSpecifications != null)
                    || (that.EmbeddedDataSpecifications.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Embedded data specifications must be either not set or have " +
                        "at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.");
                }

                if (!(
                    !(that.Value != null)
                    || (that.Value.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Value must be either not set or have at least one item");
                }

                if (!(
                    !(that.Value != null)
                    || (
                        that.Value.All(
                            element => element.IdShort != null)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "ID-shorts need to be defined for all the elements.");
                }

                if (!(
                    !(that.Value != null)
                    || Verification.IdShortsAreUnique(that.Value)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "ID-shorts of the value must be unique.");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    int indexDisplayName = 0;
                    foreach (var item in that.DisplayName)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDisplayName));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "displayName"));
                            yield return error;
                        }
                        indexDisplayName++;
                    }
                }

                if (that.Description != null)
                {
                    int indexDescription = 0;
                    foreach (var item in that.Description)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDescription));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "description"));
                            yield return error;
                        }
                        indexDescription++;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.EmbeddedDataSpecifications != null)
                {
                    int indexEmbeddedDataSpecifications = 0;
                    foreach (var item in that.EmbeddedDataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexEmbeddedDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "embeddedDataSpecifications"));
                            yield return error;
                        }
                        indexEmbeddedDataSpecifications++;
                    }
                }

                if (that.Value != null)
                {
                    int indexValue = 0;
                    foreach (var item in that.Value)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexValue));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "value"));
                            yield return error;
                        }
                        indexValue++;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.Property that)
            {
                if (!(
                    !(that.Extensions != null)
                    || (that.Extensions.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Extensions must be either not set or have at least one item");
                }

                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.");
                }

                if (!(
                    !(that.Description != null)
                    || (that.Description.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description must be either not set or have at least one item");
                }

                if (!(
                    !(that.Description != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.Description)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description specifies no duplicate languages");
                }

                if (!(
                    !(that.DisplayName != null)
                    || (that.DisplayName.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name must be either not set or have at least one " +
                        "item");
                }

                if (!(
                    !(that.DisplayName != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.DisplayName)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name specifies no duplicate languages");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SupplementalSemanticIds.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Supplemental semantic IDs must be either not set or have at " +
                        "least one item");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (that.Qualifiers.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Qualifiers must be either not set or have at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.");
                }

                if (!(
                    !(that.EmbeddedDataSpecifications != null)
                    || (that.EmbeddedDataSpecifications.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Embedded data specifications must be either not set or have " +
                        "at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.");
                }

                if (!(
                    !(that.Category != null)
                    || Aas.Constants.ValidCategoriesForDataElement.Contains(that.Category)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-090: For data elements category shall be " +
                        "one of the following values: CONSTANT, PARAMETER or VARIABLE");
                }

                if (!(
                    !(that.Value != null)
                    || Verification.ValueConsistentWithXsdType(that.Value, that.ValueType)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Value must be consistent with the value type.");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    int indexDisplayName = 0;
                    foreach (var item in that.DisplayName)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDisplayName));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "displayName"));
                            yield return error;
                        }
                        indexDisplayName++;
                    }
                }

                if (that.Description != null)
                {
                    int indexDescription = 0;
                    foreach (var item in that.Description)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDescription));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "description"));
                            yield return error;
                        }
                        indexDescription++;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.EmbeddedDataSpecifications != null)
                {
                    int indexEmbeddedDataSpecifications = 0;
                    foreach (var item in that.EmbeddedDataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexEmbeddedDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "embeddedDataSpecifications"));
                            yield return error;
                        }
                        indexEmbeddedDataSpecifications++;
                    }
                }

                foreach (var error in Verification.VerifyDataTypeDefXsd(that.ValueType))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "valueType"));
                    yield return error;
                }

                if (that.Value != null)
                {
                    foreach (var error in Verification.VerifyValueDataType(that.Value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "value"));
                        yield return error;
                    }
                }

                if (that.ValueId != null)
                {
                    foreach (var error in Verification.Verify(that.ValueId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "valueId"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.MultiLanguageProperty that)
            {
                if (!(
                    !(that.Extensions != null)
                    || (that.Extensions.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Extensions must be either not set or have at least one item");
                }

                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.");
                }

                if (!(
                    !(that.Description != null)
                    || (that.Description.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description must be either not set or have at least one item");
                }

                if (!(
                    !(that.Description != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.Description)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description specifies no duplicate languages");
                }

                if (!(
                    !(that.DisplayName != null)
                    || (that.DisplayName.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name must be either not set or have at least one " +
                        "item");
                }

                if (!(
                    !(that.DisplayName != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.DisplayName)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name specifies no duplicate languages");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SupplementalSemanticIds.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Supplemental semantic IDs must be either not set or have at " +
                        "least one item");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (that.Qualifiers.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Qualifiers must be either not set or have at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.");
                }

                if (!(
                    !(that.EmbeddedDataSpecifications != null)
                    || (that.EmbeddedDataSpecifications.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Embedded data specifications must be either not set or have " +
                        "at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.");
                }

                if (!(
                    !(that.Category != null)
                    || Aas.Constants.ValidCategoriesForDataElement.Contains(that.Category)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-090: For data elements category shall be " +
                        "one of the following values: CONSTANT, PARAMETER or VARIABLE");
                }

                if (!(
                    !(that.Value != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.Value)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Value specifies no duplicate languages");
                }

                if (!(
                    !(that.Value != null)
                    || (that.Value.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Value must be either not set or have at least one item");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    int indexDisplayName = 0;
                    foreach (var item in that.DisplayName)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDisplayName));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "displayName"));
                            yield return error;
                        }
                        indexDisplayName++;
                    }
                }

                if (that.Description != null)
                {
                    int indexDescription = 0;
                    foreach (var item in that.Description)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDescription));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "description"));
                            yield return error;
                        }
                        indexDescription++;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.EmbeddedDataSpecifications != null)
                {
                    int indexEmbeddedDataSpecifications = 0;
                    foreach (var item in that.EmbeddedDataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexEmbeddedDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "embeddedDataSpecifications"));
                            yield return error;
                        }
                        indexEmbeddedDataSpecifications++;
                    }
                }

                if (that.Value != null)
                {
                    int indexValue = 0;
                    foreach (var item in that.Value)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexValue));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "value"));
                            yield return error;
                        }
                        indexValue++;
                    }
                }

                if (that.ValueId != null)
                {
                    foreach (var error in Verification.Verify(that.ValueId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "valueId"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.Range that)
            {
                if (!(
                    !(that.Extensions != null)
                    || (that.Extensions.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Extensions must be either not set or have at least one item");
                }

                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.");
                }

                if (!(
                    !(that.Description != null)
                    || (that.Description.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description must be either not set or have at least one item");
                }

                if (!(
                    !(that.Description != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.Description)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description specifies no duplicate languages");
                }

                if (!(
                    !(that.DisplayName != null)
                    || (that.DisplayName.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name must be either not set or have at least one " +
                        "item");
                }

                if (!(
                    !(that.DisplayName != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.DisplayName)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name specifies no duplicate languages");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SupplementalSemanticIds.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Supplemental semantic IDs must be either not set or have at " +
                        "least one item");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (that.Qualifiers.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Qualifiers must be either not set or have at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.");
                }

                if (!(
                    !(that.EmbeddedDataSpecifications != null)
                    || (that.EmbeddedDataSpecifications.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Embedded data specifications must be either not set or have " +
                        "at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.");
                }

                if (!(
                    !(that.Category != null)
                    || Aas.Constants.ValidCategoriesForDataElement.Contains(that.Category)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-090: For data elements category shall be " +
                        "one of the following values: CONSTANT, PARAMETER or VARIABLE");
                }

                if (!(
                    !(that.Max != null)
                    || Verification.ValueConsistentWithXsdType(that.Max, that.ValueType)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Max must be consistent with the value type.");
                }

                if (!(
                    !(that.Min != null)
                    || Verification.ValueConsistentWithXsdType(that.Min, that.ValueType)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Min must be consistent with the value type.");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    int indexDisplayName = 0;
                    foreach (var item in that.DisplayName)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDisplayName));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "displayName"));
                            yield return error;
                        }
                        indexDisplayName++;
                    }
                }

                if (that.Description != null)
                {
                    int indexDescription = 0;
                    foreach (var item in that.Description)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDescription));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "description"));
                            yield return error;
                        }
                        indexDescription++;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.EmbeddedDataSpecifications != null)
                {
                    int indexEmbeddedDataSpecifications = 0;
                    foreach (var item in that.EmbeddedDataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexEmbeddedDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "embeddedDataSpecifications"));
                            yield return error;
                        }
                        indexEmbeddedDataSpecifications++;
                    }
                }

                foreach (var error in Verification.VerifyDataTypeDefXsd(that.ValueType))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "valueType"));
                    yield return error;
                }

                if (that.Min != null)
                {
                    foreach (var error in Verification.VerifyValueDataType(that.Min))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "min"));
                        yield return error;
                    }
                }

                if (that.Max != null)
                {
                    foreach (var error in Verification.VerifyValueDataType(that.Max))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "max"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.ReferenceElement that)
            {
                if (!(
                    !(that.Extensions != null)
                    || (that.Extensions.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Extensions must be either not set or have at least one item");
                }

                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.");
                }

                if (!(
                    !(that.Description != null)
                    || (that.Description.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description must be either not set or have at least one item");
                }

                if (!(
                    !(that.Description != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.Description)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description specifies no duplicate languages");
                }

                if (!(
                    !(that.DisplayName != null)
                    || (that.DisplayName.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name must be either not set or have at least one " +
                        "item");
                }

                if (!(
                    !(that.DisplayName != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.DisplayName)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name specifies no duplicate languages");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SupplementalSemanticIds.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Supplemental semantic IDs must be either not set or have at " +
                        "least one item");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (that.Qualifiers.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Qualifiers must be either not set or have at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.");
                }

                if (!(
                    !(that.EmbeddedDataSpecifications != null)
                    || (that.EmbeddedDataSpecifications.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Embedded data specifications must be either not set or have " +
                        "at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.");
                }

                if (!(
                    !(that.Category != null)
                    || Aas.Constants.ValidCategoriesForDataElement.Contains(that.Category)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-090: For data elements category shall be " +
                        "one of the following values: CONSTANT, PARAMETER or VARIABLE");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    int indexDisplayName = 0;
                    foreach (var item in that.DisplayName)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDisplayName));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "displayName"));
                            yield return error;
                        }
                        indexDisplayName++;
                    }
                }

                if (that.Description != null)
                {
                    int indexDescription = 0;
                    foreach (var item in that.Description)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDescription));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "description"));
                            yield return error;
                        }
                        indexDescription++;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.EmbeddedDataSpecifications != null)
                {
                    int indexEmbeddedDataSpecifications = 0;
                    foreach (var item in that.EmbeddedDataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexEmbeddedDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "embeddedDataSpecifications"));
                            yield return error;
                        }
                        indexEmbeddedDataSpecifications++;
                    }
                }

                if (that.Value != null)
                {
                    foreach (var error in Verification.Verify(that.Value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "value"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.Blob that)
            {
                if (!(
                    !(that.Extensions != null)
                    || (that.Extensions.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Extensions must be either not set or have at least one item");
                }

                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.");
                }

                if (!(
                    !(that.Description != null)
                    || (that.Description.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description must be either not set or have at least one item");
                }

                if (!(
                    !(that.Description != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.Description)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description specifies no duplicate languages");
                }

                if (!(
                    !(that.DisplayName != null)
                    || (that.DisplayName.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name must be either not set or have at least one " +
                        "item");
                }

                if (!(
                    !(that.DisplayName != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.DisplayName)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name specifies no duplicate languages");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SupplementalSemanticIds.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Supplemental semantic IDs must be either not set or have at " +
                        "least one item");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (that.Qualifiers.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Qualifiers must be either not set or have at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.");
                }

                if (!(
                    !(that.EmbeddedDataSpecifications != null)
                    || (that.EmbeddedDataSpecifications.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Embedded data specifications must be either not set or have " +
                        "at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.");
                }

                if (!(
                    !(that.Category != null)
                    || Aas.Constants.ValidCategoriesForDataElement.Contains(that.Category)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-090: For data elements category shall be " +
                        "one of the following values: CONSTANT, PARAMETER or VARIABLE");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    int indexDisplayName = 0;
                    foreach (var item in that.DisplayName)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDisplayName));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "displayName"));
                            yield return error;
                        }
                        indexDisplayName++;
                    }
                }

                if (that.Description != null)
                {
                    int indexDescription = 0;
                    foreach (var item in that.Description)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDescription));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "description"));
                            yield return error;
                        }
                        indexDescription++;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.EmbeddedDataSpecifications != null)
                {
                    int indexEmbeddedDataSpecifications = 0;
                    foreach (var item in that.EmbeddedDataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexEmbeddedDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "embeddedDataSpecifications"));
                            yield return error;
                        }
                        indexEmbeddedDataSpecifications++;
                    }
                }

                if (that.Value != null)
                {
                    foreach (var error in Verification.VerifyBlobType(that.Value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "value"));
                        yield return error;
                    }
                }

                foreach (var error in Verification.VerifyContentType(that.ContentType))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "contentType"));
                    yield return error;
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.File that)
            {
                if (!(
                    !(that.Extensions != null)
                    || (that.Extensions.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Extensions must be either not set or have at least one item");
                }

                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.");
                }

                if (!(
                    !(that.Description != null)
                    || (that.Description.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description must be either not set or have at least one item");
                }

                if (!(
                    !(that.Description != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.Description)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description specifies no duplicate languages");
                }

                if (!(
                    !(that.DisplayName != null)
                    || (that.DisplayName.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name must be either not set or have at least one " +
                        "item");
                }

                if (!(
                    !(that.DisplayName != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.DisplayName)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name specifies no duplicate languages");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SupplementalSemanticIds.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Supplemental semantic IDs must be either not set or have at " +
                        "least one item");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (that.Qualifiers.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Qualifiers must be either not set or have at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.");
                }

                if (!(
                    !(that.EmbeddedDataSpecifications != null)
                    || (that.EmbeddedDataSpecifications.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Embedded data specifications must be either not set or have " +
                        "at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.");
                }

                if (!(
                    !(that.Category != null)
                    || Aas.Constants.ValidCategoriesForDataElement.Contains(that.Category)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-090: For data elements category shall be " +
                        "one of the following values: CONSTANT, PARAMETER or VARIABLE");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    int indexDisplayName = 0;
                    foreach (var item in that.DisplayName)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDisplayName));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "displayName"));
                            yield return error;
                        }
                        indexDisplayName++;
                    }
                }

                if (that.Description != null)
                {
                    int indexDescription = 0;
                    foreach (var item in that.Description)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDescription));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "description"));
                            yield return error;
                        }
                        indexDescription++;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.EmbeddedDataSpecifications != null)
                {
                    int indexEmbeddedDataSpecifications = 0;
                    foreach (var item in that.EmbeddedDataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexEmbeddedDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "embeddedDataSpecifications"));
                            yield return error;
                        }
                        indexEmbeddedDataSpecifications++;
                    }
                }

                if (that.Value != null)
                {
                    foreach (var error in Verification.VerifyPathType(that.Value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "value"));
                        yield return error;
                    }
                }

                foreach (var error in Verification.VerifyContentType(that.ContentType))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "contentType"));
                    yield return error;
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.AnnotatedRelationshipElement that)
            {
                if (!(
                    !(that.Extensions != null)
                    || (that.Extensions.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Extensions must be either not set or have at least one item");
                }

                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.");
                }

                if (!(
                    !(that.Description != null)
                    || (that.Description.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description must be either not set or have at least one item");
                }

                if (!(
                    !(that.Description != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.Description)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description specifies no duplicate languages");
                }

                if (!(
                    !(that.DisplayName != null)
                    || (that.DisplayName.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name must be either not set or have at least one " +
                        "item");
                }

                if (!(
                    !(that.DisplayName != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.DisplayName)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name specifies no duplicate languages");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SupplementalSemanticIds.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Supplemental semantic IDs must be either not set or have at " +
                        "least one item");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (that.Qualifiers.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Qualifiers must be either not set or have at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.");
                }

                if (!(
                    !(that.EmbeddedDataSpecifications != null)
                    || (that.EmbeddedDataSpecifications.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Embedded data specifications must be either not set or have " +
                        "at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.");
                }

                if (!(
                    !(that.Annotations != null)
                    || (that.Annotations.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Annotations must be either not set or have at least one item");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    int indexDisplayName = 0;
                    foreach (var item in that.DisplayName)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDisplayName));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "displayName"));
                            yield return error;
                        }
                        indexDisplayName++;
                    }
                }

                if (that.Description != null)
                {
                    int indexDescription = 0;
                    foreach (var item in that.Description)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDescription));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "description"));
                            yield return error;
                        }
                        indexDescription++;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.EmbeddedDataSpecifications != null)
                {
                    int indexEmbeddedDataSpecifications = 0;
                    foreach (var item in that.EmbeddedDataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexEmbeddedDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "embeddedDataSpecifications"));
                            yield return error;
                        }
                        indexEmbeddedDataSpecifications++;
                    }
                }

                foreach (var error in Verification.Verify(that.First))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "first"));
                    yield return error;
                }

                foreach (var error in Verification.Verify(that.Second))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "second"));
                    yield return error;
                }

                if (that.Annotations != null)
                {
                    int indexAnnotations = 0;
                    foreach (var item in that.Annotations)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexAnnotations));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "annotations"));
                            yield return error;
                        }
                        indexAnnotations++;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.Entity that)
            {
                if (!(
                    !(that.Extensions != null)
                    || (that.Extensions.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Extensions must be either not set or have at least one item");
                }

                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.");
                }

                if (!(
                    !(that.Description != null)
                    || (that.Description.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description must be either not set or have at least one item");
                }

                if (!(
                    !(that.Description != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.Description)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description specifies no duplicate languages");
                }

                if (!(
                    !(that.DisplayName != null)
                    || (that.DisplayName.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name must be either not set or have at least one " +
                        "item");
                }

                if (!(
                    !(that.DisplayName != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.DisplayName)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name specifies no duplicate languages");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SupplementalSemanticIds.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Supplemental semantic IDs must be either not set or have at " +
                        "least one item");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (that.Qualifiers.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Qualifiers must be either not set or have at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.");
                }

                if (!(
                    !(that.EmbeddedDataSpecifications != null)
                    || (that.EmbeddedDataSpecifications.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Embedded data specifications must be either not set or have " +
                        "at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.");
                }

                if (!(
                    !(that.Statements != null)
                    || (that.Statements.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Statements must be either not set or have at least one item");
                }

                if (!(
                    (
                        that.EntityType == EntityType.SelfManagedEntity
                        && (
                            (
                                (that.GlobalAssetId != null)
                                && (that.SpecificAssetId == null)
                            )
                            || (
                                (that.GlobalAssetId == null)
                                && (that.SpecificAssetId != null)
                            )
                        )
                    )
                    || (
                        (that.GlobalAssetId == null)
                        && (that.SpecificAssetId == null)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-014: Either the attribute global asset ID " +
                        "or specific asset ID must be set if entity type is set to " +
                        "'SelfManagedEntity'. They are not existing otherwise.");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    int indexDisplayName = 0;
                    foreach (var item in that.DisplayName)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDisplayName));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "displayName"));
                            yield return error;
                        }
                        indexDisplayName++;
                    }
                }

                if (that.Description != null)
                {
                    int indexDescription = 0;
                    foreach (var item in that.Description)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDescription));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "description"));
                            yield return error;
                        }
                        indexDescription++;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.EmbeddedDataSpecifications != null)
                {
                    int indexEmbeddedDataSpecifications = 0;
                    foreach (var item in that.EmbeddedDataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexEmbeddedDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "embeddedDataSpecifications"));
                            yield return error;
                        }
                        indexEmbeddedDataSpecifications++;
                    }
                }

                if (that.Statements != null)
                {
                    int indexStatements = 0;
                    foreach (var item in that.Statements)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexStatements));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "statements"));
                            yield return error;
                        }
                        indexStatements++;
                    }
                }

                foreach (var error in Verification.VerifyEntityType(that.EntityType))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "entityType"));
                    yield return error;
                }

                if (that.GlobalAssetId != null)
                {
                    foreach (var error in Verification.Verify(that.GlobalAssetId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "globalAssetId"));
                        yield return error;
                    }
                }

                if (that.SpecificAssetId != null)
                {
                    foreach (var error in Verification.Verify(that.SpecificAssetId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "specificAssetId"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.EventPayload that)
            {
                if (!(
                    Verification.IsModelReferenceToReferable(that.Source)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Source must be a model reference to a referable.");
                }

                if (!(
                    Verification.IsModelReferenceToReferable(that.ObservableReference)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Observable reference must be a model reference to " +
                        "a referable.");
                }

                foreach (var error in Verification.Verify(that.Source))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "source"));
                    yield return error;
                }

                if (that.SourceSemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SourceSemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "sourceSemanticId"));
                        yield return error;
                    }
                }

                foreach (var error in Verification.Verify(that.ObservableReference))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "observableReference"));
                    yield return error;
                }

                if (that.ObservableSemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.ObservableSemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "observableSemanticId"));
                        yield return error;
                    }
                }

                if (that.Topic != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Topic))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "topic"));
                        yield return error;
                    }
                }

                if (that.SubjectId != null)
                {
                    foreach (var error in Verification.Verify(that.SubjectId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "subjectId"));
                        yield return error;
                    }
                }

                foreach (var error in Verification.VerifyDateTimeStampUtc(that.TimeStamp))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "timeStamp"));
                    yield return error;
                }

                if (that.Payload != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Payload))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "payload"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.BasicEventElement that)
            {
                if (!(
                    !(that.Extensions != null)
                    || (that.Extensions.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Extensions must be either not set or have at least one item");
                }

                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.");
                }

                if (!(
                    !(that.Description != null)
                    || (that.Description.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description must be either not set or have at least one item");
                }

                if (!(
                    !(that.Description != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.Description)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description specifies no duplicate languages");
                }

                if (!(
                    !(that.DisplayName != null)
                    || (that.DisplayName.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name must be either not set or have at least one " +
                        "item");
                }

                if (!(
                    !(that.DisplayName != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.DisplayName)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name specifies no duplicate languages");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SupplementalSemanticIds.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Supplemental semantic IDs must be either not set or have at " +
                        "least one item");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (that.Qualifiers.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Qualifiers must be either not set or have at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.");
                }

                if (!(
                    !(that.EmbeddedDataSpecifications != null)
                    || (that.EmbeddedDataSpecifications.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Embedded data specifications must be either not set or have " +
                        "at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.");
                }

                if (!(
                    !(that.Direction == Direction.Input)
                    || (that.MaxInterval == null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Max. interval is not applicable for input direction");
                }

                if (!(
                    Verification.IsModelReferenceToReferable(that.Observed)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Observed must be a model reference to a referable.");
                }

                if (!(
                    !(that.MessageBroker != null)
                    || Verification.IsModelReferenceToReferable(that.MessageBroker)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Message broker must be a model reference to a referable.");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    int indexDisplayName = 0;
                    foreach (var item in that.DisplayName)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDisplayName));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "displayName"));
                            yield return error;
                        }
                        indexDisplayName++;
                    }
                }

                if (that.Description != null)
                {
                    int indexDescription = 0;
                    foreach (var item in that.Description)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDescription));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "description"));
                            yield return error;
                        }
                        indexDescription++;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.EmbeddedDataSpecifications != null)
                {
                    int indexEmbeddedDataSpecifications = 0;
                    foreach (var item in that.EmbeddedDataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexEmbeddedDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "embeddedDataSpecifications"));
                            yield return error;
                        }
                        indexEmbeddedDataSpecifications++;
                    }
                }

                foreach (var error in Verification.Verify(that.Observed))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "observed"));
                    yield return error;
                }

                foreach (var error in Verification.VerifyDirection(that.Direction))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "direction"));
                    yield return error;
                }

                foreach (var error in Verification.VerifyStateOfEvent(that.State))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "state"));
                    yield return error;
                }

                if (that.MessageTopic != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.MessageTopic))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "messageTopic"));
                        yield return error;
                    }
                }

                if (that.MessageBroker != null)
                {
                    foreach (var error in Verification.Verify(that.MessageBroker))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "messageBroker"));
                        yield return error;
                    }
                }

                if (that.LastUpdate != null)
                {
                    foreach (var error in Verification.VerifyDateTimeStampUtc(that.LastUpdate))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "lastUpdate"));
                        yield return error;
                    }
                }

                if (that.MinInterval != null)
                {
                    foreach (var error in Verification.VerifyDateTimeStampUtc(that.MinInterval))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "minInterval"));
                        yield return error;
                    }
                }

                if (that.MaxInterval != null)
                {
                    foreach (var error in Verification.VerifyDateTimeStampUtc(that.MaxInterval))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "maxInterval"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.Operation that)
            {
                if (!(
                    !(that.Extensions != null)
                    || (that.Extensions.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Extensions must be either not set or have at least one item");
                }

                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.");
                }

                if (!(
                    !(that.Description != null)
                    || (that.Description.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description must be either not set or have at least one item");
                }

                if (!(
                    !(that.Description != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.Description)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description specifies no duplicate languages");
                }

                if (!(
                    !(that.DisplayName != null)
                    || (that.DisplayName.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name must be either not set or have at least one " +
                        "item");
                }

                if (!(
                    !(that.DisplayName != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.DisplayName)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name specifies no duplicate languages");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SupplementalSemanticIds.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Supplemental semantic IDs must be either not set or have at " +
                        "least one item");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (that.Qualifiers.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Qualifiers must be either not set or have at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.");
                }

                if (!(
                    !(that.EmbeddedDataSpecifications != null)
                    || (that.EmbeddedDataSpecifications.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Embedded data specifications must be either not set or have " +
                        "at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.");
                }

                if (!(
                    !(that.InputVariables != null)
                    || (that.InputVariables.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Input variables must be either not set or have at least one " +
                        "item");
                }

                if (!(
                    !(that.OutputVariables != null)
                    || (that.OutputVariables.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Output variables must be either not set or have at least " +
                        "one item");
                }

                if (!(
                    !(that.InoutputVariables != null)
                    || (that.InoutputVariables.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Inoutput variables must be either not set or have at least " +
                        "one item");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    int indexDisplayName = 0;
                    foreach (var item in that.DisplayName)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDisplayName));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "displayName"));
                            yield return error;
                        }
                        indexDisplayName++;
                    }
                }

                if (that.Description != null)
                {
                    int indexDescription = 0;
                    foreach (var item in that.Description)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDescription));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "description"));
                            yield return error;
                        }
                        indexDescription++;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.EmbeddedDataSpecifications != null)
                {
                    int indexEmbeddedDataSpecifications = 0;
                    foreach (var item in that.EmbeddedDataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexEmbeddedDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "embeddedDataSpecifications"));
                            yield return error;
                        }
                        indexEmbeddedDataSpecifications++;
                    }
                }

                if (that.InputVariables != null)
                {
                    int indexInputVariables = 0;
                    foreach (var item in that.InputVariables)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexInputVariables));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "inputVariables"));
                            yield return error;
                        }
                        indexInputVariables++;
                    }
                }

                if (that.OutputVariables != null)
                {
                    int indexOutputVariables = 0;
                    foreach (var item in that.OutputVariables)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexOutputVariables));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "outputVariables"));
                            yield return error;
                        }
                        indexOutputVariables++;
                    }
                }

                if (that.InoutputVariables != null)
                {
                    int indexInoutputVariables = 0;
                    foreach (var item in that.InoutputVariables)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexInoutputVariables));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "inoutputVariables"));
                            yield return error;
                        }
                        indexInoutputVariables++;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.OperationVariable that)
            {
                foreach (var error in Verification.Verify(that.Value))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "value"));
                    yield return error;
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.Capability that)
            {
                if (!(
                    !(that.Extensions != null)
                    || (that.Extensions.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Extensions must be either not set or have at least one item");
                }

                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.");
                }

                if (!(
                    !(that.Description != null)
                    || (that.Description.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description must be either not set or have at least one item");
                }

                if (!(
                    !(that.Description != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.Description)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description specifies no duplicate languages");
                }

                if (!(
                    !(that.DisplayName != null)
                    || (that.DisplayName.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name must be either not set or have at least one " +
                        "item");
                }

                if (!(
                    !(that.DisplayName != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.DisplayName)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name specifies no duplicate languages");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SupplementalSemanticIds.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Supplemental semantic IDs must be either not set or have at " +
                        "least one item");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (that.Qualifiers.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Qualifiers must be either not set or have at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.");
                }

                if (!(
                    !(that.EmbeddedDataSpecifications != null)
                    || (that.EmbeddedDataSpecifications.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Embedded data specifications must be either not set or have " +
                        "at least one item");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    int indexDisplayName = 0;
                    foreach (var item in that.DisplayName)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDisplayName));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "displayName"));
                            yield return error;
                        }
                        indexDisplayName++;
                    }
                }

                if (that.Description != null)
                {
                    int indexDescription = 0;
                    foreach (var item in that.Description)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDescription));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "description"));
                            yield return error;
                        }
                        indexDescription++;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.EmbeddedDataSpecifications != null)
                {
                    int indexEmbeddedDataSpecifications = 0;
                    foreach (var item in that.EmbeddedDataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexEmbeddedDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "embeddedDataSpecifications"));
                            yield return error;
                        }
                        indexEmbeddedDataSpecifications++;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.ConceptDescription that)
            {
                if (!(
                    !(that.Extensions != null)
                    || (that.Extensions.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Extensions must be either not set or have at least one item");
                }

                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.");
                }

                if (!(
                    !(that.Description != null)
                    || (that.Description.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description must be either not set or have at least one item");
                }

                if (!(
                    !(that.Description != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.Description)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Description specifies no duplicate languages");
                }

                if (!(
                    !(that.DisplayName != null)
                    || (that.DisplayName.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name must be either not set or have at least one " +
                        "item");
                }

                if (!(
                    !(that.DisplayName != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.DisplayName)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Display name specifies no duplicate languages");
                }

                if (!(
                    !(that.EmbeddedDataSpecifications != null)
                    || (that.EmbeddedDataSpecifications.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Embedded data specifications must be either not set or have " +
                        "at least one item");
                }

                if (!(
                    !(that.IsCaseOf != null)
                    || (that.IsCaseOf.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Is-case-of must be either not set or have at least one item");
                }

                if (!(
                    !(that.Category != null)
                    || Aas.Constants.ValidCategoriesForConceptDescription.Contains(that.Category)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-051: A concept description shall have one " +
                        "of the following categories: 'VALUE', 'PROPERTY', " +
                        "'REFERENCE', 'DOCUMENT', 'CAPABILITY',; 'RELATIONSHIP', " +
                        "'COLLECTION', 'FUNCTION', 'EVENT', 'ENTITY', " +
                        "'APPLICATION_CLASS', 'QUALIFIER', 'VIEW'.");
                }

                if (!(
                    !(
                        (that.Category != null)
                        && that.Category != "VALUE"
                        && (that.EmbeddedDataSpecifications != null)
                    )
                    || Verification.DataSpecificationIec61360sHaveDefinitionAtLeastInEnglish(that.EmbeddedDataSpecifications)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASc-003: For all concept descriptions with " +
                        "a category except VALUE using data specification IEC 61360, " +
                        "the definition of the data specification is mandatory and " +
                        "shall be defined at least in English.");
                }

                if (!(
                    !(
                        (that.Category != null)
                        && that.Category == "VALUE"
                        && (that.EmbeddedDataSpecifications != null)
                    )
                    || Verification.DataSpecificationIec61360sHaveValue(that.EmbeddedDataSpecifications)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASc-008: For a concept description with " +
                        "category VALUE using data specification IEC 61360, " +
                        "the value of the data specification shall be set.");
                }

                if (!(
                    !(
                        (that.Category != null)
                        && that.Category == "QUALIFIER_TYPE"
                        && (that.EmbeddedDataSpecifications != null)
                    )
                    || Verification.DataSpecificationIec61360sHaveDataType(that.EmbeddedDataSpecifications)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASc-007: For a concept description with " +
                        "category QUALIFIER_TYPE using data specification IEC 61360, " +
                        "the data type of the data specification is mandatory and " +
                        "shall be defined.");
                }

                if (!(
                    !(
                        (that.Category != null)
                        && that.Category == "DOCUMENT"
                        && (that.EmbeddedDataSpecifications != null)
                    )
                    || Verification.DataSpecificationIec61360sForDocumentHaveAppropriateDataType(that.EmbeddedDataSpecifications)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASc-006: For a concept description with " +
                        "category DOCUMENT using data specification IEC 61360, " +
                        "the data type of the data specification is mandatory and " +
                        "shall be one of: FILE, BLOB, HTML.");
                }

                if (!(
                    !(
                        (that.Category != null)
                        && that.Category == "REFERENCE"
                        && (that.EmbeddedDataSpecifications != null)
                    )
                    || Verification.DataSpecificationIec61360sForReferenceHaveAppropriateDataType(that.EmbeddedDataSpecifications)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASc-005: For a concept description with " +
                        "category REFERENCE using data specification IEC 61360, " +
                        "the data type of the data specification is mandatory and " +
                        "shall be one of: STRING, IRI, IRDI.");
                }

                if (!(
                    !(
                        (that.Category != null)
                        && (
                            that.Category == "PROPERTY"
                            || that.Category == "VALUE"
                        )
                        && (that.EmbeddedDataSpecifications != null)
                    )
                    || Verification.DataSpecificationIec61360sForPropertyOrValueHaveAppropriateDataType(that.EmbeddedDataSpecifications)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASc-004: For a concept description with " +
                        "category PROPERTY or VALUE using data specification IEC " +
                        "61360, the data type of the data specification is mandatory " +
                        "and shall be one of: DATE, STRING, STRING_TRANSLATABLE, " +
                        "INTEGER_MEASURE, INTEGER_COUNT, INTEGER_CURRENCY, " +
                        "REAL_MEASURE, REAL_COUNT, REAL_CURRENCY, BOOLEAN, RATIONAL, " +
                        "RATIONAL_MEASURE, TIME, TIMESTAMP.");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    int indexDisplayName = 0;
                    foreach (var item in that.DisplayName)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDisplayName));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "displayName"));
                            yield return error;
                        }
                        indexDisplayName++;
                    }
                }

                if (that.Description != null)
                {
                    int indexDescription = 0;
                    foreach (var item in that.Description)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDescription));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "description"));
                            yield return error;
                        }
                        indexDescription++;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Administration != null)
                {
                    foreach (var error in Verification.Verify(that.Administration))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "administration"));
                        yield return error;
                    }
                }

                foreach (var error in Verification.VerifyIdentifier(that.Id))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "id"));
                    yield return error;
                }

                if (that.EmbeddedDataSpecifications != null)
                {
                    int indexEmbeddedDataSpecifications = 0;
                    foreach (var item in that.EmbeddedDataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexEmbeddedDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "embeddedDataSpecifications"));
                            yield return error;
                        }
                        indexEmbeddedDataSpecifications++;
                    }
                }

                if (that.IsCaseOf != null)
                {
                    int indexIsCaseOf = 0;
                    foreach (var item in that.IsCaseOf)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexIsCaseOf));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "isCaseOf"));
                            yield return error;
                        }
                        indexIsCaseOf++;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.Reference that)
            {
                if (!(that.Keys.Count >= 1))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Keys must contain at least one item.");
                }

                if (!(
                    !(that.Keys.Count >= 1)
                    || Aas.Constants.GloballyIdentifiables.Contains(that.Keys[0].Type)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-121: For References the type of the first " +
                        "key shall be one of Globally identifiables.");
                }

                if (!(
                    !(
                        that.Type == ReferenceTypes.GlobalReference
                        && that.Keys.Count >= 1
                    )
                    || Aas.Constants.GenericGloballyIdentifiables.Contains(that.Keys[0].Type)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-122: For global references the type of " +
                        "the first key shall be one of Generic globally " +
                        "identifiables.");
                }

                if (!(
                    !(
                        that.Type == ReferenceTypes.ModelReference
                        && that.Keys.Count >= 1
                    )
                    || Aas.Constants.AasIdentifiables.Contains(that.Keys[0].Type)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-123: For model references the type of " +
                        "the first key shall be one of AAS identifiables");
                }

                if (!(
                    !(
                        that.Type == ReferenceTypes.GlobalReference
                        && that.Keys.Count >= 1
                    )
                    || (
                        Aas.Constants.GenericGloballyIdentifiables.Contains(that.Keys[^1].Type)
                        || Aas.Constants.GenericFragmentKeys.Contains(that.Keys[^1].Type)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-124: For global references the last key " +
                        "shall be either one of Generic globally identifiables or " +
                        "one of Generic fragment keys.");
                }

                if (!(
                    !(
                        that.Type == ReferenceTypes.ModelReference
                        && that.Keys.Count > 1
                    )
                    || (
                        Enumerable.Range(
                            1,
                            that.Keys.Count - 1
                        ).All(
                            i => Aas.Constants.FragmentKeys.Contains(that.Keys[i].Type))
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-125: For model references with more than " +
                        "one key, the type of the keys following the first key shall " +
                        "be one of Fragment keys.");
                }

                if (!(
                    !(
                        that.Type == ReferenceTypes.ModelReference
                        && that.Keys.Count > 1
                    )
                    || (
                        Enumerable.Range(
                            0,
                            that.Keys.Count - 1
                        ).All(
                            i => !Aas.Constants.GenericFragmentKeys.Contains(that.Keys[i].Type))
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-126: For model references with more than " +
                        "one key, the type of the last key in the reference key " +
                        "chain may be one of Generic fragment keys or no key at all " +
                        "shall have a value out of Generic fragment keys.");
                }

                if (!(
                    !(
                        that.Type == ReferenceTypes.ModelReference
                        && that.Keys.Count > 1
                        && that.Keys[^1].Type == KeyTypes.FragmentReference
                    )
                    || (
                        that.Keys[^2].Type == KeyTypes.File
                        || that.Keys[^2].Type == KeyTypes.Blob
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-127: For model references with more than " +
                        "one key, a key with type Fragment reference shall be " +
                        "preceded by a key with type File or Blob.");
                }

                if (!(
                    !(
                        that.Type == ReferenceTypes.ModelReference
                        && that.Keys.Count > 2
                    )
                    || (
                        Enumerable.Range(
                            0,
                            that.Keys.Count - 1
                        ).All(
                            i => !(that.Keys[i].Type == KeyTypes.SubmodelElementList)
                                || Verification.MatchesXsPositiveInteger(that.Keys[i + 1].Value))
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-128: For model references, the value of " +
                        "a key preceded by a key with type Submodel element list is " +
                        "an integer number denoting the position in the array of " +
                        "the submodel element list.");
                }

                foreach (var error in Verification.VerifyReferenceTypes(that.Type))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "type"));
                    yield return error;
                }

                if (that.ReferredSemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.ReferredSemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "referredSemanticId"));
                        yield return error;
                    }
                }

                int indexKeys = 0;
                foreach (var item in that.Keys)
                {
                    foreach (var error in Verification.Verify(item))
                    {
                        error.PrependSegment(
                            new Reporting.IndexSegment(
                                indexKeys));
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "keys"));
                        yield return error;
                    }
                    indexKeys++;
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.Key that)
            {
                foreach (var error in Verification.VerifyKeyTypes(that.Type))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "type"));
                    yield return error;
                }

                foreach (var error in Verification.VerifyNonEmptyString(that.Value))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "value"));
                    yield return error;
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.LangString that)
            {
                foreach (var error in Verification.VerifyBcp47LanguageTag(that.Language))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "language"));
                    yield return error;
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.Environment that)
            {
                if (!(
                    !(that.ConceptDescriptions != null)
                    || (that.ConceptDescriptions.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Concept descriptions must be either not set or have at " +
                        "least one item");
                }

                if (!(
                    !(that.Submodels != null)
                    || (that.Submodels.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Submodels must be either not set or have at least one item");
                }

                if (!(
                    !(that.AssetAdministrationShells != null)
                    || (that.AssetAdministrationShells.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Asset administration shells must be either not set or have " +
                        "at least one item");
                }

                if (that.AssetAdministrationShells != null)
                {
                    int indexAssetAdministrationShells = 0;
                    foreach (var item in that.AssetAdministrationShells)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexAssetAdministrationShells));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "assetAdministrationShells"));
                            yield return error;
                        }
                        indexAssetAdministrationShells++;
                    }
                }

                if (that.Submodels != null)
                {
                    int indexSubmodels = 0;
                    foreach (var item in that.Submodels)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSubmodels));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "submodels"));
                            yield return error;
                        }
                        indexSubmodels++;
                    }
                }

                if (that.ConceptDescriptions != null)
                {
                    int indexConceptDescriptions = 0;
                    foreach (var item in that.ConceptDescriptions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexConceptDescriptions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "conceptDescriptions"));
                            yield return error;
                        }
                        indexConceptDescriptions++;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.EmbeddedDataSpecification that)
            {
                foreach (var error in Verification.Verify(that.DataSpecification))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "dataSpecification"));
                    yield return error;
                }

                foreach (var error in Verification.Verify(that.DataSpecificationContent))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "dataSpecificationContent"));
                    yield return error;
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.ValueReferencePair that)
            {
                foreach (var error in Verification.Verify(that.ValueId))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "valueId"));
                    yield return error;
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.ValueList that)
            {
                if (!(that.ValueReferencePairs.Count >= 1))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Value reference pair types must contain at least one item.");
                }

                int indexValueReferencePairs = 0;
                foreach (var item in that.ValueReferencePairs)
                {
                    foreach (var error in Verification.Verify(item))
                    {
                        error.PrependSegment(
                            new Reporting.IndexSegment(
                                indexValueReferencePairs));
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "valueReferencePairs"));
                        yield return error;
                    }
                    indexValueReferencePairs++;
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.DataSpecificationIec61360 that)
            {
                if (!(
                    (
                        (that.Value != null)
                        && (that.ValueList == null)
                    )
                    || (
                        (that.Value == null)
                        && (that.ValueList != null)
                        && that.ValueList.ValueReferencePairs.Count >= 1
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASc-010: If value is not empty then value list " +
                        "shall be empty and vice versa.");
                }

                if (!(
                    !(
                        (that.DataType == null)
                        && Aas.Constants.Iec61360DataTypesWithUnit.Contains(that.DataType)
                    )
                    || (
                        (that.Unit != null)
                        || (that.UnitId != null)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASc-009: If data type is a an integer, real or " +
                        "rational with a measure or currency, unit or unit ID shall " +
                        "be defined.");
                }

                if (!(
                    !(that.Definition != null)
                    || (that.Definition.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Definition must be either not set or have at least one item");
                }

                if (!(
                    !(that.Definition != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.Definition)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Definition specifies no duplicate languages");
                }

                if (!(
                    !(that.ShortName != null)
                    || (that.ShortName.Count >= 1)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Short name must be either not set or have at least one item");
                }

                if (!(
                    !(that.ShortName != null)
                    || Verification.LangStringsHaveUniqueLanguages(that.ShortName)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Short name specifies no duplicate languages");
                }

                if (!(that.PreferredName.Count >= 1))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Preferred name must have at least one item");
                }

                if (!(
                    Verification.LangStringsHaveUniqueLanguages(that.PreferredName)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Preferred name specifies no duplicate languages");
                }

                if (!(
                    that.PreferredName.Any(
                        langString => Verification.IsBcp47ForEnglish(langString.Language))))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASc-002: preferred name shall be provided at " +
                        "least in English.");
                }

                int indexPreferredName = 0;
                foreach (var item in that.PreferredName)
                {
                    foreach (var error in Verification.Verify(item))
                    {
                        error.PrependSegment(
                            new Reporting.IndexSegment(
                                indexPreferredName));
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "preferredName"));
                        yield return error;
                    }
                    indexPreferredName++;
                }

                if (that.ShortName != null)
                {
                    int indexShortName = 0;
                    foreach (var item in that.ShortName)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexShortName));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "shortName"));
                            yield return error;
                        }
                        indexShortName++;
                    }
                }

                if (that.Unit != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Unit))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "unit"));
                        yield return error;
                    }
                }

                if (that.UnitId != null)
                {
                    foreach (var error in Verification.Verify(that.UnitId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "unitId"));
                        yield return error;
                    }
                }

                if (that.SourceOfDefinition != null)
                {
                    foreach (
                            var error in Verification.VerifyNonEmptyString(
                                that.SourceOfDefinition))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "sourceOfDefinition"));
                        yield return error;
                    }
                }

                if (that.Symbol != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Symbol))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "symbol"));
                        yield return error;
                    }
                }

                if (that.DataType != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.DataTypeIec61360 value = that.DataType
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyDataTypeIec61360(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "dataType"));
                        yield return error;
                    }
                }

                if (that.Definition != null)
                {
                    int indexDefinition = 0;
                    foreach (var item in that.Definition)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDefinition));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "definition"));
                            yield return error;
                        }
                        indexDefinition++;
                    }
                }

                if (that.ValueFormat != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.ValueFormat))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "valueFormat"));
                        yield return error;
                    }
                }

                if (that.ValueList != null)
                {
                    foreach (var error in Verification.Verify(that.ValueList))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "valueList"));
                        yield return error;
                    }
                }

                if (that.LevelType != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.LevelType value = that.LevelType
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyLevelType(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "levelType"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.DataSpecificationPhysicalUnit that)
            {
                if (!(that.Definition.Count >= 1))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Definition must have at least one item");
                }

                if (!(
                    Verification.LangStringsHaveUniqueLanguages(that.Definition)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Definition specifies no duplicate languages");
                }

                foreach (var error in Verification.VerifyNonEmptyString(that.UnitName))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "unitName"));
                    yield return error;
                }

                foreach (var error in Verification.VerifyNonEmptyString(that.UnitSymbol))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "unitSymbol"));
                    yield return error;
                }

                int indexDefinition = 0;
                foreach (var item in that.Definition)
                {
                    foreach (var error in Verification.Verify(item))
                    {
                        error.PrependSegment(
                            new Reporting.IndexSegment(
                                indexDefinition));
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "definition"));
                        yield return error;
                    }
                    indexDefinition++;
                }

                if (that.SiNotation != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.SiNotation))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "siNotation"));
                        yield return error;
                    }
                }

                if (that.SiName != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.SiName))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "siName"));
                        yield return error;
                    }
                }

                if (that.DinNotation != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.DinNotation))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "dinNotation"));
                        yield return error;
                    }
                }

                if (that.EceName != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.EceName))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "eceName"));
                        yield return error;
                    }
                }

                if (that.EceCode != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.EceCode))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "eceCode"));
                        yield return error;
                    }
                }

                if (that.NistName != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.NistName))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "nistName"));
                        yield return error;
                    }
                }

                if (that.SourceOfDefinition != null)
                {
                    foreach (
                            var error in Verification.VerifyNonEmptyString(
                                that.SourceOfDefinition))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "sourceOfDefinition"));
                        yield return error;
                    }
                }

                if (that.ConversionFactor != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.ConversionFactor))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "conversionFactor"));
                        yield return error;
                    }
                }

                if (that.RegistrationAuthorityId != null)
                {
                    foreach (
                            var error in Verification.VerifyNonEmptyString(
                                that.RegistrationAuthorityId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "registrationAuthorityId"));
                        yield return error;
                    }
                }

                if (that.Supplier != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Supplier))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "supplier"));
                        yield return error;
                    }
                }
            }
        }  // private class Transformer

        /// <summary>
        /// Verify the constraints of <paramref name="that" /> recursively.
        /// </summary>
        /// <param name="that">
        /// The instance of the meta-model to be verified
        /// </param>
        public static IEnumerable<Reporting.Error> Verify(Aas.IClass that)
        {
            foreach (var error in _transformer.Transform(that))
            {
                yield return error;
            }
        }

        /// <summary>
        /// Verify the constraints of <paramref name="that" />.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyNonEmptyString(
            string that)
        {
            if (!(that.Length >= 1))
            {
                yield return new Reporting.Error(
                    "Invariant violated:\n" +
                    "Constraint AASd-100: An attribute with data type ``string`` " +
                    "is not allowed to be empty.");
            }
        }

        /// <summary>
        /// Verify the constraints of <paramref name="that" />.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyDateTimeStampUtc(
            string that)
        {
            if (!Verification.MatchesXsDateTimeStampUtc(that))
            {
                yield return new Reporting.Error(
                    "Invariant violated:\n" +
                    "The value must match the pattern of xs:dateTimeStamp with " +
                    "the time zone fixed to UTC.");
            }

            if (!Verification.IsXsDateTimeStampUtc(that))
            {
                yield return new Reporting.Error(
                    "Invariant violated:\n" +
                    "The value must represent a valid xs:dateTimeStamp with " +
                    "the time zone fixed to UTC.");
            }
        }

        /// <summary>
        /// Verify the constraints of <paramref name="that" />.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyBlobType(
            byte[] that)
        {
            // There is no verification specified.
            yield break;
        }

        /// <summary>
        /// Verify the constraints of <paramref name="that" />.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyIdentifier(
            string that)
        {
            if (!(that.Length >= 1))
            {
                yield return new Reporting.Error(
                    "Invariant violated:\n" +
                    "Constraint AASd-100: An attribute with data type ``string`` " +
                    "is not allowed to be empty.");
            }
        }

        /// <summary>
        /// Verify the constraints of <paramref name="that" />.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyBcp47LanguageTag(
            string that)
        {
            if (!Verification.MatchesBcp47(that))
            {
                yield return new Reporting.Error(
                    "Invariant violated:\n" +
                    "The value must represent a value language tag conformant to " +
                    "BCP 47.");
            }
        }

        /// <summary>
        /// Verify the constraints of <paramref name="that" />.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyContentType(
            string that)
        {
            if (!(that.Length >= 1))
            {
                yield return new Reporting.Error(
                    "Invariant violated:\n" +
                    "Constraint AASd-100: An attribute with data type ``string`` " +
                    "is not allowed to be empty.");
            }

            if (!Verification.MatchesMimeType(that))
            {
                yield return new Reporting.Error(
                    "Invariant violated:\n" +
                    "The value must represent a valid content MIME type " +
                    "according to RFC 2046.");
            }
        }

        /// <summary>
        /// Verify the constraints of <paramref name="that" />.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyPathType(
            string that)
        {
            if (!(that.Length >= 1))
            {
                yield return new Reporting.Error(
                    "Invariant violated:\n" +
                    "Constraint AASd-100: An attribute with data type ``string`` " +
                    "is not allowed to be empty.");
            }

            if (!Verification.MatchesRfc8089Path(that))
            {
                yield return new Reporting.Error(
                    "Invariant violated:\n" +
                    "The value must represent a valid file URI scheme according " +
                    "to RFC 8089.");
            }
        }

        /// <summary>
        /// Verify the constraints of <paramref name="that" />.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyQualifierType(
            string that)
        {
            if (!(that.Length >= 1))
            {
                yield return new Reporting.Error(
                    "Invariant violated:\n" +
                    "Constraint AASd-100: An attribute with data type ``string`` " +
                    "is not allowed to be empty.");
            }
        }

        /// <summary>
        /// Verify the constraints of <paramref name="that" />.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyValueDataType(
            string that)
        {
            // There is no verification specified.
            yield break;
        }

        /// <summary>
        /// Verify the constraints of <paramref name="that" />.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyIdShort(
            string that)
        {
            if (!(that.Length <= 128))
            {
                yield return new Reporting.Error(
                    "Invariant violated:\n" +
                    "Constraint AASd-027: ID-short shall have a maximum length " +
                    "of 128 characters.");
            }

            if (!Verification.MatchesIdShort(that))
            {
                yield return new Reporting.Error(
                    "Invariant violated:\n" +
                    "ID-short of Referables shall only feature letters, digits, " +
                    "underscore (``_``); starting mandatory with a letter. " +
                    "*I.e.* ``[a-zA-Z][a-zA-Z0-9_]+``.");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyModelingKind(
            Aas.ModelingKind that)
        {
            if (!EnumValueSet.ForModelingKind.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid ModelingKind: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyQualifierKind(
            Aas.QualifierKind that)
        {
            if (!EnumValueSet.ForQualifierKind.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid QualifierKind: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyAssetKind(
            Aas.AssetKind that)
        {
            if (!EnumValueSet.ForAssetKind.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid AssetKind: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyAasSubmodelElements(
            Aas.AasSubmodelElements that)
        {
            if (!EnumValueSet.ForAasSubmodelElements.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid AasSubmodelElements: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyEntityType(
            Aas.EntityType that)
        {
            if (!EnumValueSet.ForEntityType.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid EntityType: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyDirection(
            Aas.Direction that)
        {
            if (!EnumValueSet.ForDirection.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid Direction: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyStateOfEvent(
            Aas.StateOfEvent that)
        {
            if (!EnumValueSet.ForStateOfEvent.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid StateOfEvent: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyReferenceTypes(
            Aas.ReferenceTypes that)
        {
            if (!EnumValueSet.ForReferenceTypes.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid ReferenceTypes: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyKeyTypes(
            Aas.KeyTypes that)
        {
            if (!EnumValueSet.ForKeyTypes.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid KeyTypes: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyDataTypeDefXsd(
            Aas.DataTypeDefXsd that)
        {
            if (!EnumValueSet.ForDataTypeDefXsd.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid DataTypeDefXsd: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyDataTypeIec61360(
            Aas.DataTypeIec61360 that)
        {
            if (!EnumValueSet.ForDataTypeIec61360.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid DataTypeIec61360: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyLevelType(
            Aas.LevelType that)
        {
            if (!EnumValueSet.ForLevelType.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid LevelType: {that}");
            }
        }
    }  // public static class Verification
}  // namespace AasCore.Aas3_0_RC02

/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */
