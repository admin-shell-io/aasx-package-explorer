/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */

using CodeAnalysis = System.Diagnostics.CodeAnalysis;
using Regex = System.Text.RegularExpressions.Regex;
using System.Collections.Generic;  // can't alias
using System.Linq;  // can't alias

using Aas = AasCore.Aas3_0_RC02;

namespace AasCore.Aas3_0_RC02
{
    /// <summary>
    /// Verify that the instances of the meta-model satisfy the invariants.
    /// </summary>
    /// <example>
    /// Here is an example how to verify an instance of IHasSemantics:
    /// <code>
    /// var anInstance = new Aas.IHasSemantics(
    ///     // ... some constructor arguments ...
    /// );
    /// foreach (var error in Verification.Verify(anInstance))
    /// {
    ///     System.Console.Writeln(
    ///         $"{error.Cause} at: " +
    ///         Reporting.GenerateJsonPath(error.PathSegments));
    /// }
    /// </code>
    /// </example>
    public static class Verification
    {
        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesIdShort()
        {
            var pattern = "^[a-zA-Z][a-zA-Z0-9_]+$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesIdShort = _constructMatchesIdShort();

        /// <summary>
        /// Check that <paramref name="text" /> is a valid short ID.
        /// </summary>
        public static bool MatchesIdShort(string text)
        {
            return RegexMatchesIdShort.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsDateTimeStampUtc()
        {
            var digit = "[0-9]";
            var yearFrag = $"-?(([1-9]{digit}{digit}{digit}+)|(0{digit}{digit}{digit}))";
            var monthFrag = "((0[1-9])|(1[0-2]))";
            var dayFrag = $"((0[1-9])|([12]{digit})|(3[01]))";
            var hourFrag = $"(([01]{digit})|(2[0-3]))";
            var minuteFrag = $"[0-5]{digit}";
            var secondFrag = $"([0-5]{digit})(\\.{digit}+)?";
            var endOfDayFrag = "24:00:00(\\.0+)?";
            var timezoneFrag = "Z";
            var dateTimeStampLexicalRep = $"{yearFrag}-{monthFrag}-{dayFrag}T(({hourFrag}:{minuteFrag}:{secondFrag})|{endOfDayFrag}){timezoneFrag}";
            var pattern = $"^{dateTimeStampLexicalRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsDateTimeStampUtc = _constructMatchesXsDateTimeStampUtc();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:dateTimeStamp</c>.
        /// </summary>
        /// <remarks>
        /// The time zone must be fixed to UTC. We verify only that the <c>text</c> matches
        /// a pre-defined pattern. We <em>do not</em> verify that the day of month is
        /// correct nor do we check for leap seconds.
        ///
        /// See: https://www.w3.org/TR/xmlschema11-2/#dateTimeStamp
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsDateTimeStampUtc(string text)
        {
            return RegexMatchesXsDateTimeStampUtc.IsMatch(text);
        }

        private static readonly string[] XsDateFormats = {
            "yyyy-MM-dd"
        };

        /// <summary>
        /// Clip the <paramref name="value" /> to the date part.
        /// </summary>
        /// <remarks>
        /// We ignore the negative sign prefix and clip years to 4 digits.
        /// This is necessary as <see cref="System.DateTime" /> can not handle
        /// dates B.C. and the <see cref="o:System.DateTime.ParseExact" /> expects
        /// exactly four digits.
        ///
        /// We strip the negative sign and assume astronomical years.
        /// See: https://en.wikipedia.org/wiki/Leap_year#Algorithm
        ///
        /// Furthermore, we always assume that <paramref name="value" /> has been
        /// already validated with the corresponding regular expression.
        /// Hence we can use this function to validate the date-times as the time
        /// segment and offsets are correctly matched by the regular expression,
        /// while day/month combinations need to be validated by
        /// <see cref="o:System.DateTime.ParseExact" />.
        /// </remarks>
        private static string ClipToDate(string value)
        {
            int start = 0;
            if (value[0] == '-')
            {
                start++;
            }

            int yearEnd = start;
            for (; value[yearEnd] != '-'; yearEnd++)
            {
                // Intentionally empty.
            }

            return (yearEnd == 4 && value.Length == 10)
                ? value
                : value.Substring(yearEnd - 4, 10);
        }

        /// <summary>
        /// Check that <paramref name="value" /> is a <c>xs:dateTimeStamp</c> with
        /// the time zone set to UTC.
        /// </summary>
        /// <remarks>
        /// The <paramref name="value" /> is assumed to be already checked with
        /// <see cref="MatchesXsDateTimeStampUtc" />.
        /// </remarks>
        public static bool IsXsDateTimeStampUtc(
            string value
        )
        {
            if (!MatchesXsDateTimeStampUtc(value))
            {
                return false;
            }

            try
            {
                // ReSharper disable once ReturnValueOfPureMethodIsNotUsed
                System.DateTime.ParseExact(
                    ClipToDate(value),
                    XsDateFormats,
                    System.Globalization.CultureInfo.InvariantCulture,
                    System.Globalization.DateTimeStyles.None);
                return true;
            }
            catch (System.FormatException)
            {
                return false;
            }
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesMimeType()
        {
            var tchar = "[!#$%&'*+\\-.^_`|~0-9a-zA-Z]";
            var token = $"({tchar})+";
            var type = $"{token}";
            var subtype = $"{token}";
            var ows = "[ \\t]*";
            var obsText = "[\\x80-\\xff]";
            var qdText = $"([\\t !#-\\[\\]-~]|{obsText})";
            var quotedPair = $"\\\\([\\t !-~]|{obsText})";
            var quotedString = $"\"({qdText}|{quotedPair})*\"";
            var parameter = $"{token}=({token}|{quotedString})";
            var mediaType = $"^{type}/{subtype}({ows};{ows}{parameter})*$";

            return new Regex(mediaType);
        }

        private static readonly Regex RegexMatchesMimeType = _constructMatchesMimeType();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of MIME type.
        /// </summary>
        /// <remarks>
        /// The definition has been taken from:
        /// https://www.rfc-editor.org/rfc/rfc7231#section-3.1.1.1,
        /// https://www.rfc-editor.org/rfc/rfc7230#section-3.2.3 and
        /// https://www.rfc-editor.org/rfc/rfc7230#section-3.2.6.
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesMimeType(string text)
        {
            return RegexMatchesMimeType.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesRfc8089Path()
        {
            var h16 = "[0-9A-Fa-f]{1,4}";
            var decOctet = "([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])";
            var ipv4address = $"{decOctet}\\.{decOctet}\\.{decOctet}\\.{decOctet}";
            var ls32 = $"({h16}:{h16}|{ipv4address})";
            var ipv6address = $"(({h16}:){{6}}{ls32}|::({h16}:){{5}}{ls32}|({h16})?::({h16}:){{4}}{ls32}|(({h16}:)?{h16})?::({h16}:){{3}}{ls32}|(({h16}:){{2}}{h16})?::({h16}:){{2}}{ls32}|(({h16}:){{3}}{h16})?::{h16}:{ls32}|(({h16}:){{4}}{h16})?::{ls32}|(({h16}:){{5}}{h16})?::{h16}|(({h16}:){{6}}{h16})?::)";
            var unreserved = "[a-zA-Z0-9\\-._~]";
            var subDelims = "[!$&'()*+,;=]";
            var ipvfuture = $"[vV][0-9A-Fa-f]+\\.({unreserved}|{subDelims}|:)+";
            var ipLiteral = $"\\[({ipv6address}|{ipvfuture})\\]";
            var pctEncoded = "%[0-9A-Fa-f][0-9A-Fa-f]";
            var regName = $"({unreserved}|{pctEncoded}|{subDelims})*";
            var host = $"({ipLiteral}|{ipv4address}|{regName})";
            var fileAuth = $"(localhost|{host})";
            var pchar = $"({unreserved}|{pctEncoded}|{subDelims}|[:@])";
            var segmentNz = $"({pchar})+";
            var segment = $"({pchar})*";
            var pathAbsolute = $"/({segmentNz}(/{segment})*)?";
            var authPath = $"({fileAuth})?{pathAbsolute}";
            var localPath = $"{pathAbsolute}";
            var fileHierPart = $"(//{authPath}|{localPath})";
            var fileScheme = "file";
            var fileUri = $"{fileScheme}:{fileHierPart}";
            var pattern = $"^{fileUri}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesRfc8089Path = _constructMatchesRfc8089Path();

        /// <summary>
        /// Check that <paramref name="text" /> is a path conforming to the pattern of RFC 8089.
        /// </summary>
        /// <remarks>
        /// The definition has been taken from:
        /// https://datatracker.ietf.org/doc/html/rfc8089
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesRfc8089Path(string text)
        {
            return RegexMatchesRfc8089Path.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesBcp47()
        {
            var alphanum = "[a-zA-Z0-9]";
            var singleton = "[0-9A-WY-Za-wy-z]";
            var extension = $"{singleton}(-({alphanum}){{2,8}})+";
            var extlang = "[a-zA-Z]{3}(-[a-zA-Z]{3}){2}";
            var irregular = "(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)";
            var regular = "(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)";
            var grandfathered = $"({irregular}|{regular})";
            var language = $"([a-zA-Z]{{2,3}}(-{extlang})?|[a-zA-Z]{{4}}|[a-zA-Z]{{5,8}})";
            var script = "[a-zA-Z]{4}";
            var region = "([a-zA-Z]{2}|[0-9]{3})";
            var variant = $"(({alphanum}){{5,8}}|[0-9]({alphanum}){{3}})";
            var privateuse = $"[xX](-({alphanum}){{1,8}})+";
            var langtag = $"{language}(-{script})?(-{region})?(-{variant})*(-{extension})*(-{privateuse})?";
            var languageTag = $"({langtag}|{privateuse}|{grandfathered})";
            var pattern = $"^{languageTag}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesBcp47 = _constructMatchesBcp47();

        /// <summary>
        /// Check that <paramref name="text" /> is a valid BCP 47 language tag.
        /// </summary>
        /// <remarks>
        /// See: https://en.wikipedia.org/wiki/IETF_language_tag
        /// </remarks>
        public static bool MatchesBcp47(string text)
        {
            return RegexMatchesBcp47.IsMatch(text);
        }

        /// <summary>
        /// Check that <paramref name="langStrings" /> are specified each for a unique
        /// language.
        /// </summary>
        public static bool LangStringsHaveUniqueLanguages(
            IEnumerable<Aas.LangString> langStrings
        )
        {
            var languageSet = new HashSet<string>();
            foreach (var langString in langStrings)
            {
                if (languageSet.Contains(langString.Language))
                {
                    return false;
                }
                languageSet.Add(langString.Language);
            }
            return true;
        }

        /// <summary>
        /// Check that there are no duplicate <see cref="Aas.Qualifier.Type" />'s
        /// in the <paramref name="qualifiers" />.
        /// </summary>
        public static bool QualifierTypesAreUnique(
            IEnumerable<Aas.Qualifier> qualifiers
        )
        {
            var typeSet = new HashSet<string>();
            foreach (var qualifier in qualifiers)
            {
                if (typeSet.Contains(qualifier.Type))
                {
                    return false;
                }
                typeSet.Add(qualifier.Type);
            }
            return true;
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsAnyUri()
        {
            var scheme = "[a-zA-Z][a-zA-Z0-9+\\-.]*";
            var ucschar = "([\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef]|\\ud800[\\udc00-\\udfff]|[\\ud801-\\ud83e][\\udc00-\\udfff]|\\ud83f[\\udc00-\\udffd]|\\ud840[\\udc00-\\udfff]|[\\ud841-\\ud87e][\\udc00-\\udfff]|\\ud87f[\\udc00-\\udffd]|\\ud880[\\udc00-\\udfff]|[\\ud881-\\ud8be][\\udc00-\\udfff]|\\ud8bf[\\udc00-\\udffd]|\\ud8c0[\\udc00-\\udfff]|[\\ud8c1-\\ud8fe][\\udc00-\\udfff]|\\ud8ff[\\udc00-\\udffd]|\\ud900[\\udc00-\\udfff]|[\\ud901-\\ud93e][\\udc00-\\udfff]|\\ud93f[\\udc00-\\udffd]|\\ud940[\\udc00-\\udfff]|[\\ud941-\\ud97e][\\udc00-\\udfff]|\\ud97f[\\udc00-\\udffd]|\\ud980[\\udc00-\\udfff]|[\\ud981-\\ud9be][\\udc00-\\udfff]|\\ud9bf[\\udc00-\\udffd]|\\ud9c0[\\udc00-\\udfff]|[\\ud9c1-\\ud9fe][\\udc00-\\udfff]|\\ud9ff[\\udc00-\\udffd]|\\uda00[\\udc00-\\udfff]|[\\uda01-\\uda3e][\\udc00-\\udfff]|\\uda3f[\\udc00-\\udffd]|\\uda40[\\udc00-\\udfff]|[\\uda41-\\uda7e][\\udc00-\\udfff]|\\uda7f[\\udc00-\\udffd]|\\uda80[\\udc00-\\udfff]|[\\uda81-\\udabe][\\udc00-\\udfff]|\\udabf[\\udc00-\\udffd]|\\udac0[\\udc00-\\udfff]|[\\udac1-\\udafe][\\udc00-\\udfff]|\\udaff[\\udc00-\\udffd]|\\udb00[\\udc00-\\udfff]|[\\udb01-\\udb3e][\\udc00-\\udfff]|\\udb3f[\\udc00-\\udffd]|\\udb44[\\udc00-\\udfff]|[\\udb45-\\udb7e][\\udc00-\\udfff]|\\udb7f[\\udc00-\\udffd])";
            var iunreserved = $"([a-zA-Z0-9\\-._~]|{ucschar})";
            var pctEncoded = "%[0-9A-Fa-f][0-9A-Fa-f]";
            var subDelims = "[!$&'()*+,;=]";
            var iuserinfo = $"({iunreserved}|{pctEncoded}|{subDelims}|:)*";
            var h16 = "[0-9A-Fa-f]{1,4}";
            var decOctet = "([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])";
            var ipv4address = $"{decOctet}\\.{decOctet}\\.{decOctet}\\.{decOctet}";
            var ls32 = $"({h16}:{h16}|{ipv4address})";
            var ipv6address = $"(({h16}:){{6}}{ls32}|::({h16}:){{5}}{ls32}|({h16})?::({h16}:){{4}}{ls32}|(({h16}:)?{h16})?::({h16}:){{3}}{ls32}|(({h16}:){{2}}{h16})?::({h16}:){{2}}{ls32}|(({h16}:){{3}}{h16})?::{h16}:{ls32}|(({h16}:){{4}}{h16})?::{ls32}|(({h16}:){{5}}{h16})?::{h16}|(({h16}:){{6}}{h16})?::)";
            var unreserved = "[a-zA-Z0-9\\-._~]";
            var ipvfuture = $"[vV][0-9A-Fa-f]+\\.({unreserved}|{subDelims}|:)+";
            var ipLiteral = $"\\[({ipv6address}|{ipvfuture})\\]";
            var iregName = $"({iunreserved}|{pctEncoded}|{subDelims})*";
            var ihost = $"({ipLiteral}|{ipv4address}|{iregName})";
            var port = "[0-9]*";
            var iauthority = $"({iuserinfo}@)?{ihost}(:{port})?";
            var ipchar = $"({iunreserved}|{pctEncoded}|{subDelims}|[:@])";
            var isegment = $"({ipchar})*";
            var ipathAbempty = $"(/{isegment})*";
            var isegmentNz = $"({ipchar})+";
            var ipathAbsolute = $"/({isegmentNz}(/{isegment})*)?";
            var ipathRootless = $"{isegmentNz}(/{isegment})*";
            var ipathEmpty = $"({ipchar}){{0}}";
            var ihierPart = $"(//{iauthority}{ipathAbempty}|{ipathAbsolute}|{ipathRootless}|{ipathEmpty})";
            var iprivate = "([\\ue000-\\uf8ff]|\\udb80[\\udc00-\\udfff]|[\\udb81-\\udbbe][\\udc00-\\udfff]|\\udbbf[\\udc00-\\udffd]|\\udbc0[\\udc00-\\udfff]|[\\udbc1-\\udbfe][\\udc00-\\udfff]|\\udbff[\\udc00-\\udffd])";
            var iquery = $"({ipchar}|{iprivate}|[/?])*";
            var ifragment = $"({ipchar}|[/?])*";
            var isegmentNzNc = $"({iunreserved}|{pctEncoded}|{subDelims}|@)+";
            var ipathNoscheme = $"{isegmentNzNc}(/{isegment})*";
            var irelativePart = $"(//{iauthority}{ipathAbempty}|{ipathAbsolute}|{ipathNoscheme}|{ipathEmpty})";
            var irelativeRef = $"{irelativePart}(\\?{iquery})?(#{ifragment})?";
            var iri = $"{scheme}:{ihierPart}(\\?{iquery})?(#{ifragment})?";
            var iriReference = $"({iri}|{irelativeRef})";
            var pattern = $"^{iriReference}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsAnyUri = _constructMatchesXsAnyUri();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:anyURI</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#anyURI and
        /// https://datatracker.ietf.org/doc/html/rfc3987
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsAnyUri(string text)
        {
            return RegexMatchesXsAnyUri.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsBase64Binary()
        {
            var b04Char = "[AQgw]";
            var b04 = $"{b04Char}\\x20?";
            var b16Char = "[AEIMQUYcgkosw048]";
            var b16 = $"{b16Char}\\x20?";
            var b64Char = "[A-Za-z0-9+/]";
            var b64 = $"{b64Char}\\x20?";
            var b64quad = $"({b64}{b64}{b64}{b64})";
            var b64FinalQuad = $"({b64}{b64}{b64}{b64Char})";
            var padded8 = $"{b64}{b04}= ?=";
            var padded16 = $"{b64}{b64}{b16}=";
            var b64final = $"({b64FinalQuad}|{padded16}|{padded8})";
            var base64Binary = $"({b64quad}*{b64final})?";
            var pattern = $"^{base64Binary}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsBase64Binary = _constructMatchesXsBase64Binary();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:base64Binary</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#base64Binary
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsBase64Binary(string text)
        {
            return RegexMatchesXsBase64Binary.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsBoolean()
        {
            var pattern = "^(true|false|1|0)$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsBoolean = _constructMatchesXsBoolean();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:boolean</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#boolean
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsBoolean(string text)
        {
            return RegexMatchesXsBoolean.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsDate()
        {
            var digit = "[0-9]";
            var yearFrag = $"-?(([1-9]{digit}{digit}{digit}+)|(0{digit}{digit}{digit}))";
            var monthFrag = "((0[1-9])|(1[0-2]))";
            var dayFrag = $"((0[1-9])|([12]{digit})|(3[01]))";
            var minuteFrag = $"[0-5]{digit}";
            var timezoneFrag = $"(Z|(\\+|-)(0{digit}|1[0-3]):{minuteFrag}|14:00)";
            var dateLexicalRep = $"{yearFrag}-{monthFrag}-{dayFrag}{timezoneFrag}?";
            var pattern = $"^{dateLexicalRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsDate = _constructMatchesXsDate();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:date</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#date
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsDate(string text)
        {
            return RegexMatchesXsDate.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsDateTime()
        {
            var digit = "[0-9]";
            var yearFrag = $"-?(([1-9]{digit}{digit}{digit}+)|(0{digit}{digit}{digit}))";
            var monthFrag = "((0[1-9])|(1[0-2]))";
            var dayFrag = $"((0[1-9])|([12]{digit})|(3[01]))";
            var hourFrag = $"(([01]{digit})|(2[0-3]))";
            var minuteFrag = $"[0-5]{digit}";
            var secondFrag = $"([0-5]{digit})(\\.{digit}+)?";
            var endOfDayFrag = "24:00:00(\\.0+)?";
            var timezoneFrag = $"(Z|(\\+|-)(0{digit}|1[0-3]):{minuteFrag}|14:00)";
            var dateTimeLexicalRep = $"{yearFrag}-{monthFrag}-{dayFrag}T(({hourFrag}:{minuteFrag}:{secondFrag})|{endOfDayFrag}){timezoneFrag}?";
            var pattern = $"^{dateTimeLexicalRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsDateTime = _constructMatchesXsDateTime();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:dateTime</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#dateTime
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsDateTime(string text)
        {
            return RegexMatchesXsDateTime.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsDateTimeStamp()
        {
            var digit = "[0-9]";
            var yearFrag = $"-?(([1-9]{digit}{digit}{digit}+)|(0{digit}{digit}{digit}))";
            var monthFrag = "((0[1-9])|(1[0-2]))";
            var dayFrag = $"((0[1-9])|([12]{digit})|(3[01]))";
            var hourFrag = $"(([01]{digit})|(2[0-3]))";
            var minuteFrag = $"[0-5]{digit}";
            var secondFrag = $"([0-5]{digit})(\\.{digit}+)?";
            var endOfDayFrag = "24:00:00(\\.0+)?";
            var timezoneFrag = $"(Z|(\\+|-)(0{digit}|1[0-3]):{minuteFrag}|14:00)";
            var dateTimeStampLexicalRep = $"{yearFrag}-{monthFrag}-{dayFrag}T(({hourFrag}:{minuteFrag}:{secondFrag})|{endOfDayFrag}){timezoneFrag}";
            var pattern = $"^{dateTimeStampLexicalRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsDateTimeStamp = _constructMatchesXsDateTimeStamp();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:dateTimeStamp</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#dateTimeStamp
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsDateTimeStamp(string text)
        {
            return RegexMatchesXsDateTimeStamp.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsDecimal()
        {
            var digit = "[0-9]";
            var unsignedNoDecimalPtNumeral = $"{digit}+";
            var noDecimalPtNumeral = $"(\\+|-)?{unsignedNoDecimalPtNumeral}";
            var fracFrag = $"{digit}+";
            var unsignedDecimalPtNumeral = $"({unsignedNoDecimalPtNumeral}\\.{fracFrag}|\\.{fracFrag})";
            var decimalPtNumeral = $"(\\+|-)?{unsignedDecimalPtNumeral}";
            var decimalLexicalRep = $"({decimalPtNumeral}|{noDecimalPtNumeral})";
            var pattern = $"^{decimalLexicalRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsDecimal = _constructMatchesXsDecimal();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:decimal</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#decimal
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsDecimal(string text)
        {
            return RegexMatchesXsDecimal.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsDouble()
        {
            var doubleRep = "(\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|(\\+|-)?INF|NaN";
            var pattern = $"^{doubleRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsDouble = _constructMatchesXsDouble();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:double</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#double
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsDouble(string text)
        {
            return RegexMatchesXsDouble.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsDuration()
        {
            var durationRep = "-?P((([0-9]+Y([0-9]+M)?([0-9]+D)?|([0-9]+M)([0-9]+D)?|([0-9]+D))(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S))))";
            var pattern = $"^{durationRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsDuration = _constructMatchesXsDuration();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:duration</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#duration
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsDuration(string text)
        {
            return RegexMatchesXsDuration.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsFloat()
        {
            var floatRep = "(\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|(\\+|-)?INF|NaN";
            var pattern = $"^{floatRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsFloat = _constructMatchesXsFloat();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:float</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#float
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsFloat(string text)
        {
            return RegexMatchesXsFloat.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsGDay()
        {
            var gDayLexicalRep = "---(0[1-9]|[12][0-9]|3[01])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?";
            var pattern = $"^{gDayLexicalRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsGDay = _constructMatchesXsGDay();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:gDay</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#gDay
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsGDay(string text)
        {
            return RegexMatchesXsGDay.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsGMonth()
        {
            var gMonthLexicalRep = "--(0[1-9]|1[0-2])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?";
            var pattern = $"^{gMonthLexicalRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsGMonth = _constructMatchesXsGMonth();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:gMonth</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#gMonth
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsGMonth(string text)
        {
            return RegexMatchesXsGMonth.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsGMonthDay()
        {
            var gMonthDayRep = "--(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?";
            var pattern = $"^{gMonthDayRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsGMonthDay = _constructMatchesXsGMonthDay();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:gMonthDay</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#gMonthDay
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsGMonthDay(string text)
        {
            return RegexMatchesXsGMonthDay.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsGYear()
        {
            var gYearRep = "-?([1-9][0-9]{3,}|0[0-9]{3})(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?";
            var pattern = $"^{gYearRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsGYear = _constructMatchesXsGYear();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:gYear</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#gYear
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsGYear(string text)
        {
            return RegexMatchesXsGYear.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsGYearMonth()
        {
            var gYearMonthRep = "-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?";
            var pattern = $"^{gYearMonthRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsGYearMonth = _constructMatchesXsGYearMonth();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:gYearMonth</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#gYearMonth
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsGYearMonth(string text)
        {
            return RegexMatchesXsGYearMonth.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsHexBinary()
        {
            var hexBinary = "([0-9a-fA-F]{2})*";
            var pattern = $"^{hexBinary}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsHexBinary = _constructMatchesXsHexBinary();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:hexBinary</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#hexBinary
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsHexBinary(string text)
        {
            return RegexMatchesXsHexBinary.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsTime()
        {
            var timeRep = "(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?|(24:00:00(\\.0+)?))(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?";
            var pattern = $"^{timeRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsTime = _constructMatchesXsTime();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:time</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#time
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsTime(string text)
        {
            return RegexMatchesXsTime.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsDayTimeDuration()
        {
            var dayTimeDurationRep = "-?P((([0-9]+D)(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S))))";
            var pattern = $"^{dayTimeDurationRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsDayTimeDuration = _constructMatchesXsDayTimeDuration();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:dayTimeDuration</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#dayTimeDuration
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsDayTimeDuration(string text)
        {
            return RegexMatchesXsDayTimeDuration.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsYearMonthDuration()
        {
            var yearMonthDurationRep = "-?P((([0-9]+Y)([0-9]+M)?)|([0-9]+M))";
            var pattern = $"^{yearMonthDurationRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsYearMonthDuration = _constructMatchesXsYearMonthDuration();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:yearMonthDuration</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#yearMonthDuration
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsYearMonthDuration(string text)
        {
            return RegexMatchesXsYearMonthDuration.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsInteger()
        {
            var integerRep = "[-+]?[0-9]+";
            var pattern = $"^{integerRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsInteger = _constructMatchesXsInteger();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:integer</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#integer
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsInteger(string text)
        {
            return RegexMatchesXsInteger.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsLong()
        {
            var longRep = "[-+]?0*[0-9]{1,20}";
            var pattern = $"^{longRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsLong = _constructMatchesXsLong();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:long</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#long
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsLong(string text)
        {
            return RegexMatchesXsLong.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsInt()
        {
            var intRep = "[-+]?0*[0-9]{1,10}";
            var pattern = $"^{intRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsInt = _constructMatchesXsInt();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:int</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#int
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsInt(string text)
        {
            return RegexMatchesXsInt.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsShort()
        {
            var shortRep = "[-+]?0*[0-9]{1,5}";
            var pattern = $"^{shortRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsShort = _constructMatchesXsShort();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:short</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#short
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsShort(string text)
        {
            return RegexMatchesXsShort.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsByte()
        {
            var byteRep = "[-+]?0*[0-9]{1,3}";
            var pattern = $"^{byteRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsByte = _constructMatchesXsByte();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:byte</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#byte
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsByte(string text)
        {
            return RegexMatchesXsByte.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsNonNegativeInteger()
        {
            var nonNegativeIntegerRep = "(-0|\\+?[0-9]+)";
            var pattern = $"^{nonNegativeIntegerRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsNonNegativeInteger = _constructMatchesXsNonNegativeInteger();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:nonNegativeInteger</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#nonNegativeInteger
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsNonNegativeInteger(string text)
        {
            return RegexMatchesXsNonNegativeInteger.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsPositiveInteger()
        {
            var positiveIntegerRep = "\\+?0*[1-9][0-9]*";
            var pattern = $"^{positiveIntegerRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsPositiveInteger = _constructMatchesXsPositiveInteger();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:positiveInteger</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#positiveInteger
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsPositiveInteger(string text)
        {
            return RegexMatchesXsPositiveInteger.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsUnsignedLong()
        {
            var unsignedLongRep = "(-0|\\+?0*[0-9]{1,20})";
            var pattern = $"^{unsignedLongRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsUnsignedLong = _constructMatchesXsUnsignedLong();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:unsignedLong</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#unsignedLong
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsUnsignedLong(string text)
        {
            return RegexMatchesXsUnsignedLong.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsUnsignedInt()
        {
            var unsignedIntRep = "(-0|\\+?0*[0-9]{1,10})";
            var pattern = $"^{unsignedIntRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsUnsignedInt = _constructMatchesXsUnsignedInt();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:unsignedInt</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#unsignedInt
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsUnsignedInt(string text)
        {
            return RegexMatchesXsUnsignedInt.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsUnsignedShort()
        {
            var unsignedShortRep = "(-0|\\+?0*[0-9]{1,5})";
            var pattern = $"^{unsignedShortRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsUnsignedShort = _constructMatchesXsUnsignedShort();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:unsignedShort</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#unsignedShort
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsUnsignedShort(string text)
        {
            return RegexMatchesXsUnsignedShort.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsUnsignedByte()
        {
            var unsignedByteRep = "(-0|\\+?0*[0-9]{1,3})";
            var pattern = $"^{unsignedByteRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsUnsignedByte = _constructMatchesXsUnsignedByte();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:unsignedByte</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#unsignedByte
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsUnsignedByte(string text)
        {
            return RegexMatchesXsUnsignedByte.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsNonPositiveInteger()
        {
            var nonPositiveIntegerRep = "(\\+0|0|-[0-9]+)";
            var pattern = $"^{nonPositiveIntegerRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsNonPositiveInteger = _constructMatchesXsNonPositiveInteger();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:nonPositiveInteger</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#nonPositiveInteger
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsNonPositiveInteger(string text)
        {
            return RegexMatchesXsNonPositiveInteger.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsNegativeInteger()
        {
            var negativeIntegerRep = "(-0*[1-9][0-9]*)";
            var pattern = $"^{negativeIntegerRep}$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsNegativeInteger = _constructMatchesXsNegativeInteger();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:negativeInteger</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#negativeInteger
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsNegativeInteger(string text)
        {
            return RegexMatchesXsNegativeInteger.IsMatch(text);
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesXsString()
        {
            var pattern = "^([\\x01-\\ud7ff\\ue000-\\ufffd]|\\ud800[\\udc00-\\udfff]|[\\ud801-\\udbfe][\\udc00-\\udfff]|\\udbff[\\udc00-\\udfff])*$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesXsString = _constructMatchesXsString();

        /// <summary>
        /// Check that <paramref name="text" /> conforms to the pattern of an <c>xs:string</c>.
        /// </summary>
        /// <remarks>
        /// See: https://www.w3.org/TR/xmlschema11-2/#string
        /// </remarks>
        /// <param name="text">
        /// Text to be checked
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> conforms to the pattern
        /// </returns>
        public static bool MatchesXsString(string text)
        {
            return RegexMatchesXsString.IsMatch(text);
        }

        /// <summary>
        /// Check that the <paramref name="value" /> is consistent with
        /// the given <paramref name="valueType" />.
        /// </summary>
        public static bool ValueConsistentWithXsdType(
            string value,
            Aas.DataTypeDefXsd valueType
        )
        {
            switch (valueType)
            {
                case Aas.DataTypeDefXsd.AnyUri:
                    {
                        return MatchesXsAnyUri(value);
                    }
                case Aas.DataTypeDefXsd.Base64Binary:
                    {
                        return MatchesXsBase64Binary(value);
                    }
                case Aas.DataTypeDefXsd.Boolean:
                    {
                        return MatchesXsBoolean(value);
                    }
                case Aas.DataTypeDefXsd.Date:
                    {
                        if (!MatchesXsDate(value))
                        {
                            return false;
                        }

                        try
                        {
                            // ReSharper disable once ReturnValueOfPureMethodIsNotUsed
                            System.DateTime.ParseExact(
                                ClipToDate(value),
                                XsDateFormats,
                                System.Globalization.CultureInfo.InvariantCulture,
                                System.Globalization.DateTimeStyles.None);
                            return true;
                        }
                        catch (System.FormatException)
                        {
                            return false;
                        }
                    }
                case Aas.DataTypeDefXsd.DateTime:
                    {
                        if (!MatchesXsDateTime(value))
                        {
                            return false;
                        }

                        // The time part and the time zone part will be checked by
                        // MatchesXsDateTime. We need to check that the date part is
                        // correct in sense of the day/month combination.

                        try
                        {
                            // ReSharper disable once ReturnValueOfPureMethodIsNotUsed
                            System.DateTime.ParseExact(
                                ClipToDate(value),
                                XsDateFormats,
                                System.Globalization.CultureInfo.InvariantCulture,
                                System.Globalization.DateTimeStyles.None);
                            return true;
                        }
                        catch (System.FormatException)
                        {
                            return false;
                        }
                    }
                case Aas.DataTypeDefXsd.DateTimeStamp:
                    {
                        if (!MatchesXsDateTimeStamp(value))
                        {
                            return false;
                        }

                        // The time part and the time zone part will be checked by
                        // MatchesXsDateTimeStamp. We need to check that the date part is
                        // correct in sense of the day/month combination.

                        try
                        {
                            // ReSharper disable once ReturnValueOfPureMethodIsNotUsed
                            System.DateTime.ParseExact(
                                ClipToDate(value),
                                XsDateFormats,
                                System.Globalization.CultureInfo.InvariantCulture,
                                System.Globalization.DateTimeStyles.None);
                            return true;
                        }
                        catch (System.FormatException)
                        {
                            return false;
                        }
                    }
                case Aas.DataTypeDefXsd.Decimal:
                    {
                        return MatchesXsDecimal(value);
                    }
                case Aas.DataTypeDefXsd.Double:
                    {
                        // We need to check explicitly for the regular expression since
                        // System.Xml.XmlConvert.ToDouble is too permissive. For example,
                        // it accepts "nan" although only "NaN" is valid.
                        // See: https://www.w3.org/TR/xmlschema-2/#double
                        if (!MatchesXsDouble(value))
                        {
                            return false;
                        }

                        double converted;
                        try
                        {
                            converted = System.Xml.XmlConvert.ToDouble(value);
                        }
                        catch (System.FormatException)
                        {
                            return false;
                        }

                        if (System.Double.IsInfinity(converted))
                        {
                            // Check that the value is either "INF" or "-INF".
                            // Otherwise, the value is a decimal which is too big
                            // to be represented as a double-precision floating point
                            // number.
                            //
                            // Earlier C# used to throw an exception in this case. Today it
                            // simply rounds the parsed value to infinity. In the context
                            // of data exchange formats (such as AAS), this can cause
                            // critical errors, so we check for this edge case explicitly.
                            if (value.Length == 3)
                            {
                                return value == "INF";
                            }
                            else if (value.Length == 4)
                            {
                                return value == "-INF";
                            }
                            else
                            {
                                return false;
                            }
                        }
                        return true;
                    }
                case Aas.DataTypeDefXsd.Duration:
                    {
                        return MatchesXsDuration(value);
                    }
                case Aas.DataTypeDefXsd.Float:
                    {
                        // We need to check explicitly for the regular expression since
                        // System.Xml.XmlConvert.ToSingle is too permissive. For example,
                        // it accepts "nan" although only "NaN" is valid.
                        // See: https://www.w3.org/TR/xmlschema-2/#float
                        if (!MatchesXsFloat(value))
                        {
                            return false;
                        }

                        float converted;
                        try
                        {
                            converted = System.Xml.XmlConvert.ToSingle(value);
                        }
                        catch (System.FormatException)
                        {
                            return false;
                        }

                        if (System.Single.IsInfinity(converted))
                        {
                            // Check that the value is either "INF" or "-INF".
                            // Otherwise, the value is a decimal which is too big
                            // to be represented as a single-precision floating point
                            // number.
                            //
                            // Earlier C# used to throw an exception in this case. Today it
                            // simply rounds the parsed value to infinity. In the context
                            // of data exchange formats (such as AAS), this can cause
                            // critical errors, so we check for this edge case explicitly.
                            if (value.Length == 3)
                            {
                                return value == "INF";
                            }
                            else if (value.Length == 4)
                            {
                                return value == "-INF";
                            }
                            else
                            {
                                return false;
                            }
                        }
                        return true;
                    }
                case Aas.DataTypeDefXsd.GDay:
                    {
                        return MatchesXsGDay(value);
                    }
                case Aas.DataTypeDefXsd.GMonth:
                    {
                        return MatchesXsGMonth(value);
                    }
                case Aas.DataTypeDefXsd.GMonthDay:
                    {
                        if (!MatchesXsGMonthDay(value))
                        {
                            return false;
                        }

                        var month = int.Parse(value.Substring(2, 2));
                        var day = int.Parse(value.Substring(5, 2));
                        switch (month)
                        {
                            case 1:
                            case 3:
                            case 5:
                            case 7:
                            case 8:
                            case 10:
                            case 12:
                                return day <= 31;
                            case 4:
                            case 6:
                            case 9:
                            case 11:
                                return day <= 30;
                            case 2:
                                return day <= 29;
                            default:
                                throw new System.InvalidOperationException(
                                    $"Unhandled month: {month}; " +
                                    "is there maybe a bug in MatchesXsGMonthDay?"
                                );
                        }
                    }
                case Aas.DataTypeDefXsd.GYear:
                    {
                        return MatchesXsGYear(value);
                    }
                case Aas.DataTypeDefXsd.GYearMonth:
                    {
                        return MatchesXsGYearMonth(value);
                    }
                case Aas.DataTypeDefXsd.HexBinary:
                    {
                        return MatchesXsHexBinary(value);
                    }
                case Aas.DataTypeDefXsd.String:
                    {
                        return MatchesXsString(value);
                    }
                case Aas.DataTypeDefXsd.Time:
                    {
                        return MatchesXsTime(value);
                    }
                case Aas.DataTypeDefXsd.DayTimeDuration:
                    {
                        return MatchesXsDayTimeDuration(value);
                    }
                case Aas.DataTypeDefXsd.YearMonthDuration:
                    {
                        return MatchesXsYearMonthDuration(value);
                    }
                case Aas.DataTypeDefXsd.Integer:
                    {
                        return MatchesXsInteger(value);
                    }
                case Aas.DataTypeDefXsd.Long:
                    {
                        try
                        {
                            // ReSharper disable once ReturnValueOfPureMethodIsNotUsed
                            System.Xml.XmlConvert.ToInt64(value);
                            return true;
                        }
                        catch (System.OverflowException)
                        {
                            return false;
                        }
                        catch (System.FormatException)
                        {
                            return false;
                        }
                    }
                case Aas.DataTypeDefXsd.Int:
                    {
                        try
                        {
                            // ReSharper disable once ReturnValueOfPureMethodIsNotUsed
                            System.Xml.XmlConvert.ToInt32(value);
                            return true;
                        }
                        catch (System.OverflowException)
                        {
                            return false;
                        }
                        catch (System.FormatException)
                        {
                            return false;
                        }
                    }
                case Aas.DataTypeDefXsd.Short:
                    {
                        try
                        {
                            // ReSharper disable once ReturnValueOfPureMethodIsNotUsed
                            System.Xml.XmlConvert.ToInt16(value);
                            return true;
                        }
                        catch (System.OverflowException)
                        {
                            return false;
                        }
                        catch (System.FormatException)
                        {
                            return false;
                        }
                    }
                case Aas.DataTypeDefXsd.Byte:
                    {
                        try
                        {
                            // ReSharper disable once ReturnValueOfPureMethodIsNotUsed
                            System.Xml.XmlConvert.ToSByte(value);
                            return true;
                        }
                        catch (System.OverflowException)
                        {
                            return false;
                        }
                        catch (System.FormatException)
                        {
                            return false;
                        }
                    }
                case Aas.DataTypeDefXsd.NonNegativeInteger:
                    {
                        return MatchesXsNonNegativeInteger(value);
                    }
                case Aas.DataTypeDefXsd.PositiveInteger:
                    {
                        return MatchesXsPositiveInteger(value);
                    }
                case Aas.DataTypeDefXsd.UnsignedLong:
                    {
                        if (value.Length == 0)
                        {
                            return false;
                        }

                        // We need to allow negative zeros which are allowed in the lexical
                        // representation of an unsigned long, but System.Xml.XmlConvert.ToUInt64
                        // rejects it.
                        // See: https://www.w3.org/TR/xmlschema11-2/#unsignedLong
                        if (value == "-0")
                        {
                            return true;
                        }

                        // We need to strip the prefix positive sign since
                        // System.Xml.XmlConvert.ToUInt64 does not adhere to lexical representation
                        // of an unsigned long.
                        //
                        // The positive sign is indeed allowed in the lexical representation, see:
                        // https://www.w3.org/TR/xmlschema11-2/#unsignedLong
                        string clipped = (value[0] == '+')
                            ? value.Substring(1, value.Length - 1)
                            : value;

                        try
                        {
                            // ReSharper disable once ReturnValueOfPureMethodIsNotUsed
                            System.Xml.XmlConvert.ToUInt64(clipped);
                            return true;
                        }
                        catch (System.OverflowException)
                        {
                            return false;
                        }
                        catch (System.FormatException)
                        {
                            return false;
                        }
                    }
                case Aas.DataTypeDefXsd.UnsignedInt:
                    {
                        if (value.Length == 0)
                        {
                            return false;
                        }

                        // We need to allow negative zeros which are allowed in the lexical
                        // representation of an unsigned int, but System.Xml.XmlConvert.ToUInt32
                        // rejects it.
                        // See: https://www.w3.org/TR/xmlschema11-2/#unsignedInt
                        if (value == "-0")
                        {
                            return true;
                        }

                        // We need to strip the prefix positive sign since
                        // System.Xml.XmlConvert.ToUInt32 does not adhere to lexical representation
                        // of an unsigned int.
                        //
                        // The positive sign is indeed allowed in the lexical representation, see:
                        // https://www.w3.org/TR/xmlschema11-2/#unsignedInt
                        string clipped = (value[0] == '+')
                            ? value.Substring(1, value.Length - 1)
                            : value;

                        try
                        {
                            // ReSharper disable once ReturnValueOfPureMethodIsNotUsed
                            System.Xml.XmlConvert.ToUInt32(clipped);
                            return true;
                        }
                        catch (System.OverflowException)
                        {
                            return false;
                        }
                        catch (System.FormatException)
                        {
                            return false;
                        }
                    }
                case Aas.DataTypeDefXsd.UnsignedShort:
                    {
                        if (value.Length == 0)
                        {
                            return false;
                        }

                        // We need to allow negative zeros which are allowed in the lexical
                        // representation of an unsigned short, but System.Xml.XmlConvert.ToUInt16
                        // rejects it.
                        // See: https://www.w3.org/TR/xmlschema11-2/#unsignedShort
                        if (value == "-0")
                        {
                            return true;
                        }

                        // We need to strip the prefix positive sign since
                        // System.Xml.XmlConvert.ToUInt16 does not adhere to lexical representation
                        // of an unsigned short.
                        //
                        // The positive sign is indeed allowed in the lexical representation, see:
                        // https://www.w3.org/TR/xmlschema11-2/#unsignedShort
                        string clipped = (value[0] == '+')
                            ? value.Substring(1, value.Length - 1)
                            : value;

                        try
                        {
                            // ReSharper disable once ReturnValueOfPureMethodIsNotUsed
                            System.Xml.XmlConvert.ToUInt16(clipped);
                            return true;
                        }
                        catch (System.OverflowException)
                        {
                            return false;
                        }
                        catch (System.FormatException)
                        {
                            return false;
                        }
                    }
                case Aas.DataTypeDefXsd.UnsignedByte:
                    {
                        if (value.Length == 0)
                        {
                            return false;
                        }

                        // We need to allow negative zeros which are allowed in the lexical
                        // representation of an unsigned byte, but System.Xml.XmlConvert.ToByte
                        // rejects it.
                        // See: https://www.w3.org/TR/xmlschema11-2/#unsignedByte
                        if (value == "-0")
                        {
                            return true;
                        }

                        // We need to strip the prefix positive sign since
                        // System.Xml.XmlConvert.ToByte does not adhere to lexical representation
                        // of an unsigned byte.
                        //
                        // The positive sign is indeed allowed in the lexical representation, see:
                        // https://www.w3.org/TR/xmlschema11-2/#unsignedByte
                        string clipped = (value[0] == '+')
                            ? value.Substring(1, value.Length - 1)
                            : value;

                        try
                        {
                            // ReSharper disable once ReturnValueOfPureMethodIsNotUsed
                            System.Xml.XmlConvert.ToByte(clipped);
                            return true;
                        }
                        catch (System.OverflowException)
                        {
                            return false;
                        }
                        catch (System.FormatException)
                        {
                            return false;
                        }
                    }
                case Aas.DataTypeDefXsd.NonPositiveInteger:
                    {
                        return MatchesXsNonPositiveInteger(value);
                    }
                case Aas.DataTypeDefXsd.NegativeInteger:
                    {
                        return MatchesXsNegativeInteger(value);
                    }
                default:
                    throw new System.ArgumentException(
                        $"valueType is an invalid  DataTypeDefXsd: {valueType}"
                    );
            }
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        [CodeAnalysis.SuppressMessageAttribute("ReSharper", "IdentifierTypo")]
        [CodeAnalysis.SuppressMessage("ReSharper", "StringLiteralTypo")]
        private static Regex _constructMatchesGlobalAssetIdLiterally()
        {
            var pattern = "^[gG][lL][oO][bB][aA][lL][aA][sS][sS][eE][tT][iI][dD]$";

            return new Regex(pattern);
        }

        private static readonly Regex RegexMatchesGlobalAssetIdLiterally = _constructMatchesGlobalAssetIdLiterally();

        /// <summary>
        /// Check that the <paramref name="text" /> matches <c>globalAssetId</c> case-insensitive.
        /// </summary>
        /// <remarks>
        /// The case-insensitivity depends on the culture. For example in Turkish, uppercase
        /// "i" is "", not "I". We assume the culture to be English, and explicitly check
        /// for English case-folding.
        /// </remarks>
        /// <param name="text">
        /// which needs to match <c>globalAssetId</c> literally
        /// </param>
        /// <returns>
        /// True if the <paramref name="text" /> matches case-insensitive
        /// </returns>
        public static bool MatchesGlobalAssetIdLiterally(string text)
        {
            return RegexMatchesGlobalAssetIdLiterally.IsMatch(text);
        }

        /// <summary>
        /// Check that the target of the model <paramref name="reference" /> matches
        /// the <paramref name="expectedType" />.
        /// </summary>
        public static bool IsModelReferenceTo(
            Aas.Reference reference,
            Aas.KeyTypes expectedType
        )
        {
            if (reference.Keys.Count == 0)
            {
                return false;
            }

            return reference.Keys[^1].Type == expectedType;
        }

        /// <summary>
        /// Check that all <see cref="Aas.IReferable.IdShort" /> are unique among
        /// <paramref name="referables" />.
        /// </summary>
        public static bool IdShortsAreUnique(
            IEnumerable<Aas.IReferable> referables
        )
        {
            var idShortSet = new HashSet<string>();
            foreach (var referable in referables)
            {
                if (referable.IdShort != null)
                {
                    if (idShortSet.Contains(referable.IdShort))
                    {
                        return false;
                    }
                    idShortSet.Add(referable.IdShort);
                }
            }
            return true;
        }

        /// <summary>
        /// Check that all <see cref="Aas.Extension.Name" /> are unique among
        /// <paramref name="extensions" />.
        /// </summary>
        public static bool ExtensionNamesAreUnique(
            IEnumerable<Aas.Extension> extensions
        )
        {
            var nameSet = new HashSet<string>();
            foreach (var extension in extensions)
            {
                if (nameSet.Contains(extension.Name))
                {
                    return false;
                }
                nameSet.Add(extension.Name);
            }
            return true;
        }

        /// <summary>
        /// Check that all <paramref name="elements" /> have the identical
        /// <see cref="Aas.IHasSemantics.SemanticId" />'s.
        /// </summary>
        public static bool SubmodelElementsHaveIdenticalSemanticIds(
            IEnumerable<Aas.ISubmodelElement> elements
        )
        {
            Aas.Reference? thatSemanticId = null;

            foreach (var element in elements)
            {
                if (element.SemanticId == null)
                {
                    continue;
                }

                if (thatSemanticId == null)
                {
                    thatSemanticId = element.SemanticId;
                    continue;
                }

                var thisSemanticId = element.SemanticId;

                if (thatSemanticId.Keys.Count != thisSemanticId.Keys.Count)
                {
                    return false;
                }

                for (int i = 0; i < thisSemanticId.Keys.Count; i++)
                {
                    if (thatSemanticId.Keys[i].Value != thisSemanticId.Keys[i].Value)
                    {
                        return false;
                    }
                }
            }

            return true;
        }

        public static bool SubmodelElementIsOfType(
            Aas.ISubmodelElement element,
            Aas.AasSubmodelElements elementType
        )
        {
            switch (elementType)
            {
                case Aas.AasSubmodelElements.AnnotatedRelationshipElement:
                    return element is Aas.AnnotatedRelationshipElement;

                case Aas.AasSubmodelElements.BasicEventElement:
                    return element is Aas.BasicEventElement;

                case Aas.AasSubmodelElements.Blob:
                    return element is Aas.Blob;

                case Aas.AasSubmodelElements.Capability:
                    return element is Aas.Capability;

                case Aas.AasSubmodelElements.DataElement:
                    return element is Aas.IDataElement;

                case Aas.AasSubmodelElements.Entity:
                    return element is Aas.Entity;

                case Aas.AasSubmodelElements.EventElement:
                    return element is Aas.IEventElement;

                case Aas.AasSubmodelElements.File:
                    return element is Aas.File;

                case Aas.AasSubmodelElements.MultiLanguageProperty:
                    return element is Aas.MultiLanguageProperty;

                case Aas.AasSubmodelElements.Operation:
                    return element is Aas.Operation;

                case Aas.AasSubmodelElements.Property:
                    return element is Aas.Property;

                case Aas.AasSubmodelElements.Range:
                    return element is Aas.Range;

                case Aas.AasSubmodelElements.ReferenceElement:
                    return element is Aas.ReferenceElement;

                case Aas.AasSubmodelElements.RelationshipElement:
                    return element is Aas.IRelationshipElement;

                case Aas.AasSubmodelElements.SubmodelElement:
                    // ReSharper disable once IsExpressionAlwaysTrue
                    // ReSharper disable once ConvertTypeCheckToNullCheck
                    return element is Aas.ISubmodelElement;

                case Aas.AasSubmodelElements.SubmodelElementList:
                    return element is Aas.SubmodelElementList;

                case Aas.AasSubmodelElements.SubmodelElementCollection:
                    return element is Aas.SubmodelElementCollection;

                default:
                    throw new System.ArgumentException(
                        $"elementType is not a valid AasSubmodelElements: {elementType}"
                    );
            }
        }

        /// <summary>
        /// Check that the <paramref name="elements" /> which are
        /// <see cref="Aas.Property" /> or <see cref="Aas.Range" />
        /// have the given <paramref name="valueType" />.
        /// </summary>
        /// <remarks>
        /// We have to use nullable valueType since the compiler does not really handle
        /// nullable C# value types.
        ///
        /// See https://endjin.com/blog/2022/02/csharp-10-generics-nullable-references-improvements-allownull
        /// </remarks>
        public static bool PropertiesOrRangesHaveValueType(
            IEnumerable<Aas.ISubmodelElement> elements,
            Aas.DataTypeDefXsd? valueType
        )
        {
            foreach (var element in elements)
            {
                switch (element)
                {
                    case Aas.Property prop:
                        if (prop.ValueType != valueType)
                        {
                            return false;
                        }
                        break;
                    case Aas.Range range:
                        if (range.ValueType != valueType)
                        {
                            return false;
                        }
                        break;
                }
            }
            return true;
        }

        private static readonly HashSet<string> ConceptDescriptionCategories = new HashSet<string>
        {
            "APPLICATION_CLASS",
            "CAPABILITY",
            "COLLECTION",
            "DOCUMENT",
            "ENTITY",
            "EVENT",
            "FUNCTION",
            "PROPERTY",
            "VALUE",
            "RANGE",
            "QUALIFIER_TYPE",
            "REFERENCE",
            "RELATIONSHIP"
        };

        /// <summary>
        /// Check that <paramref name="category" /> is a valid
        /// category of the concept description.
        /// </summary>
        public static bool ConceptDescriptionCategoryIsValid(
            string category
        )
        {
            return ConceptDescriptionCategories.Contains(
                category);
        }

        private static readonly HashSet<string> DataElementCategories = new HashSet<string>
        {
            "CONSTANT",
            "PARAMETER",
            "VARIABLE"
        };

        /// <summary>
        /// Check that <paramref name="category" /> is a valid
        /// category of a data element.
        /// </summary>
        public static bool DataElementCategoryIsValid(
            string category
        )
        {
            return DataElementCategories.Contains(
                category);
        }

        /// <summary>
        /// Check that the two references, <paramref name="that" /> and
        /// <paramref name="other" />, are equal by comparing
        /// their <see cref="Aas.Reference.Keys" /> by
        /// <see cref="Aas.Key.Value" />'s.
        /// </summary>
        public static bool ReferenceKeyValuesEqual(
            Aas.Reference that,
            Aas.Reference other
        )
        {
            if (that.Keys.Count != other.Keys.Count)
            {
                return false;
            }

            for (int i = 0; i < that.Keys.Count; i++)
            {
                if (that.Keys[i].Value != other.Keys[i].Value)
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Hash allowed enum values for efficient validation of enums.
        /// </summary>
        internal static class EnumValueSet
        {
            internal static readonly HashSet<int> ForModelingKind = new HashSet<int>
            {

                (int)Aas.ModelingKind.Template,
                (int)Aas.ModelingKind.Instance
            };

            internal static readonly HashSet<int> ForQualifierKind = new HashSet<int>
            {

                (int)Aas.QualifierKind.ValueQualifier,
                (int)Aas.QualifierKind.ConceptQualifier,
                (int)Aas.QualifierKind.TemplateQualifier
            };

            internal static readonly HashSet<int> ForAssetKind = new HashSet<int>
            {

                (int)Aas.AssetKind.Type,
                (int)Aas.AssetKind.Instance
            };

            internal static readonly HashSet<int> ForEntityType = new HashSet<int>
            {

                (int)Aas.EntityType.CoManagedEntity,
                (int)Aas.EntityType.SelfManagedEntity
            };

            internal static readonly HashSet<int> ForDirection = new HashSet<int>
            {

                (int)Aas.Direction.Input,
                (int)Aas.Direction.Output
            };

            internal static readonly HashSet<int> ForStateOfEvent = new HashSet<int>
            {

                (int)Aas.StateOfEvent.On,
                (int)Aas.StateOfEvent.Off
            };

            internal static readonly HashSet<int> ForReferenceTypes = new HashSet<int>
            {

                (int)Aas.ReferenceTypes.GlobalReference,
                (int)Aas.ReferenceTypes.ModelReference
            };

            internal static readonly HashSet<int> ForGenericFragmentKeys = new HashSet<int>
            {

                (int)Aas.GenericFragmentKeys.FragmentReference
            };

            internal static readonly HashSet<int> ForGenericGloballyIdentifiables = new HashSet<int>
            {

                (int)Aas.GenericGloballyIdentifiables.GlobalReference
            };

            internal static readonly HashSet<int> ForAasIdentifiables = new HashSet<int>
            {

                (int)Aas.AasIdentifiables.AssetAdministrationShell,
                (int)Aas.AasIdentifiables.ConceptDescription,
                (int)Aas.AasIdentifiables.Identifiable,
                (int)Aas.AasIdentifiables.Submodel
            };

            internal static readonly HashSet<int> ForAasSubmodelElements = new HashSet<int>
            {

                (int)Aas.AasSubmodelElements.AnnotatedRelationshipElement,
                (int)Aas.AasSubmodelElements.BasicEventElement,
                (int)Aas.AasSubmodelElements.Blob,
                (int)Aas.AasSubmodelElements.Capability,
                (int)Aas.AasSubmodelElements.DataElement,
                (int)Aas.AasSubmodelElements.Entity,
                (int)Aas.AasSubmodelElements.EventElement,
                (int)Aas.AasSubmodelElements.File,
                (int)Aas.AasSubmodelElements.MultiLanguageProperty,
                (int)Aas.AasSubmodelElements.Operation,
                (int)Aas.AasSubmodelElements.Property,
                (int)Aas.AasSubmodelElements.Range,
                (int)Aas.AasSubmodelElements.ReferenceElement,
                (int)Aas.AasSubmodelElements.RelationshipElement,
                (int)Aas.AasSubmodelElements.SubmodelElement,
                (int)Aas.AasSubmodelElements.SubmodelElementList,
                (int)Aas.AasSubmodelElements.SubmodelElementCollection
            };

            internal static readonly HashSet<int> ForAasReferableNonIdentifiables = new HashSet<int>
            {

                (int)Aas.AasReferableNonIdentifiables.AnnotatedRelationshipElement,
                (int)Aas.AasReferableNonIdentifiables.BasicEventElement,
                (int)Aas.AasReferableNonIdentifiables.Blob,
                (int)Aas.AasReferableNonIdentifiables.Capability,
                (int)Aas.AasReferableNonIdentifiables.DataElement,
                (int)Aas.AasReferableNonIdentifiables.Entity,
                (int)Aas.AasReferableNonIdentifiables.EventElement,
                (int)Aas.AasReferableNonIdentifiables.File,
                (int)Aas.AasReferableNonIdentifiables.MultiLanguageProperty,
                (int)Aas.AasReferableNonIdentifiables.Operation,
                (int)Aas.AasReferableNonIdentifiables.Property,
                (int)Aas.AasReferableNonIdentifiables.Range,
                (int)Aas.AasReferableNonIdentifiables.ReferenceElement,
                (int)Aas.AasReferableNonIdentifiables.RelationshipElement,
                (int)Aas.AasReferableNonIdentifiables.SubmodelElement,
                (int)Aas.AasReferableNonIdentifiables.SubmodelElementCollection,
                (int)Aas.AasReferableNonIdentifiables.SubmodelElementList
            };

            internal static readonly HashSet<int> ForAasReferables = new HashSet<int>
            {

                (int)Aas.AasReferables.Referable,
                (int)Aas.AasReferables.AssetAdministrationShell,
                (int)Aas.AasReferables.ConceptDescription,
                (int)Aas.AasReferables.Identifiable,
                (int)Aas.AasReferables.Submodel,
                (int)Aas.AasReferables.AnnotatedRelationshipElement,
                (int)Aas.AasReferables.BasicEventElement,
                (int)Aas.AasReferables.Blob,
                (int)Aas.AasReferables.Capability,
                (int)Aas.AasReferables.DataElement,
                (int)Aas.AasReferables.Entity,
                (int)Aas.AasReferables.EventElement,
                (int)Aas.AasReferables.File,
                (int)Aas.AasReferables.MultiLanguageProperty,
                (int)Aas.AasReferables.Operation,
                (int)Aas.AasReferables.Property,
                (int)Aas.AasReferables.Range,
                (int)Aas.AasReferables.ReferenceElement,
                (int)Aas.AasReferables.RelationshipElement,
                (int)Aas.AasReferables.SubmodelElement,
                (int)Aas.AasReferables.SubmodelElementCollection,
                (int)Aas.AasReferables.SubmodelElementList
            };

            internal static readonly HashSet<int> ForGloballyIdentifiables = new HashSet<int>
            {

                (int)Aas.GloballyIdentifiables.GlobalReference,
                (int)Aas.GloballyIdentifiables.AssetAdministrationShell,
                (int)Aas.GloballyIdentifiables.ConceptDescription,
                (int)Aas.GloballyIdentifiables.Identifiable,
                (int)Aas.GloballyIdentifiables.Submodel
            };

            internal static readonly HashSet<int> ForFragmentKeys = new HashSet<int>
            {

                (int)Aas.FragmentKeys.FragmentReference,
                (int)Aas.FragmentKeys.AnnotatedRelationshipElement,
                (int)Aas.FragmentKeys.AssetAdministrationShell,
                (int)Aas.FragmentKeys.BasicEventElement,
                (int)Aas.FragmentKeys.Blob,
                (int)Aas.FragmentKeys.Capability,
                (int)Aas.FragmentKeys.ConceptDescription,
                (int)Aas.FragmentKeys.DataElement,
                (int)Aas.FragmentKeys.Entity,
                (int)Aas.FragmentKeys.EventElement,
                (int)Aas.FragmentKeys.File,
                (int)Aas.FragmentKeys.MultiLanguageProperty,
                (int)Aas.FragmentKeys.Operation,
                (int)Aas.FragmentKeys.Property,
                (int)Aas.FragmentKeys.Range,
                (int)Aas.FragmentKeys.ReferenceElement,
                (int)Aas.FragmentKeys.RelationshipElement,
                (int)Aas.FragmentKeys.Submodel,
                (int)Aas.FragmentKeys.SubmodelElement,
                (int)Aas.FragmentKeys.SubmodelElementList,
                (int)Aas.FragmentKeys.SubmodelElementCollection
            };

            internal static readonly HashSet<int> ForKeyTypes = new HashSet<int>
            {

                (int)Aas.KeyTypes.FragmentReference,
                (int)Aas.KeyTypes.GlobalReference,
                (int)Aas.KeyTypes.AnnotatedRelationshipElement,
                (int)Aas.KeyTypes.AssetAdministrationShell,
                (int)Aas.KeyTypes.BasicEventElement,
                (int)Aas.KeyTypes.Blob,
                (int)Aas.KeyTypes.Capability,
                (int)Aas.KeyTypes.ConceptDescription,
                (int)Aas.KeyTypes.Identifiable,
                (int)Aas.KeyTypes.DataElement,
                (int)Aas.KeyTypes.Entity,
                (int)Aas.KeyTypes.EventElement,
                (int)Aas.KeyTypes.File,
                (int)Aas.KeyTypes.MultiLanguageProperty,
                (int)Aas.KeyTypes.Operation,
                (int)Aas.KeyTypes.Property,
                (int)Aas.KeyTypes.Range,
                (int)Aas.KeyTypes.Referable,
                (int)Aas.KeyTypes.ReferenceElement,
                (int)Aas.KeyTypes.RelationshipElement,
                (int)Aas.KeyTypes.Submodel,
                (int)Aas.KeyTypes.SubmodelElement,
                (int)Aas.KeyTypes.SubmodelElementList,
                (int)Aas.KeyTypes.SubmodelElementCollection
            };

            internal static readonly HashSet<int> ForDataTypeDefXsd = new HashSet<int>
            {

                (int)Aas.DataTypeDefXsd.AnyUri,
                (int)Aas.DataTypeDefXsd.Base64Binary,
                (int)Aas.DataTypeDefXsd.Boolean,
                (int)Aas.DataTypeDefXsd.Date,
                (int)Aas.DataTypeDefXsd.DateTime,
                (int)Aas.DataTypeDefXsd.DateTimeStamp,
                (int)Aas.DataTypeDefXsd.Decimal,
                (int)Aas.DataTypeDefXsd.Double,
                (int)Aas.DataTypeDefXsd.Duration,
                (int)Aas.DataTypeDefXsd.Float,
                (int)Aas.DataTypeDefXsd.GDay,
                (int)Aas.DataTypeDefXsd.GMonth,
                (int)Aas.DataTypeDefXsd.GMonthDay,
                (int)Aas.DataTypeDefXsd.GYear,
                (int)Aas.DataTypeDefXsd.GYearMonth,
                (int)Aas.DataTypeDefXsd.HexBinary,
                (int)Aas.DataTypeDefXsd.String,
                (int)Aas.DataTypeDefXsd.Time,
                (int)Aas.DataTypeDefXsd.DayTimeDuration,
                (int)Aas.DataTypeDefXsd.YearMonthDuration,
                (int)Aas.DataTypeDefXsd.Integer,
                (int)Aas.DataTypeDefXsd.Long,
                (int)Aas.DataTypeDefXsd.Int,
                (int)Aas.DataTypeDefXsd.Short,
                (int)Aas.DataTypeDefXsd.Byte,
                (int)Aas.DataTypeDefXsd.NonNegativeInteger,
                (int)Aas.DataTypeDefXsd.PositiveInteger,
                (int)Aas.DataTypeDefXsd.UnsignedLong,
                (int)Aas.DataTypeDefXsd.UnsignedInt,
                (int)Aas.DataTypeDefXsd.UnsignedShort,
                (int)Aas.DataTypeDefXsd.UnsignedByte,
                (int)Aas.DataTypeDefXsd.NonPositiveInteger,
                (int)Aas.DataTypeDefXsd.NegativeInteger
            };

            internal static readonly HashSet<int> ForDataTypeDefRdf = new HashSet<int>
            {

                (int)Aas.DataTypeDefRdf.LangString
            };

            internal static readonly HashSet<int> ForDataTypeDef = new HashSet<int>
            {

                (int)Aas.DataTypeDef.AnyUri,
                (int)Aas.DataTypeDef.Base64Binary,
                (int)Aas.DataTypeDef.Boolean,
                (int)Aas.DataTypeDef.Date,
                (int)Aas.DataTypeDef.DateTime,
                (int)Aas.DataTypeDef.DateTimeStamp,
                (int)Aas.DataTypeDef.Decimal,
                (int)Aas.DataTypeDef.Double,
                (int)Aas.DataTypeDef.Duration,
                (int)Aas.DataTypeDef.Float,
                (int)Aas.DataTypeDef.GDay,
                (int)Aas.DataTypeDef.GMonth,
                (int)Aas.DataTypeDef.GMonthDay,
                (int)Aas.DataTypeDef.GYear,
                (int)Aas.DataTypeDef.GYearMonth,
                (int)Aas.DataTypeDef.HexBinary,
                (int)Aas.DataTypeDef.String,
                (int)Aas.DataTypeDef.Time,
                (int)Aas.DataTypeDef.DayTimeDuration,
                (int)Aas.DataTypeDef.YearMonthDuration,
                (int)Aas.DataTypeDef.Integer,
                (int)Aas.DataTypeDef.Long,
                (int)Aas.DataTypeDef.Int,
                (int)Aas.DataTypeDef.Short,
                (int)Aas.DataTypeDef.Byte,
                (int)Aas.DataTypeDef.NonNegativeInteger,
                (int)Aas.DataTypeDef.PositiveInteger,
                (int)Aas.DataTypeDef.UnsignedLong,
                (int)Aas.DataTypeDef.UnsignedInt,
                (int)Aas.DataTypeDef.UnsignedShort,
                (int)Aas.DataTypeDef.UnsignedByte,
                (int)Aas.DataTypeDef.NonPositiveInteger,
                (int)Aas.DataTypeDef.NegativeInteger,
                (int)Aas.DataTypeDef.LangString
            };
        }  // internal static class EnumValueSet

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        private static readonly Verification.Transformer _transformer = (
            new Verification.Transformer());

        private class Transformer
            : Visitation.AbstractTransformer<IEnumerable<Reporting.Error>>
        {
            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.Extension that)
            {
                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.\n" +
                        "!(that.SupplementalSemanticIds != null)\n" +
                        "|| (that.SemanticId != null)");
                }

                if (!(
                    !(that.Value != null)
                    || Verification.ValueConsistentWithXsdType(that.Value, that.ValueTypeOrDefault())))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "!(that.Value != null)\n" +
                        "|| Verification.ValueConsistentWithXsdType(that.Value, that.ValueTypeOrDefault())");
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                foreach (var error in Verification.VerifyNonEmptyString(that.Name))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "name"));
                    yield return error;
                }

                if (that.ValueType != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.DataTypeDefXsd value = that.ValueType
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyDataTypeDefXsd(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "valueType"));
                        yield return error;
                    }
                }

                if (that.Value != null)
                {
                    foreach (var error in Verification.VerifyValueDataType(that.Value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "value"));
                        yield return error;
                    }
                }

                if (that.RefersTo != null)
                {
                    foreach (var error in Verification.Verify(that.RefersTo))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "refersTo"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.AdministrativeInformation that)
            {
                if (!(
                    !(that.Revision != null)
                    || (that.Version != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-005: If version is not specified then also " +
                        "revision shall be unspecified. This means, a revision " +
                        "requires a version. If there is no version there is no " +
                        "revision either. Revision is optional.\n" +
                        "!(that.Revision != null)\n" +
                        "|| (that.Version != null)");
                }

                if (that.DataSpecifications != null)
                {
                    int indexDataSpecifications = 0;
                    foreach (var item in that.DataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "dataSpecifications"));
                            yield return error;
                        }
                        indexDataSpecifications++;
                    }
                }

                if (that.Version != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Version))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "version"));
                        yield return error;
                    }
                }

                if (that.Revision != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Revision))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "revision"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.Qualifier that)
            {
                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.\n" +
                        "!(that.SupplementalSemanticIds != null)\n" +
                        "|| (that.SemanticId != null)");
                }

                if (!(
                    !(that.Value != null)
                    || Verification.ValueConsistentWithXsdType(that.Value, that.ValueType)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-020: The value shall be consistent to " +
                        "the data type as defined in value type.\n" +
                        "!(that.Value != null)\n" +
                        "|| Verification.ValueConsistentWithXsdType(that.Value, that.ValueType)");
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.QualifierKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyQualifierKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                foreach (var error in Verification.VerifyQualifierType(that.Type))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "type"));
                    yield return error;
                }

                foreach (var error in Verification.VerifyDataTypeDefXsd(that.ValueType))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "valueType"));
                    yield return error;
                }

                if (that.Value != null)
                {
                    foreach (var error in Verification.VerifyValueDataType(that.Value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "value"));
                        yield return error;
                    }
                }

                if (that.ValueId != null)
                {
                    foreach (var error in Verification.Verify(that.ValueId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "valueId"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.AssetAdministrationShell that)
            {
                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.\n" +
                        "!(that.Extensions != null)\n" +
                        "|| Verification.ExtensionNamesAreUnique(that.Extensions)");
                }

                if (!(
                    !(that.DerivedFrom != null)
                    || Verification.IsModelReferenceTo(
                        that.DerivedFrom,
                        KeyTypes.AssetAdministrationShell)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "!(that.DerivedFrom != null)\n" +
                        "|| Verification.IsModelReferenceTo(\n" +
                        "    that.DerivedFrom,\n" +
                        "    KeyTypes.AssetAdministrationShell)");
                }

                if (!(
                    !(that.Submodels != null)
                    || (
                        that.Submodels.All(
                            reference => Verification.IsModelReferenceTo(reference, KeyTypes.Submodel))
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "!(that.Submodels != null)\n" +
                        "|| (\n" +
                        "    that.Submodels.All(\n" +
                        "        reference => Verification.IsModelReferenceTo(reference, KeyTypes.Submodel))\n" +
                        ")");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    foreach (var error in Verification.Verify(that.DisplayName))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "displayName"));
                        yield return error;
                    }
                }

                if (that.Description != null)
                {
                    foreach (var error in Verification.Verify(that.Description))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "description"));
                        yield return error;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Administration != null)
                {
                    foreach (var error in Verification.Verify(that.Administration))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "administration"));
                        yield return error;
                    }
                }

                foreach (var error in Verification.VerifyIdentifier(that.Id))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "id"));
                    yield return error;
                }

                if (that.DataSpecifications != null)
                {
                    int indexDataSpecifications = 0;
                    foreach (var item in that.DataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "dataSpecifications"));
                            yield return error;
                        }
                        indexDataSpecifications++;
                    }
                }

                if (that.DerivedFrom != null)
                {
                    foreach (var error in Verification.Verify(that.DerivedFrom))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "derivedFrom"));
                        yield return error;
                    }
                }

                foreach (var error in Verification.Verify(that.AssetInformation))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "assetInformation"));
                    yield return error;
                }

                if (that.Submodels != null)
                {
                    int indexSubmodels = 0;
                    foreach (var item in that.Submodels)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSubmodels));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "submodels"));
                            yield return error;
                        }
                        indexSubmodels++;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.AssetInformation that)
            {
                foreach (var error in Verification.VerifyAssetKind(that.AssetKind))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "assetKind"));
                    yield return error;
                }

                if (that.GlobalAssetId != null)
                {
                    foreach (var error in Verification.Verify(that.GlobalAssetId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "globalAssetId"));
                        yield return error;
                    }
                }

                if (that.SpecificAssetIds != null)
                {
                    int indexSpecificAssetIds = 0;
                    foreach (var item in that.SpecificAssetIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSpecificAssetIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "specificAssetIds"));
                            yield return error;
                        }
                        indexSpecificAssetIds++;
                    }
                }

                if (that.DefaultThumbnail != null)
                {
                    foreach (var error in Verification.Verify(that.DefaultThumbnail))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "defaultThumbnail"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.Resource that)
            {
                foreach (var error in Verification.VerifyPathType(that.Path))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "path"));
                    yield return error;
                }

                if (that.ContentType != null)
                {
                    foreach (var error in Verification.VerifyContentType(that.ContentType))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "contentType"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.SpecificAssetId that)
            {
                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.\n" +
                        "!(that.SupplementalSemanticIds != null)\n" +
                        "|| (that.SemanticId != null)");
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                foreach (var error in Verification.VerifyNonEmptyString(that.Name))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "name"));
                    yield return error;
                }

                foreach (var error in Verification.VerifyNonEmptyString(that.Value))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "value"));
                    yield return error;
                }

                foreach (var error in Verification.Verify(that.ExternalSubjectId))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "externalSubjectId"));
                    yield return error;
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.Submodel that)
            {
                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.\n" +
                        "!(that.Extensions != null)\n" +
                        "|| Verification.ExtensionNamesAreUnique(that.Extensions)");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.\n" +
                        "!(that.SupplementalSemanticIds != null)\n" +
                        "|| (that.SemanticId != null)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| Verification.QualifierTypesAreUnique(that.Qualifiers)");
                }

                if (!(
                    !(that.SubmodelElements != null)
                    || (
                        that.SubmodelElements.All(
                            element => element.IdShort != null)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "ID-shorts need to be defined for all the submodel elements.\n" +
                        "!(that.SubmodelElements != null)\n" +
                        "|| (\n" +
                        "    that.SubmodelElements.All(\n" +
                        "        element => element.IdShort != null)\n" +
                        ")");
                }

                if (!(
                    !(that.SubmodelElements != null)
                    || Verification.IdShortsAreUnique(that.SubmodelElements)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-120: ID-short of non-identifiable " +
                        "referables shall be unique in its namespace.\n" +
                        "!(that.SubmodelElements != null)\n" +
                        "|| Verification.IdShortsAreUnique(that.SubmodelElements)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| (\n" +
                        "    !(\n" +
                        "        that.Qualifiers.Any(\n" +
                        "            qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)\n" +
                        "    )\n" +
                        "    || (that.KindOrDefault() == ModelingKind.Template)\n" +
                        ")");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    foreach (var error in Verification.Verify(that.DisplayName))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "displayName"));
                        yield return error;
                    }
                }

                if (that.Description != null)
                {
                    foreach (var error in Verification.Verify(that.Description))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "description"));
                        yield return error;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Administration != null)
                {
                    foreach (var error in Verification.Verify(that.Administration))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "administration"));
                        yield return error;
                    }
                }

                foreach (var error in Verification.VerifyIdentifier(that.Id))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "id"));
                    yield return error;
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.DataSpecifications != null)
                {
                    int indexDataSpecifications = 0;
                    foreach (var item in that.DataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "dataSpecifications"));
                            yield return error;
                        }
                        indexDataSpecifications++;
                    }
                }

                if (that.SubmodelElements != null)
                {
                    int indexSubmodelElements = 0;
                    foreach (var item in that.SubmodelElements)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSubmodelElements));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "submodelElements"));
                            yield return error;
                        }
                        indexSubmodelElements++;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.RelationshipElement that)
            {
                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.\n" +
                        "!(that.Extensions != null)\n" +
                        "|| Verification.ExtensionNamesAreUnique(that.Extensions)");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.\n" +
                        "!(that.SupplementalSemanticIds != null)\n" +
                        "|| (that.SemanticId != null)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| Verification.QualifierTypesAreUnique(that.Qualifiers)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| (\n" +
                        "    !(\n" +
                        "        that.Qualifiers.Any(\n" +
                        "            qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)\n" +
                        "    )\n" +
                        "    || (that.KindOrDefault() == ModelingKind.Template)\n" +
                        ")");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    foreach (var error in Verification.Verify(that.DisplayName))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "displayName"));
                        yield return error;
                    }
                }

                if (that.Description != null)
                {
                    foreach (var error in Verification.Verify(that.Description))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "description"));
                        yield return error;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.DataSpecifications != null)
                {
                    int indexDataSpecifications = 0;
                    foreach (var item in that.DataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "dataSpecifications"));
                            yield return error;
                        }
                        indexDataSpecifications++;
                    }
                }

                foreach (var error in Verification.Verify(that.First))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "first"));
                    yield return error;
                }

                foreach (var error in Verification.Verify(that.Second))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "second"));
                    yield return error;
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.SubmodelElementList that)
            {
                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.\n" +
                        "!(that.Extensions != null)\n" +
                        "|| Verification.ExtensionNamesAreUnique(that.Extensions)");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.\n" +
                        "!(that.SupplementalSemanticIds != null)\n" +
                        "|| (that.SemanticId != null)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| Verification.QualifierTypesAreUnique(that.Qualifiers)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| (\n" +
                        "    !(\n" +
                        "        that.Qualifiers.Any(\n" +
                        "            qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)\n" +
                        "    )\n" +
                        "    || (that.KindOrDefault() == ModelingKind.Template)\n" +
                        ")");
                }

                if (!(
                    !(
                        (that.Value != null)
                        && (that.SemanticIdListElement != null)
                    )
                    || (
                        that.Value.All(
                            child => !(child.SemanticId != null)
                                || Verification.ReferenceKeyValuesEqual(child.SemanticId, that.SemanticIdListElement))
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-107: If a first level child element has " +
                        "a semantic ID it shall be identical to semantic ID list " +
                        "element.\n" +
                        "!(\n" +
                        "    (that.Value != null)\n" +
                        "    && (that.SemanticIdListElement != null)\n" +
                        ")\n" +
                        "|| (\n" +
                        "    that.Value.All(\n" +
                        "        child => !(child.SemanticId != null)\n" +
                        "            || Verification.ReferenceKeyValuesEqual(child.SemanticId, that.SemanticIdListElement))\n" +
                        ")");
                }

                if (!(
                    !(that.Value != null)
                    || Verification.SubmodelElementsHaveIdenticalSemanticIds(that.Value)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-114: If two first level child elements have " +
                        "a semantic ID then they shall be identical.\n" +
                        "!(that.Value != null)\n" +
                        "|| Verification.SubmodelElementsHaveIdenticalSemanticIds(that.Value)");
                }

                if (!(
                    !(that.Value != null)
                    || (
                        that.Value.All(
                            element => Verification.SubmodelElementIsOfType(element, that.TypeValueListElement))
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-108: All first level child elements shall " +
                        "have the same submodel element type as specified in type " +
                        "value list element.\n" +
                        "!(that.Value != null)\n" +
                        "|| (\n" +
                        "    that.Value.All(\n" +
                        "        element => Verification.SubmodelElementIsOfType(element, that.TypeValueListElement))\n" +
                        ")");
                }

                if (!(
                    !(
                        (that.Value != null)
                        && (
                            that.TypeValueListElement == AasSubmodelElements.Property
                            || that.TypeValueListElement == AasSubmodelElements.Range
                        )
                    )
                    || (
                        (that.ValueTypeListElement != null)
                        && Verification.PropertiesOrRangesHaveValueType(that.Value, that.ValueTypeListElement)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-109: If type value list element is equal to " +
                        "Property or Range value type list element shall be set and " +
                        "all first level child elements shall have the value type as " +
                        "specified in value type list element.\n" +
                        "!(\n" +
                        "    (that.Value != null)\n" +
                        "    && (\n" +
                        "        that.TypeValueListElement == AasSubmodelElements.Property\n" +
                        "        || that.TypeValueListElement == AasSubmodelElements.Range\n" +
                        "    )\n" +
                        ")\n" +
                        "|| (\n" +
                        "    (that.ValueTypeListElement != null)\n" +
                        "    && Verification.PropertiesOrRangesHaveValueType(that.Value, that.ValueTypeListElement)\n" +
                        ")");
                }

                if (!(
                    !(that.Value != null)
                    || (
                        that.Value.All(
                            element => element.IdShort == null)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-120: ID-shorts of submodel elements within " +
                        "a SubmodelElementList shall not be specified.\n" +
                        "!(that.Value != null)\n" +
                        "|| (\n" +
                        "    that.Value.All(\n" +
                        "        element => element.IdShort == null)\n" +
                        ")");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    foreach (var error in Verification.Verify(that.DisplayName))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "displayName"));
                        yield return error;
                    }
                }

                if (that.Description != null)
                {
                    foreach (var error in Verification.Verify(that.Description))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "description"));
                        yield return error;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.DataSpecifications != null)
                {
                    int indexDataSpecifications = 0;
                    foreach (var item in that.DataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "dataSpecifications"));
                            yield return error;
                        }
                        indexDataSpecifications++;
                    }
                }

                if (that.Value != null)
                {
                    int indexValue = 0;
                    foreach (var item in that.Value)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexValue));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "value"));
                            yield return error;
                        }
                        indexValue++;
                    }
                }

                if (that.SemanticIdListElement != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticIdListElement))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticIdListElement"));
                        yield return error;
                    }
                }

                foreach (
                        var error in Verification.VerifyAasSubmodelElements(
                            that.TypeValueListElement))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "typeValueListElement"));
                    yield return error;
                }

                if (that.ValueTypeListElement != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.DataTypeDefXsd value = that.ValueTypeListElement
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyDataTypeDefXsd(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "valueTypeListElement"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.SubmodelElementCollection that)
            {
                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.\n" +
                        "!(that.Extensions != null)\n" +
                        "|| Verification.ExtensionNamesAreUnique(that.Extensions)");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.\n" +
                        "!(that.SupplementalSemanticIds != null)\n" +
                        "|| (that.SemanticId != null)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| Verification.QualifierTypesAreUnique(that.Qualifiers)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| (\n" +
                        "    !(\n" +
                        "        that.Qualifiers.Any(\n" +
                        "            qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)\n" +
                        "    )\n" +
                        "    || (that.KindOrDefault() == ModelingKind.Template)\n" +
                        ")");
                }

                if (!(
                    !(that.Value != null)
                    || (
                        that.Value.All(
                            element => element.IdShort != null)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "ID-shorts need to be defined for all the elements.\n" +
                        "!(that.Value != null)\n" +
                        "|| (\n" +
                        "    that.Value.All(\n" +
                        "        element => element.IdShort != null)\n" +
                        ")");
                }

                if (!(
                    !(that.Value != null)
                    || Verification.IdShortsAreUnique(that.Value)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "!(that.Value != null)\n" +
                        "|| Verification.IdShortsAreUnique(that.Value)");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    foreach (var error in Verification.Verify(that.DisplayName))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "displayName"));
                        yield return error;
                    }
                }

                if (that.Description != null)
                {
                    foreach (var error in Verification.Verify(that.Description))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "description"));
                        yield return error;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.DataSpecifications != null)
                {
                    int indexDataSpecifications = 0;
                    foreach (var item in that.DataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "dataSpecifications"));
                            yield return error;
                        }
                        indexDataSpecifications++;
                    }
                }

                if (that.Value != null)
                {
                    int indexValue = 0;
                    foreach (var item in that.Value)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexValue));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "value"));
                            yield return error;
                        }
                        indexValue++;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.Property that)
            {
                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.\n" +
                        "!(that.Extensions != null)\n" +
                        "|| Verification.ExtensionNamesAreUnique(that.Extensions)");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.\n" +
                        "!(that.SupplementalSemanticIds != null)\n" +
                        "|| (that.SemanticId != null)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| Verification.QualifierTypesAreUnique(that.Qualifiers)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| (\n" +
                        "    !(\n" +
                        "        that.Qualifiers.Any(\n" +
                        "            qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)\n" +
                        "    )\n" +
                        "    || (that.KindOrDefault() == ModelingKind.Template)\n" +
                        ")");
                }

                if (!(
                    !(that.Category != null)
                    || Verification.DataElementCategoryIsValid(that.Category)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-090: For data elements category shall be " +
                        "one of the following values: CONSTANT, PARAMETER or VARIABLE\n" +
                        "!(that.Category != null)\n" +
                        "|| Verification.DataElementCategoryIsValid(that.Category)");
                }

                if (!(
                    !(that.Value != null)
                    || Verification.ValueConsistentWithXsdType(that.Value, that.ValueType)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "!(that.Value != null)\n" +
                        "|| Verification.ValueConsistentWithXsdType(that.Value, that.ValueType)");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    foreach (var error in Verification.Verify(that.DisplayName))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "displayName"));
                        yield return error;
                    }
                }

                if (that.Description != null)
                {
                    foreach (var error in Verification.Verify(that.Description))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "description"));
                        yield return error;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.DataSpecifications != null)
                {
                    int indexDataSpecifications = 0;
                    foreach (var item in that.DataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "dataSpecifications"));
                            yield return error;
                        }
                        indexDataSpecifications++;
                    }
                }

                foreach (var error in Verification.VerifyDataTypeDefXsd(that.ValueType))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "valueType"));
                    yield return error;
                }

                if (that.Value != null)
                {
                    foreach (var error in Verification.VerifyValueDataType(that.Value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "value"));
                        yield return error;
                    }
                }

                if (that.ValueId != null)
                {
                    foreach (var error in Verification.Verify(that.ValueId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "valueId"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.MultiLanguageProperty that)
            {
                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.\n" +
                        "!(that.Extensions != null)\n" +
                        "|| Verification.ExtensionNamesAreUnique(that.Extensions)");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.\n" +
                        "!(that.SupplementalSemanticIds != null)\n" +
                        "|| (that.SemanticId != null)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| Verification.QualifierTypesAreUnique(that.Qualifiers)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| (\n" +
                        "    !(\n" +
                        "        that.Qualifiers.Any(\n" +
                        "            qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)\n" +
                        "    )\n" +
                        "    || (that.KindOrDefault() == ModelingKind.Template)\n" +
                        ")");
                }

                if (!(
                    !(that.Category != null)
                    || Verification.DataElementCategoryIsValid(that.Category)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-090: For data elements category shall be " +
                        "one of the following values: CONSTANT, PARAMETER or VARIABLE\n" +
                        "!(that.Category != null)\n" +
                        "|| Verification.DataElementCategoryIsValid(that.Category)");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    foreach (var error in Verification.Verify(that.DisplayName))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "displayName"));
                        yield return error;
                    }
                }

                if (that.Description != null)
                {
                    foreach (var error in Verification.Verify(that.Description))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "description"));
                        yield return error;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.DataSpecifications != null)
                {
                    int indexDataSpecifications = 0;
                    foreach (var item in that.DataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "dataSpecifications"));
                            yield return error;
                        }
                        indexDataSpecifications++;
                    }
                }

                if (that.Value != null)
                {
                    foreach (var error in Verification.Verify(that.Value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "value"));
                        yield return error;
                    }
                }

                if (that.ValueId != null)
                {
                    foreach (var error in Verification.Verify(that.ValueId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "valueId"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.Range that)
            {
                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.\n" +
                        "!(that.Extensions != null)\n" +
                        "|| Verification.ExtensionNamesAreUnique(that.Extensions)");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.\n" +
                        "!(that.SupplementalSemanticIds != null)\n" +
                        "|| (that.SemanticId != null)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| Verification.QualifierTypesAreUnique(that.Qualifiers)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| (\n" +
                        "    !(\n" +
                        "        that.Qualifiers.Any(\n" +
                        "            qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)\n" +
                        "    )\n" +
                        "    || (that.KindOrDefault() == ModelingKind.Template)\n" +
                        ")");
                }

                if (!(
                    !(that.Category != null)
                    || Verification.DataElementCategoryIsValid(that.Category)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-090: For data elements category shall be " +
                        "one of the following values: CONSTANT, PARAMETER or VARIABLE\n" +
                        "!(that.Category != null)\n" +
                        "|| Verification.DataElementCategoryIsValid(that.Category)");
                }

                if (!(
                    !(that.Max != null)
                    || Verification.ValueConsistentWithXsdType(that.Max, that.ValueType)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "!(that.Max != null)\n" +
                        "|| Verification.ValueConsistentWithXsdType(that.Max, that.ValueType)");
                }

                if (!(
                    !(that.Min != null)
                    || Verification.ValueConsistentWithXsdType(that.Min, that.ValueType)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "!(that.Min != null)\n" +
                        "|| Verification.ValueConsistentWithXsdType(that.Min, that.ValueType)");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    foreach (var error in Verification.Verify(that.DisplayName))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "displayName"));
                        yield return error;
                    }
                }

                if (that.Description != null)
                {
                    foreach (var error in Verification.Verify(that.Description))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "description"));
                        yield return error;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.DataSpecifications != null)
                {
                    int indexDataSpecifications = 0;
                    foreach (var item in that.DataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "dataSpecifications"));
                            yield return error;
                        }
                        indexDataSpecifications++;
                    }
                }

                foreach (var error in Verification.VerifyDataTypeDefXsd(that.ValueType))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "valueType"));
                    yield return error;
                }

                if (that.Min != null)
                {
                    foreach (var error in Verification.VerifyValueDataType(that.Min))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "min"));
                        yield return error;
                    }
                }

                if (that.Max != null)
                {
                    foreach (var error in Verification.VerifyValueDataType(that.Max))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "max"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.ReferenceElement that)
            {
                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.\n" +
                        "!(that.Extensions != null)\n" +
                        "|| Verification.ExtensionNamesAreUnique(that.Extensions)");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.\n" +
                        "!(that.SupplementalSemanticIds != null)\n" +
                        "|| (that.SemanticId != null)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| Verification.QualifierTypesAreUnique(that.Qualifiers)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| (\n" +
                        "    !(\n" +
                        "        that.Qualifiers.Any(\n" +
                        "            qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)\n" +
                        "    )\n" +
                        "    || (that.KindOrDefault() == ModelingKind.Template)\n" +
                        ")");
                }

                if (!(
                    !(that.Category != null)
                    || Verification.DataElementCategoryIsValid(that.Category)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-090: For data elements category shall be " +
                        "one of the following values: CONSTANT, PARAMETER or VARIABLE\n" +
                        "!(that.Category != null)\n" +
                        "|| Verification.DataElementCategoryIsValid(that.Category)");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    foreach (var error in Verification.Verify(that.DisplayName))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "displayName"));
                        yield return error;
                    }
                }

                if (that.Description != null)
                {
                    foreach (var error in Verification.Verify(that.Description))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "description"));
                        yield return error;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.DataSpecifications != null)
                {
                    int indexDataSpecifications = 0;
                    foreach (var item in that.DataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "dataSpecifications"));
                            yield return error;
                        }
                        indexDataSpecifications++;
                    }
                }

                if (that.Value != null)
                {
                    foreach (var error in Verification.Verify(that.Value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "value"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.Blob that)
            {
                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.\n" +
                        "!(that.Extensions != null)\n" +
                        "|| Verification.ExtensionNamesAreUnique(that.Extensions)");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.\n" +
                        "!(that.SupplementalSemanticIds != null)\n" +
                        "|| (that.SemanticId != null)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| Verification.QualifierTypesAreUnique(that.Qualifiers)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| (\n" +
                        "    !(\n" +
                        "        that.Qualifiers.Any(\n" +
                        "            qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)\n" +
                        "    )\n" +
                        "    || (that.KindOrDefault() == ModelingKind.Template)\n" +
                        ")");
                }

                if (!(
                    !(that.Category != null)
                    || Verification.DataElementCategoryIsValid(that.Category)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-090: For data elements category shall be " +
                        "one of the following values: CONSTANT, PARAMETER or VARIABLE\n" +
                        "!(that.Category != null)\n" +
                        "|| Verification.DataElementCategoryIsValid(that.Category)");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    foreach (var error in Verification.Verify(that.DisplayName))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "displayName"));
                        yield return error;
                    }
                }

                if (that.Description != null)
                {
                    foreach (var error in Verification.Verify(that.Description))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "description"));
                        yield return error;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.DataSpecifications != null)
                {
                    int indexDataSpecifications = 0;
                    foreach (var item in that.DataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "dataSpecifications"));
                            yield return error;
                        }
                        indexDataSpecifications++;
                    }
                }

                if (that.Value != null)
                {
                    foreach (var error in Verification.VerifyBlobType(that.Value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "value"));
                        yield return error;
                    }
                }

                foreach (var error in Verification.VerifyContentType(that.ContentType))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "contentType"));
                    yield return error;
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.File that)
            {
                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.\n" +
                        "!(that.Extensions != null)\n" +
                        "|| Verification.ExtensionNamesAreUnique(that.Extensions)");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.\n" +
                        "!(that.SupplementalSemanticIds != null)\n" +
                        "|| (that.SemanticId != null)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| Verification.QualifierTypesAreUnique(that.Qualifiers)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| (\n" +
                        "    !(\n" +
                        "        that.Qualifiers.Any(\n" +
                        "            qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)\n" +
                        "    )\n" +
                        "    || (that.KindOrDefault() == ModelingKind.Template)\n" +
                        ")");
                }

                if (!(
                    !(that.Category != null)
                    || Verification.DataElementCategoryIsValid(that.Category)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-090: For data elements category shall be " +
                        "one of the following values: CONSTANT, PARAMETER or VARIABLE\n" +
                        "!(that.Category != null)\n" +
                        "|| Verification.DataElementCategoryIsValid(that.Category)");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    foreach (var error in Verification.Verify(that.DisplayName))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "displayName"));
                        yield return error;
                    }
                }

                if (that.Description != null)
                {
                    foreach (var error in Verification.Verify(that.Description))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "description"));
                        yield return error;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.DataSpecifications != null)
                {
                    int indexDataSpecifications = 0;
                    foreach (var item in that.DataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "dataSpecifications"));
                            yield return error;
                        }
                        indexDataSpecifications++;
                    }
                }

                if (that.Value != null)
                {
                    foreach (var error in Verification.VerifyPathType(that.Value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "value"));
                        yield return error;
                    }
                }

                foreach (var error in Verification.VerifyContentType(that.ContentType))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "contentType"));
                    yield return error;
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.AnnotatedRelationshipElement that)
            {
                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.\n" +
                        "!(that.Extensions != null)\n" +
                        "|| Verification.ExtensionNamesAreUnique(that.Extensions)");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.\n" +
                        "!(that.SupplementalSemanticIds != null)\n" +
                        "|| (that.SemanticId != null)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| Verification.QualifierTypesAreUnique(that.Qualifiers)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| (\n" +
                        "    !(\n" +
                        "        that.Qualifiers.Any(\n" +
                        "            qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)\n" +
                        "    )\n" +
                        "    || (that.KindOrDefault() == ModelingKind.Template)\n" +
                        ")");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    foreach (var error in Verification.Verify(that.DisplayName))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "displayName"));
                        yield return error;
                    }
                }

                if (that.Description != null)
                {
                    foreach (var error in Verification.Verify(that.Description))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "description"));
                        yield return error;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.DataSpecifications != null)
                {
                    int indexDataSpecifications = 0;
                    foreach (var item in that.DataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "dataSpecifications"));
                            yield return error;
                        }
                        indexDataSpecifications++;
                    }
                }

                foreach (var error in Verification.Verify(that.First))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "first"));
                    yield return error;
                }

                foreach (var error in Verification.Verify(that.Second))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "second"));
                    yield return error;
                }

                if (that.Annotations != null)
                {
                    int indexAnnotations = 0;
                    foreach (var item in that.Annotations)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexAnnotations));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "annotations"));
                            yield return error;
                        }
                        indexAnnotations++;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.Entity that)
            {
                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.\n" +
                        "!(that.Extensions != null)\n" +
                        "|| Verification.ExtensionNamesAreUnique(that.Extensions)");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.\n" +
                        "!(that.SupplementalSemanticIds != null)\n" +
                        "|| (that.SemanticId != null)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| Verification.QualifierTypesAreUnique(that.Qualifiers)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| (\n" +
                        "    !(\n" +
                        "        that.Qualifiers.Any(\n" +
                        "            qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)\n" +
                        "    )\n" +
                        "    || (that.KindOrDefault() == ModelingKind.Template)\n" +
                        ")");
                }

                if (!(
                    (
                        that.EntityType == EntityType.SelfManagedEntity
                        && (
                            (
                                (that.GlobalAssetId != null)
                                && (that.SpecificAssetId == null)
                            )
                            || (
                                (that.GlobalAssetId == null)
                                && (that.SpecificAssetId != null)
                            )
                        )
                    )
                    || (
                        (that.GlobalAssetId == null)
                        && (that.SpecificAssetId == null)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-014: Either the attribute global asset ID " +
                        "or specific asset ID must be set if entity type is set to " +
                        "'SelfManagedEntity'. They are not existing otherwise.\n" +
                        "(\n" +
                        "    that.EntityType == EntityType.SelfManagedEntity\n" +
                        "    && (\n" +
                        "        (\n" +
                        "            (that.GlobalAssetId != null)\n" +
                        "            && (that.SpecificAssetId == null)\n" +
                        "        )\n" +
                        "        || (\n" +
                        "            (that.GlobalAssetId == null)\n" +
                        "            && (that.SpecificAssetId != null)\n" +
                        "        )\n" +
                        "    )\n" +
                        ")\n" +
                        "|| (\n" +
                        "    (that.GlobalAssetId == null)\n" +
                        "    && (that.SpecificAssetId == null)\n" +
                        ")");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    foreach (var error in Verification.Verify(that.DisplayName))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "displayName"));
                        yield return error;
                    }
                }

                if (that.Description != null)
                {
                    foreach (var error in Verification.Verify(that.Description))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "description"));
                        yield return error;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.DataSpecifications != null)
                {
                    int indexDataSpecifications = 0;
                    foreach (var item in that.DataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "dataSpecifications"));
                            yield return error;
                        }
                        indexDataSpecifications++;
                    }
                }

                if (that.Statements != null)
                {
                    int indexStatements = 0;
                    foreach (var item in that.Statements)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexStatements));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "statements"));
                            yield return error;
                        }
                        indexStatements++;
                    }
                }

                foreach (var error in Verification.VerifyEntityType(that.EntityType))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "entityType"));
                    yield return error;
                }

                if (that.GlobalAssetId != null)
                {
                    foreach (var error in Verification.Verify(that.GlobalAssetId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "globalAssetId"));
                        yield return error;
                    }
                }

                if (that.SpecificAssetId != null)
                {
                    foreach (var error in Verification.Verify(that.SpecificAssetId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "specificAssetId"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.EventPayload that)
            {
                if (!(
                    Verification.IsModelReferenceTo(that.Source, KeyTypes.Referable)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Verification.IsModelReferenceTo(that.Source, KeyTypes.Referable)");
                }

                if (!(
                    Verification.IsModelReferenceTo(that.ObservableReference, KeyTypes.Referable)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Verification.IsModelReferenceTo(that.ObservableReference, KeyTypes.Referable)");
                }

                foreach (var error in Verification.Verify(that.Source))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "source"));
                    yield return error;
                }

                if (that.SourceSemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SourceSemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "sourceSemanticId"));
                        yield return error;
                    }
                }

                foreach (var error in Verification.Verify(that.ObservableReference))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "observableReference"));
                    yield return error;
                }

                if (that.ObservableSemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.ObservableSemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "observableSemanticId"));
                        yield return error;
                    }
                }

                if (that.Topic != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Topic))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "topic"));
                        yield return error;
                    }
                }

                if (that.SubjectId != null)
                {
                    foreach (var error in Verification.Verify(that.SubjectId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "subjectId"));
                        yield return error;
                    }
                }

                foreach (var error in Verification.VerifyDateTimeStampUtc(that.TimeStamp))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "timeStamp"));
                    yield return error;
                }

                if (that.Payload != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Payload))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "payload"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.BasicEventElement that)
            {
                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.\n" +
                        "!(that.Extensions != null)\n" +
                        "|| Verification.ExtensionNamesAreUnique(that.Extensions)");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.\n" +
                        "!(that.SupplementalSemanticIds != null)\n" +
                        "|| (that.SemanticId != null)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| Verification.QualifierTypesAreUnique(that.Qualifiers)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| (\n" +
                        "    !(\n" +
                        "        that.Qualifiers.Any(\n" +
                        "            qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)\n" +
                        "    )\n" +
                        "    || (that.KindOrDefault() == ModelingKind.Template)\n" +
                        ")");
                }

                if (!(
                    !(that.Direction == Direction.Input)
                    || (that.MaxInterval == null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Max. interval is not applicable for input direction\n" +
                        "!(that.Direction == Direction.Input)\n" +
                        "|| (that.MaxInterval == null)");
                }

                if (!(
                    Verification.IsModelReferenceTo(that.Observed, KeyTypes.Referable)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Verification.IsModelReferenceTo(that.Observed, KeyTypes.Referable)");
                }

                if (!(
                    !(that.MessageBroker != null)
                    || Verification.IsModelReferenceTo(that.MessageBroker, KeyTypes.Referable)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "!(that.MessageBroker != null)\n" +
                        "|| Verification.IsModelReferenceTo(that.MessageBroker, KeyTypes.Referable)");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    foreach (var error in Verification.Verify(that.DisplayName))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "displayName"));
                        yield return error;
                    }
                }

                if (that.Description != null)
                {
                    foreach (var error in Verification.Verify(that.Description))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "description"));
                        yield return error;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.DataSpecifications != null)
                {
                    int indexDataSpecifications = 0;
                    foreach (var item in that.DataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "dataSpecifications"));
                            yield return error;
                        }
                        indexDataSpecifications++;
                    }
                }

                foreach (var error in Verification.Verify(that.Observed))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "observed"));
                    yield return error;
                }

                foreach (var error in Verification.VerifyDirection(that.Direction))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "direction"));
                    yield return error;
                }

                foreach (var error in Verification.VerifyStateOfEvent(that.State))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "state"));
                    yield return error;
                }

                if (that.MessageTopic != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.MessageTopic))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "messageTopic"));
                        yield return error;
                    }
                }

                if (that.MessageBroker != null)
                {
                    foreach (var error in Verification.Verify(that.MessageBroker))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "messageBroker"));
                        yield return error;
                    }
                }

                if (that.LastUpdate != null)
                {
                    foreach (var error in Verification.VerifyDateTimeStampUtc(that.LastUpdate))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "lastUpdate"));
                        yield return error;
                    }
                }

                if (that.MinInterval != null)
                {
                    foreach (var error in Verification.VerifyDateTimeStampUtc(that.MinInterval))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "minInterval"));
                        yield return error;
                    }
                }

                if (that.MaxInterval != null)
                {
                    foreach (var error in Verification.VerifyDateTimeStampUtc(that.MaxInterval))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "maxInterval"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.Operation that)
            {
                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.\n" +
                        "!(that.Extensions != null)\n" +
                        "|| Verification.ExtensionNamesAreUnique(that.Extensions)");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.\n" +
                        "!(that.SupplementalSemanticIds != null)\n" +
                        "|| (that.SemanticId != null)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| Verification.QualifierTypesAreUnique(that.Qualifiers)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| (\n" +
                        "    !(\n" +
                        "        that.Qualifiers.Any(\n" +
                        "            qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)\n" +
                        "    )\n" +
                        "    || (that.KindOrDefault() == ModelingKind.Template)\n" +
                        ")");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    foreach (var error in Verification.Verify(that.DisplayName))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "displayName"));
                        yield return error;
                    }
                }

                if (that.Description != null)
                {
                    foreach (var error in Verification.Verify(that.Description))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "description"));
                        yield return error;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.DataSpecifications != null)
                {
                    int indexDataSpecifications = 0;
                    foreach (var item in that.DataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "dataSpecifications"));
                            yield return error;
                        }
                        indexDataSpecifications++;
                    }
                }

                if (that.InputVariables != null)
                {
                    int indexInputVariables = 0;
                    foreach (var item in that.InputVariables)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexInputVariables));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "inputVariables"));
                            yield return error;
                        }
                        indexInputVariables++;
                    }
                }

                if (that.OutputVariables != null)
                {
                    int indexOutputVariables = 0;
                    foreach (var item in that.OutputVariables)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexOutputVariables));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "outputVariables"));
                            yield return error;
                        }
                        indexOutputVariables++;
                    }
                }

                if (that.InoutputVariables != null)
                {
                    int indexInoutputVariables = 0;
                    foreach (var item in that.InoutputVariables)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexInoutputVariables));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "inoutputVariables"));
                            yield return error;
                        }
                        indexInoutputVariables++;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.OperationVariable that)
            {
                foreach (var error in Verification.Verify(that.Value))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "value"));
                    yield return error;
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.Capability that)
            {
                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.\n" +
                        "!(that.Extensions != null)\n" +
                        "|| Verification.ExtensionNamesAreUnique(that.Extensions)");
                }

                if (!(
                    !(that.SupplementalSemanticIds != null)
                    || (that.SemanticId != null)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-118: If there are supplemental semantic IDs " +
                        "defined then there shall be also a main semantic ID.\n" +
                        "!(that.SupplementalSemanticIds != null)\n" +
                        "|| (that.SemanticId != null)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || Verification.QualifierTypesAreUnique(that.Qualifiers)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-021: Every qualifiable can only have one " +
                        "qualifier with the same type.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| Verification.QualifierTypesAreUnique(that.Qualifiers)");
                }

                if (!(
                    !(that.Qualifiers != null)
                    || (
                        !(
                            that.Qualifiers.Any(
                                qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)
                        )
                        || (that.KindOrDefault() == ModelingKind.Template)
                    )))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-119: If any qualifier kind value of " +
                        "a qualifiable qualifier is equal to template qualifier and " +
                        "the qualified element has kind then the qualified element " +
                        "shall be of kind template.\n" +
                        "!(that.Qualifiers != null)\n" +
                        "|| (\n" +
                        "    !(\n" +
                        "        that.Qualifiers.Any(\n" +
                        "            qualifier => qualifier.Kind == QualifierKind.TemplateQualifier)\n" +
                        "    )\n" +
                        "    || (that.KindOrDefault() == ModelingKind.Template)\n" +
                        ")");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    foreach (var error in Verification.Verify(that.DisplayName))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "displayName"));
                        yield return error;
                    }
                }

                if (that.Description != null)
                {
                    foreach (var error in Verification.Verify(that.Description))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "description"));
                        yield return error;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Kind != null)
                {
                    // We need to help the static analyzer with a null coalescing.
                    Aas.ModelingKind value = that.Kind
                        ?? throw new System.InvalidOperationException();
                    foreach (var error in Verification.VerifyModelingKind(value))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "kind"));
                        yield return error;
                    }
                }

                if (that.SemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.SemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "semanticId"));
                        yield return error;
                    }
                }

                if (that.SupplementalSemanticIds != null)
                {
                    int indexSupplementalSemanticIds = 0;
                    foreach (var item in that.SupplementalSemanticIds)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSupplementalSemanticIds));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "supplementalSemanticIds"));
                            yield return error;
                        }
                        indexSupplementalSemanticIds++;
                    }
                }

                if (that.Qualifiers != null)
                {
                    int indexQualifiers = 0;
                    foreach (var item in that.Qualifiers)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexQualifiers));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "qualifiers"));
                            yield return error;
                        }
                        indexQualifiers++;
                    }
                }

                if (that.DataSpecifications != null)
                {
                    int indexDataSpecifications = 0;
                    foreach (var item in that.DataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "dataSpecifications"));
                            yield return error;
                        }
                        indexDataSpecifications++;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.ConceptDescription that)
            {
                if (!(
                    !(that.Extensions != null)
                    || Verification.ExtensionNamesAreUnique(that.Extensions)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-077: The name of an extension within " +
                        "Has-Extensions needs to be unique.\n" +
                        "!(that.Extensions != null)\n" +
                        "|| Verification.ExtensionNamesAreUnique(that.Extensions)");
                }

                if (!(
                    !(that.Category != null)
                    || Verification.ConceptDescriptionCategoryIsValid(that.Category)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Constraint AASd-051: A concept description shall have one " +
                        "of the following categories: 'VALUE', 'PROPERTY', " +
                        "'REFERENCE', 'DOCUMENT', 'CAPABILITY',; 'RELATIONSHIP', " +
                        "'COLLECTION', 'FUNCTION', 'EVENT', 'ENTITY', " +
                        "'APPLICATION_CLASS', 'QUALIFIER', 'VIEW'.\n" +
                        "!(that.Category != null)\n" +
                        "|| Verification.ConceptDescriptionCategoryIsValid(that.Category)");
                }

                if (that.Extensions != null)
                {
                    int indexExtensions = 0;
                    foreach (var item in that.Extensions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexExtensions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "extensions"));
                            yield return error;
                        }
                        indexExtensions++;
                    }
                }

                if (that.Category != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Category))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "category"));
                        yield return error;
                    }
                }

                if (that.IdShort != null)
                {
                    foreach (var error in Verification.VerifyIdShort(that.IdShort))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "idShort"));
                        yield return error;
                    }
                }

                if (that.DisplayName != null)
                {
                    foreach (var error in Verification.Verify(that.DisplayName))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "displayName"));
                        yield return error;
                    }
                }

                if (that.Description != null)
                {
                    foreach (var error in Verification.Verify(that.Description))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "description"));
                        yield return error;
                    }
                }

                if (that.Checksum != null)
                {
                    foreach (var error in Verification.VerifyNonEmptyString(that.Checksum))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "checksum"));
                        yield return error;
                    }
                }

                if (that.Administration != null)
                {
                    foreach (var error in Verification.Verify(that.Administration))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "administration"));
                        yield return error;
                    }
                }

                foreach (var error in Verification.VerifyIdentifier(that.Id))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "id"));
                    yield return error;
                }

                if (that.DataSpecifications != null)
                {
                    int indexDataSpecifications = 0;
                    foreach (var item in that.DataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "dataSpecifications"));
                            yield return error;
                        }
                        indexDataSpecifications++;
                    }
                }

                if (that.IsCaseOf != null)
                {
                    int indexIsCaseOf = 0;
                    foreach (var item in that.IsCaseOf)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexIsCaseOf));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "isCaseOf"));
                            yield return error;
                        }
                        indexIsCaseOf++;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.Reference that)
            {
                if (!(that.Keys.Count >= 1))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "that.Keys.Count >= 1");
                }

                foreach (var error in Verification.VerifyReferenceTypes(that.Type))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "type"));
                    yield return error;
                }

                if (that.ReferredSemanticId != null)
                {
                    foreach (var error in Verification.Verify(that.ReferredSemanticId))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "referredSemanticId"));
                        yield return error;
                    }
                }

                int indexKeys = 0;
                foreach (var item in that.Keys)
                {
                    foreach (var error in Verification.Verify(item))
                    {
                        error.PrependSegment(
                            new Reporting.IndexSegment(
                                indexKeys));
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "keys"));
                        yield return error;
                    }
                    indexKeys++;
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.Key that)
            {
                foreach (var error in Verification.VerifyKeyTypes(that.Type))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "type"));
                    yield return error;
                }

                foreach (var error in Verification.VerifyNonEmptyString(that.Value))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "value"));
                    yield return error;
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.LangString that)
            {
                foreach (var error in Verification.VerifyBcp47LanguageTag(that.Language))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "language"));
                    yield return error;
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.LangStringSet that)
            {
                if (!(that.LangStrings.Count >= 1))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "that.LangStrings.Count >= 1");
                }

                if (!(
                    Verification.LangStringsHaveUniqueLanguages(that.LangStrings)))
                {
                    yield return new Reporting.Error(
                        "Invariant violated:\n" +
                        "Verification.LangStringsHaveUniqueLanguages(that.LangStrings)");
                }

                int indexLangStrings = 0;
                foreach (var item in that.LangStrings)
                {
                    foreach (var error in Verification.Verify(item))
                    {
                        error.PrependSegment(
                            new Reporting.IndexSegment(
                                indexLangStrings));
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "langStrings"));
                        yield return error;
                    }
                    indexLangStrings++;
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.DataSpecificationContent that)
            {
                // No verification has been defined for DataSpecificationContent.
                yield break;
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.DataSpecification that)
            {
                foreach (var error in Verification.VerifyIdentifier(that.Id))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "id"));
                    yield return error;
                }

                foreach (var error in Verification.Verify(that.DataSpecificationContent))
                {
                    error.PrependSegment(
                        new Reporting.NameSegment(
                            "dataSpecificationContent"));
                    yield return error;
                }

                if (that.Administration != null)
                {
                    foreach (var error in Verification.Verify(that.Administration))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "administration"));
                        yield return error;
                    }
                }

                if (that.Description != null)
                {
                    foreach (var error in Verification.Verify(that.Description))
                    {
                        error.PrependSegment(
                            new Reporting.NameSegment(
                                "description"));
                        yield return error;
                    }
                }
            }

            [CodeAnalysis.SuppressMessage("ReSharper", "NegativeEqualityExpression")]
            public override IEnumerable<Reporting.Error> Transform(
                Aas.Environment that)
            {
                if (that.AssetAdministrationShells != null)
                {
                    int indexAssetAdministrationShells = 0;
                    foreach (var item in that.AssetAdministrationShells)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexAssetAdministrationShells));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "assetAdministrationShells"));
                            yield return error;
                        }
                        indexAssetAdministrationShells++;
                    }
                }

                if (that.Submodels != null)
                {
                    int indexSubmodels = 0;
                    foreach (var item in that.Submodels)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexSubmodels));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "submodels"));
                            yield return error;
                        }
                        indexSubmodels++;
                    }
                }

                if (that.ConceptDescriptions != null)
                {
                    int indexConceptDescriptions = 0;
                    foreach (var item in that.ConceptDescriptions)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexConceptDescriptions));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "conceptDescriptions"));
                            yield return error;
                        }
                        indexConceptDescriptions++;
                    }
                }

                if (that.DataSpecifications != null)
                {
                    int indexDataSpecifications = 0;
                    foreach (var item in that.DataSpecifications)
                    {
                        foreach (var error in Verification.Verify(item))
                        {
                            error.PrependSegment(
                                new Reporting.IndexSegment(
                                    indexDataSpecifications));
                            error.PrependSegment(
                                new Reporting.NameSegment(
                                    "dataSpecifications"));
                            yield return error;
                        }
                        indexDataSpecifications++;
                    }
                }
            }
        }  // private class Transformer

        /// <summary>
        /// Verify the constraints of <paramref name="that" /> recursively.
        /// </summary>
        /// <param name="that">
        /// The instance of the meta-model to be verified
        /// </param>
        public static IEnumerable<Reporting.Error> Verify(Aas.IClass that)
        {
            foreach (var error in _transformer.Transform(that))
            {
                yield return error;
            }
        }

        /// <summary>
        /// Verify the constraints of <paramref name="that" />.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyNonEmptyString(
            string that)
        {
            if (!(that.Length >= 1))
            {
                yield return new Reporting.Error(
                    "Invariant violated:\n" +
                    "that.Length >= 1");
            }
        }

        /// <summary>
        /// Verify the constraints of <paramref name="that" />.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyDateTimeStampUtc(
            string that)
        {
            if (!Verification.MatchesXsDateTimeStampUtc(that))
            {
                yield return new Reporting.Error(
                    "Invariant violated:\n" +
                    "Verification.MatchesXsDateTimeStampUtc(that)");
            }

            if (!Verification.IsXsDateTimeStampUtc(that))
            {
                yield return new Reporting.Error(
                    "Invariant violated:\n" +
                    "Verification.IsXsDateTimeStampUtc(that)");
            }
        }

        /// <summary>
        /// Verify the constraints of <paramref name="that" />.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyBlobType(
            byte[] that)
        {
            // There is no verification specified.
            yield break;
        }

        /// <summary>
        /// Verify the constraints of <paramref name="that" />.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyIdentifier(
            string that)
        {
            if (!(that.Length >= 1))
            {
                yield return new Reporting.Error(
                    "Invariant violated:\n" +
                    "that.Length >= 1");
            }
        }

        /// <summary>
        /// Verify the constraints of <paramref name="that" />.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyBcp47LanguageTag(
            string that)
        {
            if (!Verification.MatchesBcp47(that))
            {
                yield return new Reporting.Error(
                    "Invariant violated:\n" +
                    "Verification.MatchesBcp47(that)");
            }
        }

        /// <summary>
        /// Verify the constraints of <paramref name="that" />.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyContentType(
            string that)
        {
            if (!(that.Length >= 1))
            {
                yield return new Reporting.Error(
                    "Invariant violated:\n" +
                    "that.Length >= 1");
            }

            if (!Verification.MatchesMimeType(that))
            {
                yield return new Reporting.Error(
                    "Invariant violated:\n" +
                    "Verification.MatchesMimeType(that)");
            }
        }

        /// <summary>
        /// Verify the constraints of <paramref name="that" />.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyPathType(
            string that)
        {
            if (!(that.Length >= 1))
            {
                yield return new Reporting.Error(
                    "Invariant violated:\n" +
                    "that.Length >= 1");
            }

            if (!Verification.MatchesRfc8089Path(that))
            {
                yield return new Reporting.Error(
                    "Invariant violated:\n" +
                    "Verification.MatchesRfc8089Path(that)");
            }
        }

        /// <summary>
        /// Verify the constraints of <paramref name="that" />.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyQualifierType(
            string that)
        {
            if (!(that.Length >= 1))
            {
                yield return new Reporting.Error(
                    "Invariant violated:\n" +
                    "that.Length >= 1");
            }
        }

        /// <summary>
        /// Verify the constraints of <paramref name="that" />.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyValueDataType(
            string that)
        {
            // There is no verification specified.
            yield break;
        }

        /// <summary>
        /// Verify the constraints of <paramref name="that" />.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyIdShort(
            string that)
        {
            if (!(that.Length <= 128))
            {
                yield return new Reporting.Error(
                    "Invariant violated:\n" +
                    "Constraint AASd-027: ID-short shall have a maximum length " +
                    "of 128 characters.\n" +
                    "that.Length <= 128");
            }

            if (!Verification.MatchesIdShort(that))
            {
                yield return new Reporting.Error(
                    "Invariant violated:\n" +
                    "ID-short of Referables shall only feature letters, digits, " +
                    "underscore (``_``); starting mandatory with a letter. " +
                    "*I.e.* ``[a-zA-Z][a-zA-Z0-9_]+``.\n" +
                    "Verification.MatchesIdShort(that)");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyModelingKind(
            Aas.ModelingKind that)
        {
            if (!EnumValueSet.ForModelingKind.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid ModelingKind: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyQualifierKind(
            Aas.QualifierKind that)
        {
            if (!EnumValueSet.ForQualifierKind.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid QualifierKind: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyAssetKind(
            Aas.AssetKind that)
        {
            if (!EnumValueSet.ForAssetKind.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid AssetKind: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyEntityType(
            Aas.EntityType that)
        {
            if (!EnumValueSet.ForEntityType.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid EntityType: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyDirection(
            Aas.Direction that)
        {
            if (!EnumValueSet.ForDirection.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid Direction: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyStateOfEvent(
            Aas.StateOfEvent that)
        {
            if (!EnumValueSet.ForStateOfEvent.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid StateOfEvent: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyReferenceTypes(
            Aas.ReferenceTypes that)
        {
            if (!EnumValueSet.ForReferenceTypes.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid ReferenceTypes: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyGenericFragmentKeys(
            Aas.GenericFragmentKeys that)
        {
            if (!EnumValueSet.ForGenericFragmentKeys.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid GenericFragmentKeys: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyGenericGloballyIdentifiables(
            Aas.GenericGloballyIdentifiables that)
        {
            if (!EnumValueSet.ForGenericGloballyIdentifiables.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid GenericGloballyIdentifiables: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyAasIdentifiables(
            Aas.AasIdentifiables that)
        {
            if (!EnumValueSet.ForAasIdentifiables.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid AasIdentifiables: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyAasSubmodelElements(
            Aas.AasSubmodelElements that)
        {
            if (!EnumValueSet.ForAasSubmodelElements.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid AasSubmodelElements: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyAasReferableNonIdentifiables(
            Aas.AasReferableNonIdentifiables that)
        {
            if (!EnumValueSet.ForAasReferableNonIdentifiables.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid AasReferableNonIdentifiables: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyAasReferables(
            Aas.AasReferables that)
        {
            if (!EnumValueSet.ForAasReferables.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid AasReferables: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyGloballyIdentifiables(
            Aas.GloballyIdentifiables that)
        {
            if (!EnumValueSet.ForGloballyIdentifiables.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid GloballyIdentifiables: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyFragmentKeys(
            Aas.FragmentKeys that)
        {
            if (!EnumValueSet.ForFragmentKeys.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid FragmentKeys: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyKeyTypes(
            Aas.KeyTypes that)
        {
            if (!EnumValueSet.ForKeyTypes.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid KeyTypes: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyDataTypeDefXsd(
            Aas.DataTypeDefXsd that)
        {
            if (!EnumValueSet.ForDataTypeDefXsd.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid DataTypeDefXsd: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyDataTypeDefRdf(
            Aas.DataTypeDefRdf that)
        {
            if (!EnumValueSet.ForDataTypeDefRdf.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid DataTypeDefRdf: {that}");
            }
        }

        /// <summary>
        /// Verify that <paramref name="that" /> is a valid enumeration value.
        /// </summary>
        public static IEnumerable<Reporting.Error> VerifyDataTypeDef(
            Aas.DataTypeDef that)
        {
            if (!EnumValueSet.ForDataTypeDef.Contains(
                (int)that))
            {
                yield return new Reporting.Error(
                    $"Invalid DataTypeDef: {that}");
            }
        }
    }  // public static class Verification
}  // namespace AasCore.Aas3_0_RC02

/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */
