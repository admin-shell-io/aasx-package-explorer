/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */

using Aas = AasCore.Aas3_0_RC02;  // renamed
using CodeAnalysis = System.Diagnostics.CodeAnalysis;

using System.Collections.Generic;  // can't alias

namespace AasCore.Aas3_0_RC02
{
    public static class Stringification
    {
        private static readonly Dictionary<Aas.ModelingKind, string> ModelingKindToString = (
            new Dictionary<Aas.ModelingKind, string>()
            {
                { Aas.ModelingKind.Template, "Template" },
                { Aas.ModelingKind.Instance, "Instance" }
            });

        /// <summary>
        /// Retrieve the string representation of <paramref name="that" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="that" /> is not a valid literal, return <c>null</c>.
        /// </remarks>
        public static string? ToString(Aas.ModelingKind? that)
        {
            if (!that.HasValue)
            {
                return null;
            }
            else
            {
                if (ModelingKindToString.TryGetValue(that.Value, out string? value))
                {
                    return value;
                }
                else
                {
                    return null;
                }
            }
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        private static readonly Dictionary<string, Aas.ModelingKind> _modelingKindFromString = (
            new Dictionary<string, Aas.ModelingKind>()
            {
                { "Template", Aas.ModelingKind.Template },
                { "Instance", Aas.ModelingKind.Instance }
            });

        /// <summary>
        /// Parse the string representation of <see cref="ModelingKind" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="text" /> is not a valid string representation
        /// of a literal of <see cref="ModelingKind" />,
        /// return <c>null</c>.
        /// </remarks>
        public static Aas.ModelingKind? ModelingKindFromString(string text)
        {
            if (_modelingKindFromString.TryGetValue(text, out ModelingKind value))
            {
                return value;
            }
            else
            {
                return null;
            }
        }

        private static readonly Dictionary<Aas.QualifierKind, string> QualifierKindToString = (
            new Dictionary<Aas.QualifierKind, string>()
            {
                { Aas.QualifierKind.ValueQualifier, "ValueQualifier" },
                { Aas.QualifierKind.ConceptQualifier, "ConceptQualifier" },
                { Aas.QualifierKind.TemplateQualifier, "TemplateQualifier" }
            });

        /// <summary>
        /// Retrieve the string representation of <paramref name="that" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="that" /> is not a valid literal, return <c>null</c>.
        /// </remarks>
        public static string? ToString(Aas.QualifierKind? that)
        {
            if (!that.HasValue)
            {
                return null;
            }
            else
            {
                if (QualifierKindToString.TryGetValue(that.Value, out string? value))
                {
                    return value;
                }
                else
                {
                    return null;
                }
            }
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        private static readonly Dictionary<string, Aas.QualifierKind> _qualifierKindFromString = (
            new Dictionary<string, Aas.QualifierKind>()
            {
                { "ValueQualifier", Aas.QualifierKind.ValueQualifier },
                { "ConceptQualifier", Aas.QualifierKind.ConceptQualifier },
                { "TemplateQualifier", Aas.QualifierKind.TemplateQualifier }
            });

        /// <summary>
        /// Parse the string representation of <see cref="QualifierKind" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="text" /> is not a valid string representation
        /// of a literal of <see cref="QualifierKind" />,
        /// return <c>null</c>.
        /// </remarks>
        public static Aas.QualifierKind? QualifierKindFromString(string text)
        {
            if (_qualifierKindFromString.TryGetValue(text, out QualifierKind value))
            {
                return value;
            }
            else
            {
                return null;
            }
        }

        private static readonly Dictionary<Aas.AssetKind, string> AssetKindToString = (
            new Dictionary<Aas.AssetKind, string>()
            {
                { Aas.AssetKind.Type, "Type" },
                { Aas.AssetKind.Instance, "Instance" }
            });

        /// <summary>
        /// Retrieve the string representation of <paramref name="that" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="that" /> is not a valid literal, return <c>null</c>.
        /// </remarks>
        public static string? ToString(Aas.AssetKind? that)
        {
            if (!that.HasValue)
            {
                return null;
            }
            else
            {
                if (AssetKindToString.TryGetValue(that.Value, out string? value))
                {
                    return value;
                }
                else
                {
                    return null;
                }
            }
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        private static readonly Dictionary<string, Aas.AssetKind> _assetKindFromString = (
            new Dictionary<string, Aas.AssetKind>()
            {
                { "Type", Aas.AssetKind.Type },
                { "Instance", Aas.AssetKind.Instance }
            });

        /// <summary>
        /// Parse the string representation of <see cref="AssetKind" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="text" /> is not a valid string representation
        /// of a literal of <see cref="AssetKind" />,
        /// return <c>null</c>.
        /// </remarks>
        public static Aas.AssetKind? AssetKindFromString(string text)
        {
            if (_assetKindFromString.TryGetValue(text, out AssetKind value))
            {
                return value;
            }
            else
            {
                return null;
            }
        }

        private static readonly Dictionary<Aas.AasSubmodelElements, string> AasSubmodelElementsToString = (
            new Dictionary<Aas.AasSubmodelElements, string>()
            {
                { Aas.AasSubmodelElements.AnnotatedRelationshipElement, "AnnotatedRelationshipElement" },
                { Aas.AasSubmodelElements.BasicEventElement, "BasicEventElement" },
                { Aas.AasSubmodelElements.Blob, "Blob" },
                { Aas.AasSubmodelElements.Capability, "Capability" },
                { Aas.AasSubmodelElements.DataElement, "DataElement" },
                { Aas.AasSubmodelElements.Entity, "Entity" },
                { Aas.AasSubmodelElements.EventElement, "EventElement" },
                { Aas.AasSubmodelElements.File, "File" },
                { Aas.AasSubmodelElements.MultiLanguageProperty, "MultiLanguageProperty" },
                { Aas.AasSubmodelElements.Operation, "Operation" },
                { Aas.AasSubmodelElements.Property, "Property" },
                { Aas.AasSubmodelElements.Range, "Range" },
                { Aas.AasSubmodelElements.ReferenceElement, "ReferenceElement" },
                { Aas.AasSubmodelElements.RelationshipElement, "RelationshipElement" },
                { Aas.AasSubmodelElements.SubmodelElement, "SubmodelElement" },
                { Aas.AasSubmodelElements.SubmodelElementList, "SubmodelElementList" },
                { Aas.AasSubmodelElements.SubmodelElementCollection, "SubmodelElementCollection" }
            });

        /// <summary>
        /// Retrieve the string representation of <paramref name="that" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="that" /> is not a valid literal, return <c>null</c>.
        /// </remarks>
        public static string? ToString(Aas.AasSubmodelElements? that)
        {
            if (!that.HasValue)
            {
                return null;
            }
            else
            {
                if (AasSubmodelElementsToString.TryGetValue(that.Value, out string? value))
                {
                    return value;
                }
                else
                {
                    return null;
                }
            }
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        private static readonly Dictionary<string, Aas.AasSubmodelElements> _aasSubmodelElementsFromString = (
            new Dictionary<string, Aas.AasSubmodelElements>()
            {
                { "AnnotatedRelationshipElement", Aas.AasSubmodelElements.AnnotatedRelationshipElement },
                { "BasicEventElement", Aas.AasSubmodelElements.BasicEventElement },
                { "Blob", Aas.AasSubmodelElements.Blob },
                { "Capability", Aas.AasSubmodelElements.Capability },
                { "DataElement", Aas.AasSubmodelElements.DataElement },
                { "Entity", Aas.AasSubmodelElements.Entity },
                { "EventElement", Aas.AasSubmodelElements.EventElement },
                { "File", Aas.AasSubmodelElements.File },
                { "MultiLanguageProperty", Aas.AasSubmodelElements.MultiLanguageProperty },
                { "Operation", Aas.AasSubmodelElements.Operation },
                { "Property", Aas.AasSubmodelElements.Property },
                { "Range", Aas.AasSubmodelElements.Range },
                { "ReferenceElement", Aas.AasSubmodelElements.ReferenceElement },
                { "RelationshipElement", Aas.AasSubmodelElements.RelationshipElement },
                { "SubmodelElement", Aas.AasSubmodelElements.SubmodelElement },
                { "SubmodelElementList", Aas.AasSubmodelElements.SubmodelElementList },
                { "SubmodelElementCollection", Aas.AasSubmodelElements.SubmodelElementCollection }
            });

        /// <summary>
        /// Parse the string representation of <see cref="AasSubmodelElements" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="text" /> is not a valid string representation
        /// of a literal of <see cref="AasSubmodelElements" />,
        /// return <c>null</c>.
        /// </remarks>
        public static Aas.AasSubmodelElements? AasSubmodelElementsFromString(string text)
        {
            if (_aasSubmodelElementsFromString.TryGetValue(text, out AasSubmodelElements value))
            {
                return value;
            }
            else
            {
                return null;
            }
        }

        private static readonly Dictionary<Aas.EntityType, string> EntityTypeToString = (
            new Dictionary<Aas.EntityType, string>()
            {
                { Aas.EntityType.CoManagedEntity, "CoManagedEntity" },
                { Aas.EntityType.SelfManagedEntity, "SelfManagedEntity" }
            });

        /// <summary>
        /// Retrieve the string representation of <paramref name="that" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="that" /> is not a valid literal, return <c>null</c>.
        /// </remarks>
        public static string? ToString(Aas.EntityType? that)
        {
            if (!that.HasValue)
            {
                return null;
            }
            else
            {
                if (EntityTypeToString.TryGetValue(that.Value, out string? value))
                {
                    return value;
                }
                else
                {
                    return null;
                }
            }
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        private static readonly Dictionary<string, Aas.EntityType> _entityTypeFromString = (
            new Dictionary<string, Aas.EntityType>()
            {
                { "CoManagedEntity", Aas.EntityType.CoManagedEntity },
                { "SelfManagedEntity", Aas.EntityType.SelfManagedEntity }
            });

        /// <summary>
        /// Parse the string representation of <see cref="EntityType" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="text" /> is not a valid string representation
        /// of a literal of <see cref="EntityType" />,
        /// return <c>null</c>.
        /// </remarks>
        public static Aas.EntityType? EntityTypeFromString(string text)
        {
            if (_entityTypeFromString.TryGetValue(text, out EntityType value))
            {
                return value;
            }
            else
            {
                return null;
            }
        }

        private static readonly Dictionary<Aas.Direction, string> DirectionToString = (
            new Dictionary<Aas.Direction, string>()
            {
                { Aas.Direction.Input, "input" },
                { Aas.Direction.Output, "output" }
            });

        /// <summary>
        /// Retrieve the string representation of <paramref name="that" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="that" /> is not a valid literal, return <c>null</c>.
        /// </remarks>
        public static string? ToString(Aas.Direction? that)
        {
            if (!that.HasValue)
            {
                return null;
            }
            else
            {
                if (DirectionToString.TryGetValue(that.Value, out string? value))
                {
                    return value;
                }
                else
                {
                    return null;
                }
            }
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        private static readonly Dictionary<string, Aas.Direction> _directionFromString = (
            new Dictionary<string, Aas.Direction>()
            {
                { "input", Aas.Direction.Input },
                { "output", Aas.Direction.Output }
            });

        /// <summary>
        /// Parse the string representation of <see cref="Direction" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="text" /> is not a valid string representation
        /// of a literal of <see cref="Direction" />,
        /// return <c>null</c>.
        /// </remarks>
        public static Aas.Direction? DirectionFromString(string text)
        {
            if (_directionFromString.TryGetValue(text, out Direction value))
            {
                return value;
            }
            else
            {
                return null;
            }
        }

        private static readonly Dictionary<Aas.StateOfEvent, string> StateOfEventToString = (
            new Dictionary<Aas.StateOfEvent, string>()
            {
                { Aas.StateOfEvent.On, "on" },
                { Aas.StateOfEvent.Off, "off" }
            });

        /// <summary>
        /// Retrieve the string representation of <paramref name="that" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="that" /> is not a valid literal, return <c>null</c>.
        /// </remarks>
        public static string? ToString(Aas.StateOfEvent? that)
        {
            if (!that.HasValue)
            {
                return null;
            }
            else
            {
                if (StateOfEventToString.TryGetValue(that.Value, out string? value))
                {
                    return value;
                }
                else
                {
                    return null;
                }
            }
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        private static readonly Dictionary<string, Aas.StateOfEvent> _stateOfEventFromString = (
            new Dictionary<string, Aas.StateOfEvent>()
            {
                { "on", Aas.StateOfEvent.On },
                { "off", Aas.StateOfEvent.Off }
            });

        /// <summary>
        /// Parse the string representation of <see cref="StateOfEvent" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="text" /> is not a valid string representation
        /// of a literal of <see cref="StateOfEvent" />,
        /// return <c>null</c>.
        /// </remarks>
        public static Aas.StateOfEvent? StateOfEventFromString(string text)
        {
            if (_stateOfEventFromString.TryGetValue(text, out StateOfEvent value))
            {
                return value;
            }
            else
            {
                return null;
            }
        }

        private static readonly Dictionary<Aas.ReferenceTypes, string> ReferenceTypesToString = (
            new Dictionary<Aas.ReferenceTypes, string>()
            {
                { Aas.ReferenceTypes.GlobalReference, "GlobalReference" },
                { Aas.ReferenceTypes.ModelReference, "ModelReference" }
            });

        /// <summary>
        /// Retrieve the string representation of <paramref name="that" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="that" /> is not a valid literal, return <c>null</c>.
        /// </remarks>
        public static string? ToString(Aas.ReferenceTypes? that)
        {
            if (!that.HasValue)
            {
                return null;
            }
            else
            {
                if (ReferenceTypesToString.TryGetValue(that.Value, out string? value))
                {
                    return value;
                }
                else
                {
                    return null;
                }
            }
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        private static readonly Dictionary<string, Aas.ReferenceTypes> _referenceTypesFromString = (
            new Dictionary<string, Aas.ReferenceTypes>()
            {
                { "GlobalReference", Aas.ReferenceTypes.GlobalReference },
                { "ModelReference", Aas.ReferenceTypes.ModelReference }
            });

        /// <summary>
        /// Parse the string representation of <see cref="ReferenceTypes" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="text" /> is not a valid string representation
        /// of a literal of <see cref="ReferenceTypes" />,
        /// return <c>null</c>.
        /// </remarks>
        public static Aas.ReferenceTypes? ReferenceTypesFromString(string text)
        {
            if (_referenceTypesFromString.TryGetValue(text, out ReferenceTypes value))
            {
                return value;
            }
            else
            {
                return null;
            }
        }

        private static readonly Dictionary<Aas.KeyTypes, string> KeyTypesToString = (
            new Dictionary<Aas.KeyTypes, string>()
            {
                { Aas.KeyTypes.FragmentReference, "FragmentReference" },
                { Aas.KeyTypes.GlobalReference, "GlobalReference" },
                { Aas.KeyTypes.AnnotatedRelationshipElement, "AnnotatedRelationshipElement" },
                { Aas.KeyTypes.AssetAdministrationShell, "AssetAdministrationShell" },
                { Aas.KeyTypes.BasicEventElement, "BasicEventElement" },
                { Aas.KeyTypes.Blob, "Blob" },
                { Aas.KeyTypes.Capability, "Capability" },
                { Aas.KeyTypes.ConceptDescription, "ConceptDescription" },
                { Aas.KeyTypes.Identifiable, "Identifiable" },
                { Aas.KeyTypes.DataElement, "DataElement" },
                { Aas.KeyTypes.Entity, "Entity" },
                { Aas.KeyTypes.EventElement, "EventElement" },
                { Aas.KeyTypes.File, "File" },
                { Aas.KeyTypes.MultiLanguageProperty, "MultiLanguageProperty" },
                { Aas.KeyTypes.Operation, "Operation" },
                { Aas.KeyTypes.Property, "Property" },
                { Aas.KeyTypes.Range, "Range" },
                { Aas.KeyTypes.ReferenceElement, "ReferenceElement" },
                { Aas.KeyTypes.Referable, "Referable" },
                { Aas.KeyTypes.RelationshipElement, "RelationshipElement" },
                { Aas.KeyTypes.Submodel, "Submodel" },
                { Aas.KeyTypes.SubmodelElement, "SubmodelElement" },
                { Aas.KeyTypes.SubmodelElementList, "SubmodelElementList" },
                { Aas.KeyTypes.SubmodelElementCollection, "SubmodelElementCollection" }
            });

        /// <summary>
        /// Retrieve the string representation of <paramref name="that" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="that" /> is not a valid literal, return <c>null</c>.
        /// </remarks>
        public static string? ToString(Aas.KeyTypes? that)
        {
            if (!that.HasValue)
            {
                return null;
            }
            else
            {
                if (KeyTypesToString.TryGetValue(that.Value, out string? value))
                {
                    return value;
                }
                else
                {
                    return null;
                }
            }
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        private static readonly Dictionary<string, Aas.KeyTypes> _keyTypesFromString = (
            new Dictionary<string, Aas.KeyTypes>()
            {
                { "FragmentReference", Aas.KeyTypes.FragmentReference },
                { "GlobalReference", Aas.KeyTypes.GlobalReference },
                { "AnnotatedRelationshipElement", Aas.KeyTypes.AnnotatedRelationshipElement },
                { "AssetAdministrationShell", Aas.KeyTypes.AssetAdministrationShell },
                { "BasicEventElement", Aas.KeyTypes.BasicEventElement },
                { "Blob", Aas.KeyTypes.Blob },
                { "Capability", Aas.KeyTypes.Capability },
                { "ConceptDescription", Aas.KeyTypes.ConceptDescription },
                { "Identifiable", Aas.KeyTypes.Identifiable },
                { "DataElement", Aas.KeyTypes.DataElement },
                { "Entity", Aas.KeyTypes.Entity },
                { "EventElement", Aas.KeyTypes.EventElement },
                { "File", Aas.KeyTypes.File },
                { "MultiLanguageProperty", Aas.KeyTypes.MultiLanguageProperty },
                { "Operation", Aas.KeyTypes.Operation },
                { "Property", Aas.KeyTypes.Property },
                { "Range", Aas.KeyTypes.Range },
                { "ReferenceElement", Aas.KeyTypes.ReferenceElement },
                { "Referable", Aas.KeyTypes.Referable },
                { "RelationshipElement", Aas.KeyTypes.RelationshipElement },
                { "Submodel", Aas.KeyTypes.Submodel },
                { "SubmodelElement", Aas.KeyTypes.SubmodelElement },
                { "SubmodelElementList", Aas.KeyTypes.SubmodelElementList },
                { "SubmodelElementCollection", Aas.KeyTypes.SubmodelElementCollection }
            });

        /// <summary>
        /// Parse the string representation of <see cref="KeyTypes" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="text" /> is not a valid string representation
        /// of a literal of <see cref="KeyTypes" />,
        /// return <c>null</c>.
        /// </remarks>
        public static Aas.KeyTypes? KeyTypesFromString(string text)
        {
            if (_keyTypesFromString.TryGetValue(text, out KeyTypes value))
            {
                return value;
            }
            else
            {
                return null;
            }
        }

        private static readonly Dictionary<Aas.DataTypeDefXsd, string> DataTypeDefXsdToString = (
            new Dictionary<Aas.DataTypeDefXsd, string>()
            {
                { Aas.DataTypeDefXsd.AnyUri, "xs:anyURI" },
                { Aas.DataTypeDefXsd.Base64Binary, "xs:base64Binary" },
                { Aas.DataTypeDefXsd.Boolean, "xs:boolean" },
                { Aas.DataTypeDefXsd.Date, "xs:date" },
                { Aas.DataTypeDefXsd.DateTime, "xs:dateTime" },
                { Aas.DataTypeDefXsd.DateTimeStamp, "xs:dateTimeStamp" },
                { Aas.DataTypeDefXsd.Decimal, "xs:decimal" },
                { Aas.DataTypeDefXsd.Double, "xs:double" },
                { Aas.DataTypeDefXsd.Duration, "xs:duration" },
                { Aas.DataTypeDefXsd.Float, "xs:float" },
                { Aas.DataTypeDefXsd.GDay, "xs:gDay" },
                { Aas.DataTypeDefXsd.GMonth, "xs:gMonth" },
                { Aas.DataTypeDefXsd.GMonthDay, "xs:gMonthDay" },
                { Aas.DataTypeDefXsd.GYear, "xs:gYear" },
                { Aas.DataTypeDefXsd.GYearMonth, "xs:gYearMonth" },
                { Aas.DataTypeDefXsd.HexBinary, "xs:hexBinary" },
                { Aas.DataTypeDefXsd.String, "xs:string" },
                { Aas.DataTypeDefXsd.Time, "xs:time" },
                { Aas.DataTypeDefXsd.DayTimeDuration, "xs:dayTimeDuration" },
                { Aas.DataTypeDefXsd.YearMonthDuration, "xs:yearMonthDuration" },
                { Aas.DataTypeDefXsd.Integer, "xs:integer" },
                { Aas.DataTypeDefXsd.Long, "xs:long" },
                { Aas.DataTypeDefXsd.Int, "xs:int" },
                { Aas.DataTypeDefXsd.Short, "xs:short" },
                { Aas.DataTypeDefXsd.Byte, "xs:byte" },
                { Aas.DataTypeDefXsd.NonNegativeInteger, "xs:nonNegativeInteger" },
                { Aas.DataTypeDefXsd.PositiveInteger, "xs:positiveInteger" },
                { Aas.DataTypeDefXsd.UnsignedLong, "xs:unsignedLong" },
                { Aas.DataTypeDefXsd.UnsignedInt, "xs:unsignedInt" },
                { Aas.DataTypeDefXsd.UnsignedShort, "xs:unsignedShort" },
                { Aas.DataTypeDefXsd.UnsignedByte, "xs:unsignedByte" },
                { Aas.DataTypeDefXsd.NonPositiveInteger, "xs:nonPositiveInteger" },
                { Aas.DataTypeDefXsd.NegativeInteger, "xs:negativeInteger" }
            });

        /// <summary>
        /// Retrieve the string representation of <paramref name="that" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="that" /> is not a valid literal, return <c>null</c>.
        /// </remarks>
        public static string? ToString(Aas.DataTypeDefXsd? that)
        {
            if (!that.HasValue)
            {
                return null;
            }
            else
            {
                if (DataTypeDefXsdToString.TryGetValue(that.Value, out string? value))
                {
                    return value;
                }
                else
                {
                    return null;
                }
            }
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        private static readonly Dictionary<string, Aas.DataTypeDefXsd> _dataTypeDefXsdFromString = (
            new Dictionary<string, Aas.DataTypeDefXsd>()
            {
                { "xs:anyURI", Aas.DataTypeDefXsd.AnyUri },
                { "xs:base64Binary", Aas.DataTypeDefXsd.Base64Binary },
                { "xs:boolean", Aas.DataTypeDefXsd.Boolean },
                { "xs:date", Aas.DataTypeDefXsd.Date },
                { "xs:dateTime", Aas.DataTypeDefXsd.DateTime },
                { "xs:dateTimeStamp", Aas.DataTypeDefXsd.DateTimeStamp },
                { "xs:decimal", Aas.DataTypeDefXsd.Decimal },
                { "xs:double", Aas.DataTypeDefXsd.Double },
                { "xs:duration", Aas.DataTypeDefXsd.Duration },
                { "xs:float", Aas.DataTypeDefXsd.Float },
                { "xs:gDay", Aas.DataTypeDefXsd.GDay },
                { "xs:gMonth", Aas.DataTypeDefXsd.GMonth },
                { "xs:gMonthDay", Aas.DataTypeDefXsd.GMonthDay },
                { "xs:gYear", Aas.DataTypeDefXsd.GYear },
                { "xs:gYearMonth", Aas.DataTypeDefXsd.GYearMonth },
                { "xs:hexBinary", Aas.DataTypeDefXsd.HexBinary },
                { "xs:string", Aas.DataTypeDefXsd.String },
                { "xs:time", Aas.DataTypeDefXsd.Time },
                { "xs:dayTimeDuration", Aas.DataTypeDefXsd.DayTimeDuration },
                { "xs:yearMonthDuration", Aas.DataTypeDefXsd.YearMonthDuration },
                { "xs:integer", Aas.DataTypeDefXsd.Integer },
                { "xs:long", Aas.DataTypeDefXsd.Long },
                { "xs:int", Aas.DataTypeDefXsd.Int },
                { "xs:short", Aas.DataTypeDefXsd.Short },
                { "xs:byte", Aas.DataTypeDefXsd.Byte },
                { "xs:nonNegativeInteger", Aas.DataTypeDefXsd.NonNegativeInteger },
                { "xs:positiveInteger", Aas.DataTypeDefXsd.PositiveInteger },
                { "xs:unsignedLong", Aas.DataTypeDefXsd.UnsignedLong },
                { "xs:unsignedInt", Aas.DataTypeDefXsd.UnsignedInt },
                { "xs:unsignedShort", Aas.DataTypeDefXsd.UnsignedShort },
                { "xs:unsignedByte", Aas.DataTypeDefXsd.UnsignedByte },
                { "xs:nonPositiveInteger", Aas.DataTypeDefXsd.NonPositiveInteger },
                { "xs:negativeInteger", Aas.DataTypeDefXsd.NegativeInteger }
            });

        /// <summary>
        /// Parse the string representation of <see cref="DataTypeDefXsd" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="text" /> is not a valid string representation
        /// of a literal of <see cref="DataTypeDefXsd" />,
        /// return <c>null</c>.
        /// </remarks>
        public static Aas.DataTypeDefXsd? DataTypeDefXsdFromString(string text)
        {
            if (_dataTypeDefXsdFromString.TryGetValue(text, out DataTypeDefXsd value))
            {
                return value;
            }
            else
            {
                return null;
            }
        }

        private static readonly Dictionary<Aas.DataTypeIec61360, string> DataTypeIec61360ToString = (
            new Dictionary<Aas.DataTypeIec61360, string>()
            {
                { Aas.DataTypeIec61360.Date, "DATE" },
                { Aas.DataTypeIec61360.String, "STRING" },
                { Aas.DataTypeIec61360.StringTranslatable, "STRING_TRANSLATABLE" },
                { Aas.DataTypeIec61360.IntegerMeasure, "INTEGER_MEASURE" },
                { Aas.DataTypeIec61360.IntegerCount, "INTEGER_COUNT" },
                { Aas.DataTypeIec61360.IntegerCurrency, "INTEGER_CURRENCY" },
                { Aas.DataTypeIec61360.RealMeasure, "REAL_MEASURE" },
                { Aas.DataTypeIec61360.RealCount, "REAL_COUNT" },
                { Aas.DataTypeIec61360.RealCurrency, "REAL_CURRENCY" },
                { Aas.DataTypeIec61360.Boolean, "BOOLEAN" },
                { Aas.DataTypeIec61360.Iri, "IRI" },
                { Aas.DataTypeIec61360.Irdi, "IRDI" },
                { Aas.DataTypeIec61360.Rational, "RATIONAL" },
                { Aas.DataTypeIec61360.RationalMeasure, "RATIONAL_MEASURE" },
                { Aas.DataTypeIec61360.Time, "TIME" },
                { Aas.DataTypeIec61360.Timestamp, "TIMESTAMP" },
                { Aas.DataTypeIec61360.File, "FILE" },
                { Aas.DataTypeIec61360.Html, "HTML" },
                { Aas.DataTypeIec61360.Blob, "BLOB" }
            });

        /// <summary>
        /// Retrieve the string representation of <paramref name="that" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="that" /> is not a valid literal, return <c>null</c>.
        /// </remarks>
        public static string? ToString(Aas.DataTypeIec61360? that)
        {
            if (!that.HasValue)
            {
                return null;
            }
            else
            {
                if (DataTypeIec61360ToString.TryGetValue(that.Value, out string? value))
                {
                    return value;
                }
                else
                {
                    return null;
                }
            }
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        private static readonly Dictionary<string, Aas.DataTypeIec61360> _dataTypeIec61360FromString = (
            new Dictionary<string, Aas.DataTypeIec61360>()
            {
                { "DATE", Aas.DataTypeIec61360.Date },
                { "STRING", Aas.DataTypeIec61360.String },
                { "STRING_TRANSLATABLE", Aas.DataTypeIec61360.StringTranslatable },
                { "INTEGER_MEASURE", Aas.DataTypeIec61360.IntegerMeasure },
                { "INTEGER_COUNT", Aas.DataTypeIec61360.IntegerCount },
                { "INTEGER_CURRENCY", Aas.DataTypeIec61360.IntegerCurrency },
                { "REAL_MEASURE", Aas.DataTypeIec61360.RealMeasure },
                { "REAL_COUNT", Aas.DataTypeIec61360.RealCount },
                { "REAL_CURRENCY", Aas.DataTypeIec61360.RealCurrency },
                { "BOOLEAN", Aas.DataTypeIec61360.Boolean },
                { "IRI", Aas.DataTypeIec61360.Iri },
                { "IRDI", Aas.DataTypeIec61360.Irdi },
                { "RATIONAL", Aas.DataTypeIec61360.Rational },
                { "RATIONAL_MEASURE", Aas.DataTypeIec61360.RationalMeasure },
                { "TIME", Aas.DataTypeIec61360.Time },
                { "TIMESTAMP", Aas.DataTypeIec61360.Timestamp },
                { "FILE", Aas.DataTypeIec61360.File },
                { "HTML", Aas.DataTypeIec61360.Html },
                { "BLOB", Aas.DataTypeIec61360.Blob }
            });

        /// <summary>
        /// Parse the string representation of <see cref="DataTypeIec61360" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="text" /> is not a valid string representation
        /// of a literal of <see cref="DataTypeIec61360" />,
        /// return <c>null</c>.
        /// </remarks>
        public static Aas.DataTypeIec61360? DataTypeIec61360FromString(string text)
        {
            if (_dataTypeIec61360FromString.TryGetValue(text, out DataTypeIec61360 value))
            {
                return value;
            }
            else
            {
                return null;
            }
        }

        private static readonly Dictionary<Aas.LevelType, string> LevelTypeToString = (
            new Dictionary<Aas.LevelType, string>()
            {
                { Aas.LevelType.Min, "Min" },
                { Aas.LevelType.Max, "Max" },
                { Aas.LevelType.Nom, "Nom" },
                { Aas.LevelType.Typ, "Typ" }
            });

        /// <summary>
        /// Retrieve the string representation of <paramref name="that" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="that" /> is not a valid literal, return <c>null</c>.
        /// </remarks>
        public static string? ToString(Aas.LevelType? that)
        {
            if (!that.HasValue)
            {
                return null;
            }
            else
            {
                if (LevelTypeToString.TryGetValue(that.Value, out string? value))
                {
                    return value;
                }
                else
                {
                    return null;
                }
            }
        }

        [CodeAnalysis.SuppressMessage("ReSharper", "InconsistentNaming")]
        private static readonly Dictionary<string, Aas.LevelType> _levelTypeFromString = (
            new Dictionary<string, Aas.LevelType>()
            {
                { "Min", Aas.LevelType.Min },
                { "Max", Aas.LevelType.Max },
                { "Nom", Aas.LevelType.Nom },
                { "Typ", Aas.LevelType.Typ }
            });

        /// <summary>
        /// Parse the string representation of <see cref="LevelType" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="text" /> is not a valid string representation
        /// of a literal of <see cref="LevelType" />,
        /// return <c>null</c>.
        /// </remarks>
        public static Aas.LevelType? LevelTypeFromString(string text)
        {
            if (_levelTypeFromString.TryGetValue(text, out LevelType value))
            {
                return value;
            }
            else
            {
                return null;
            }
        }
    }  // public static class Stringification
}  // namespace AasCore.Aas3_0_RC02

/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */
