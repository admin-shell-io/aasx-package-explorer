/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */
using AdminShellNS.DiaryData;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;  // can't alias
using Aas = AasCore.Aas3_0;  // renamed
using EnumMemberAttribute = System.Runtime.Serialization.EnumMemberAttribute;

namespace AasCore.Aas3_0
{
    /// <summary>
    /// Represent a general class of an AAS model.
    /// </summary>
    public interface IClass
    {
        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce();

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend();

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor);

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context);

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer);

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context);
    }

    /// <summary>
    /// Element that can have a semantic definition plus some supplemental semantic
    /// definitions.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Constraint AASd-118:
    ///     If there are ID <see cref="Aas.IHasSemantics.SupplementalSemanticIds" /> defined
    ///     then there shall be also a main semantic ID <see cref="Aas.IHasSemantics.SemanticId" />.
    ///   </li>
    /// </ul>
    /// </remarks>
    public interface IHasSemantics : IClass
    {
        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<IReference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IReference> OverSupplementalSemanticIdsOrEmpty();
    }

    /// <summary>
    /// Single extension of an element.
    /// </summary>
    public interface IExtension : IHasSemantics
    {
        /// <summary>
        /// Name of the extension.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Constraints:
        /// </para>
        /// <ul>
        ///   <li>
        ///     Constraint AASd-077:
        ///     The name of an extension (Extension/name) within <see cref="Aas.IHasExtensions" /> needs
        ///     to be unique.
        ///   </li>
        /// </ul>
        /// </remarks>
        public string Name { get; set; }

        /// <summary>
        /// Type of the value of the extension.
        /// </summary>
        /// <remarks>
        /// Default: <see cref="Aas.DataTypeDefXsd.String" />
        /// </remarks>
        public DataTypeDefXsd? ValueType { get; set; }

        /// <summary>
        /// Value of the extension
        /// </summary>
        public string? Value { get; set; }

        /// <summary>
        /// Reference to an element the extension refers to.
        /// </summary>
        public List<IReference>? RefersTo { get; set; }

        public DataTypeDefXsd ValueTypeOrDefault();

        /// <summary>
        /// Iterate over RefersTo, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IReference> OverRefersToOrEmpty();
    }

    /// <summary>
    /// Single extension of an element.
    /// </summary>
    public class Extension : IExtension
    {
        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<IReference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Name of the extension.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Constraints:
        /// </para>
        /// <ul>
        ///   <li>
        ///     Constraint AASd-077:
        ///     The name of an extension (Extension/name) within <see cref="Aas.IHasExtensions" /> needs
        ///     to be unique.
        ///   </li>
        /// </ul>
        /// </remarks>
        public string Name { get; set; }

        /// <summary>
        /// Type of the value of the extension.
        /// </summary>
        /// <remarks>
        /// Default: <see cref="Aas.DataTypeDefXsd.String" />
        /// </remarks>
        public DataTypeDefXsd? ValueType { get; set; }

        /// <summary>
        /// Value of the extension
        /// </summary>
        public string? Value { get; set; }

        /// <summary>
        /// Reference to an element the extension refers to.
        /// </summary>
        public List<IReference>? RefersTo { get; set; }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IReference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<IReference>();
        }

        /// <summary>
        /// Iterate over RefersTo, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IReference> OverRefersToOrEmpty()
        {
            return RefersTo
                ?? System.Linq.Enumerable.Empty<IReference>();
        }

        /// <summary>
        /// Return the <see cref="Extension.ValueType" /> or the default value
        /// if it has not been set.
        /// </summary>
        public DataTypeDefXsd ValueTypeOrDefault()
        {
            return ValueType ?? DataTypeDefXsd.String;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (RefersTo != null)
            {
                foreach (var anItem in RefersTo)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (RefersTo != null)
            {
                foreach (var anItem in RefersTo)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitExtension(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitExtension(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformExtension(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformExtension(this, context);
        }

        public Extension(
            string name,
            IReference? semanticId = null,
            List<IReference>? supplementalSemanticIds = null,
            DataTypeDefXsd? valueType = null,
            string? value = null,
            List<IReference>? refersTo = null)
        {
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Name = name;
            ValueType = valueType;
            Value = value;
            RefersTo = refersTo;
        }
    }

    /// <summary>
    /// Element that can be extended by proprietary extensions.
    /// </summary>
    /// <remarks>
    /// Extensions are proprietary, i.e. they do not support global interoperability.
    /// </remarks>
    public interface IHasExtensions : IClass
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<IExtension>? Extensions { get; set; }

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IExtension> OverExtensionsOrEmpty();
    }

    /// <summary>
    /// An element that is referable by its <see cref="Aas.IReferable.IdShort" />.
    /// </summary>
    /// <remarks>
    /// This ID is not globally unique.
    /// This ID is unique within the name space of the element.
    /// </remarks>
    public interface IReferable : IHasExtensions, IDiaryData
    {
        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        public List<ILangStringNameType>? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The description can be provided in several languages.
        /// </para>
        /// <para>
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        /// </para>
        /// <para>
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </para>
        /// </remarks>
        public List<ILangStringTextType>? Description { get; set; }

        #region Parent
        [JsonIgnore]
        public IClass Parent { get; set; }
        #endregion

        #region TimeStamp
        [JsonIgnore]
        public DateTime TimeStampCreate { get; set; }
        [JsonIgnore]
        public DateTime TimeStamp { get; set; }
        [JsonIgnore]
        public DateTime TimeStampTree { get; set; }

        #endregion

        /// <summary>
        /// Iterate over DisplayName, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringNameType> OverDisplayNameOrEmpty();

        /// <summary>
        /// Iterate over Description, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringTextType> OverDescriptionOrEmpty();
    }

    /// <summary>
    /// An element that has a globally unique identifier.
    /// </summary>
    public interface IIdentifiable : IReferable
    {
        /// <summary>
        /// Administrative information of an identifiable element.
        /// </summary>
        /// <remarks>
        /// Some of the administrative information like the version number might need to
        /// be part of the identification.
        /// </remarks>
        public IAdministrativeInformation? Administration { get; set; }

        /// <summary>
        /// The globally unique identification of the element.
        /// </summary>
        public string Id { get; set; }
    }

    /// <summary>
    /// Enumeration for denoting whether an element is a template or an instance.
    /// </summary>
    public enum ModellingKind
    {
        /// <summary>
        /// Specification of the common features of a structured element in sufficient detail
        /// that such a instance can be instantiated using it
        /// </summary>
        [EnumMember(Value = "Template")]
        Template,

        /// <summary>
        /// Concrete, clearly identifiable element instance. Its creation and validation
        /// may be guided by a corresponding element template.
        /// </summary>
        [EnumMember(Value = "Instance")]
        Instance
    }

    /// <summary>
    /// An element with a kind is an element that can either represent a template or an
    /// instance.
    /// </summary>
    /// <remarks>
    /// Default for an element is that it is representing an instance.
    /// </remarks>
    public interface IHasKind : IClass
    {
        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default: <see cref="Aas.ModellingKind.Instance" />
        /// </remarks>
        public ModellingKind? Kind { get; set; }

        public ModellingKind KindOrDefault();
    }

    /// <summary>
    /// Element that can be extended by using data specification templates.
    /// </summary>
    /// <remarks>
    /// A data specification template defines a named set of additional attributes an
    /// element may or shall have. The data specifications used are explicitly specified
    /// with their global ID.
    /// </remarks>
    public interface IHasDataSpecification : IClass
    {
        /// <summary>
        /// Embedded data specification.
        /// </summary>
        public List<IEmbeddedDataSpecification>? EmbeddedDataSpecifications { get; set; }

        /// <summary>
        /// Iterate over EmbeddedDataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IEmbeddedDataSpecification> OverEmbeddedDataSpecificationsOrEmpty();
    }

    /// <summary>
    /// Administrative meta-information for an element like version
    /// information.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Constraint AASd-005:
    ///     If <see cref="Aas.AdministrativeInformation.Version" /> is not specified then also <see cref="Aas.AdministrativeInformation.Revision" /> shall be
    ///     unspecified. This means, a revision requires a version. If there is no version
    ///     there is no revision neither. Revision is optional.
    ///   </li>
    /// </ul>
    /// </remarks>
    public interface IAdministrativeInformation : IHasDataSpecification
    {
        /// <summary>
        /// Version of the element.
        /// </summary>
        public string? Version { get; set; }

        /// <summary>
        /// Revision of the element.
        /// </summary>
        public string? Revision { get; set; }

        /// <summary>
        /// The subject ID of the subject responsible for making the element.
        /// </summary>
        public IReference? Creator { get; set; }

        /// <summary>
        /// Identifier of the template that guided the creation of the element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// In case of a submodel the <see cref="Aas.AdministrativeInformation.TemplateId" /> is the identifier
        /// of the submodel template ID that guided the creation of the submodel
        /// </para>
        /// <para>
        /// The <see cref="Aas.AdministrativeInformation.TemplateId" /> is not relevant for validation in Submodels.
        /// For validation the <see cref="Aas.Submodel.SemanticId" /> shall be used.
        /// </para>
        /// <para>
        /// Usage of <see cref="Aas.AdministrativeInformation.TemplateId" /> is not restricted to submodel instances. So also
        /// the creation of submodel templates can be guided by another submodel template.
        /// </para>
        /// </remarks>
        public string? TemplateId { get; set; }
    }

    /// <summary>
    /// Administrative meta-information for an element like version
    /// information.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Constraint AASd-005:
    ///     If <see cref="Aas.AdministrativeInformation.Version" /> is not specified then also <see cref="Aas.AdministrativeInformation.Revision" /> shall be
    ///     unspecified. This means, a revision requires a version. If there is no version
    ///     there is no revision neither. Revision is optional.
    ///   </li>
    /// </ul>
    /// </remarks>
    public class AdministrativeInformation : IAdministrativeInformation
    {
        /// <summary>
        /// Embedded data specification.
        /// </summary>
        public List<IEmbeddedDataSpecification>? EmbeddedDataSpecifications { get; set; }

        /// <summary>
        /// Version of the element.
        /// </summary>
        public string? Version { get; set; }

        /// <summary>
        /// Revision of the element.
        /// </summary>
        public string? Revision { get; set; }

        /// <summary>
        /// The subject ID of the subject responsible for making the element.
        /// </summary>
        public IReference? Creator { get; set; }

        /// <summary>
        /// Identifier of the template that guided the creation of the element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// In case of a submodel the <see cref="Aas.AdministrativeInformation.TemplateId" /> is the identifier
        /// of the submodel template ID that guided the creation of the submodel
        /// </para>
        /// <para>
        /// The <see cref="Aas.AdministrativeInformation.TemplateId" /> is not relevant for validation in Submodels.
        /// For validation the <see cref="Aas.Submodel.SemanticId" /> shall be used.
        /// </para>
        /// <para>
        /// Usage of <see cref="Aas.AdministrativeInformation.TemplateId" /> is not restricted to submodel instances. So also
        /// the creation of submodel templates can be guided by another submodel template.
        /// </para>
        /// </remarks>
        public string? TemplateId { get; set; }

        /// <summary>
        /// Iterate over EmbeddedDataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IEmbeddedDataSpecification> OverEmbeddedDataSpecificationsOrEmpty()
        {
            return EmbeddedDataSpecifications
                ?? System.Linq.Enumerable.Empty<IEmbeddedDataSpecification>();
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (Creator != null)
            {
                yield return Creator;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Creator != null)
            {
                yield return Creator;

                // Recurse
                foreach (var anItem in Creator.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitAdministrativeInformation(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitAdministrativeInformation(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformAdministrativeInformation(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformAdministrativeInformation(this, context);
        }

        public AdministrativeInformation(
            List<IEmbeddedDataSpecification>? embeddedDataSpecifications = null,
            string? version = null,
            string? revision = null,
            IReference? creator = null,
            string? templateId = null)
        {
            EmbeddedDataSpecifications = embeddedDataSpecifications;
            Version = version;
            Revision = revision;
            Creator = creator;
            TemplateId = templateId;
        }
    }

    /// <summary>
    /// The value of a qualifiable element may be further qualified by one or more
    /// qualifiers.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This constraint is checked at <see cref="Aas.Submodel" />.
    /// </para>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Constraint AASd-119:
    ///     If any <see cref="Aas.Qualifier.Kind" /> value of <see cref="Aas.IQualifiable.Qualifiers" /> is
    ///     equal to <see cref="Aas.QualifierKind.TemplateQualifier" /> and the qualified element
    ///     inherits from <see cref="Aas.IHasKind" /> then the qualified element shall be of
    ///     kind Template (<see cref="Aas.IHasKind.Kind" /> = <see cref="Aas.ModellingKind.Template" />).
    ///   </li>
    /// </ul>
    /// </remarks>
    public interface IQualifiable : IClass
    {
        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Constraints:
        /// </para>
        /// <ul>
        ///   <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///   </li>
        /// </ul>
        /// </remarks>
        public List<IQualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IQualifier> OverQualifiersOrEmpty();
    }

    /// <summary>
    /// Enumeration for kinds of qualifiers.
    /// </summary>
    /// <remarks>
    /// This element is experimental and therefore may be subject to change or may be
    /// removed completely in future versions of the meta-model.
    /// </remarks>
    public enum QualifierKind
    {
        /// <summary>
        /// qualifies the value of the element and can change during run-time.
        /// </summary>
        /// <remarks>
        /// Value qualifiers are only applicable to elements with kind
        /// <see cref="Aas.ModellingKind.Instance" />.
        /// </remarks>
        [EnumMember(Value = "ValueQualifier")]
        ValueQualifier,

        /// <summary>
        /// qualifies the semantic definition the element is referring to
        /// (<see cref="Aas.IHasSemantics.SemanticId" />)
        /// </summary>
        [EnumMember(Value = "ConceptQualifier")]
        ConceptQualifier,

        /// <summary>
        /// qualifies the elements within a specific submodel on concept level.
        /// </summary>
        /// <remarks>
        /// Template qualifiers are only applicable to elements with kind
        /// <see cref="Aas.ModellingKind.Template" />.
        /// </remarks>
        [EnumMember(Value = "TemplateQualifier")]
        TemplateQualifier
    }

    /// <summary>
    /// A qualifier is a type-value-pair that makes additional statements w.r.t. the value
    /// of the element.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Constraint AASd-006:
    ///     If both the <see cref="Aas.Qualifier.Value" /> and the <see cref="Aas.Qualifier.ValueId" /> of
    ///     a <see cref="Aas.Qualifier" /> are present then the <see cref="Aas.Qualifier.Value" /> needs
    ///     to be identical to the value of the referenced coded value
    ///     in <see cref="Aas.Qualifier.ValueId" />.
    ///   </li>
    ///   <li>
    ///     Constraint AASd-020:
    ///     The value of <see cref="Aas.Qualifier.Value" /> shall be consistent to the data type as
    ///     defined in <see cref="Aas.Qualifier.ValueType" />.
    ///   </li>
    /// </ul>
    /// </remarks>
    public interface IQualifier : IHasSemantics
    {
        /// <summary>
        /// The qualifier kind describes the kind of the qualifier that is applied to the
        /// element.
        /// </summary>
        /// <remarks>
        /// Default: <see cref="Aas.QualifierKind.ConceptQualifier" />
        /// </remarks>
        public QualifierKind? Kind { get; set; }

        /// <summary>
        /// The qualifier <em>type</em> describes the type of the qualifier that is applied to
        /// the element.
        /// </summary>
        public string Type { get; set; }

        /// <summary>
        /// Data type of the qualifier value.
        /// </summary>
        public DataTypeDefXsd ValueType { get; set; }

        /// <summary>
        /// The qualifier value is the value of the qualifier.
        /// </summary>
        public string? Value { get; set; }

        /// <summary>
        /// Reference to the global unique ID of a coded value.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? ValueId { get; set; }

        public QualifierKind KindOrDefault();
    }

    /// <summary>
    /// A qualifier is a type-value-pair that makes additional statements w.r.t. the value
    /// of the element.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Constraint AASd-006:
    ///     If both the <see cref="Aas.Qualifier.Value" /> and the <see cref="Aas.Qualifier.ValueId" /> of
    ///     a <see cref="Aas.Qualifier" /> are present then the <see cref="Aas.Qualifier.Value" /> needs
    ///     to be identical to the value of the referenced coded value
    ///     in <see cref="Aas.Qualifier.ValueId" />.
    ///   </li>
    ///   <li>
    ///     Constraint AASd-020:
    ///     The value of <see cref="Aas.Qualifier.Value" /> shall be consistent to the data type as
    ///     defined in <see cref="Aas.Qualifier.ValueType" />.
    ///   </li>
    /// </ul>
    /// </remarks>
    public class Qualifier : IQualifier
    {
        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<IReference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// The qualifier kind describes the kind of the qualifier that is applied to the
        /// element.
        /// </summary>
        /// <remarks>
        /// Default: <see cref="Aas.QualifierKind.ConceptQualifier" />
        /// </remarks>
        public QualifierKind? Kind { get; set; }

        /// <summary>
        /// The qualifier <em>type</em> describes the type of the qualifier that is applied to
        /// the element.
        /// </summary>
        public string Type { get; set; }

        /// <summary>
        /// Data type of the qualifier value.
        /// </summary>
        public DataTypeDefXsd ValueType { get; set; }

        /// <summary>
        /// The qualifier value is the value of the qualifier.
        /// </summary>
        public string? Value { get; set; }

        /// <summary>
        /// Reference to the global unique ID of a coded value.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? ValueId { get; set; }

        #region Parent
        [JsonIgnore]
        public IClass Parent { get; set; }
        #endregion

        #region TimeStamp
        [JsonIgnore]
        public DateTime TimeStampCreate { get; set; }
        [JsonIgnore]
        public DateTime TimeStamp { get; set; }
        [JsonIgnore]
        public DateTime TimeStampTree { get; set; }

        #endregion

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IReference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<IReference>();
        }

        /// <summary>
        /// Return the <see cref="Qualifier.Kind" /> or the default value
        /// if it has not been set.
        /// </summary>
        public QualifierKind KindOrDefault()
        {
            return Kind ?? QualifierKind.ConceptQualifier;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (ValueId != null)
            {
                yield return ValueId;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (ValueId != null)
            {
                yield return ValueId;

                // Recurse
                foreach (var anItem in ValueId.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitQualifier(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitQualifier(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformQualifier(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformQualifier(this, context);
        }

        public Qualifier(
            string type,
            DataTypeDefXsd valueType,
            IReference? semanticId = null,
            List<IReference>? supplementalSemanticIds = null,
            QualifierKind? kind = null,
            string? value = null,
            IReference? valueId = null)
        {
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Type = type;
            ValueType = valueType;
            Kind = kind;
            Value = value;
            ValueId = valueId;
        }
    }

    /// <summary>
    /// An asset administration shell.
    /// </summary>
    public interface IAssetAdministrationShell :
            IIdentifiable,
            IHasDataSpecification
    {
        /// <summary>
        /// The reference to the AAS the AAS was derived from.
        /// </summary>
        public IReference? DerivedFrom { get; set; }

        /// <summary>
        /// Meta-information about the asset the AAS is representing.
        /// </summary>
        public IAssetInformation AssetInformation { get; set; }

        /// <summary>
        /// References to submodels of the AAS.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A submodel is a description of an aspect of the asset the AAS is representing.
        /// </para>
        /// <para>
        /// The asset of an AAS is typically described by one or more submodels.
        /// </para>
        /// <para>
        /// Temporarily no submodel might be assigned to the AAS.
        /// </para>
        /// </remarks>
        public List<IReference>? Submodels { get; set; }

        /// <summary>
        /// Iterate over Submodels, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IReference> OverSubmodelsOrEmpty();
    }

    /// <summary>
    /// An asset administration shell.
    /// </summary>
    public class AssetAdministrationShell : IAssetAdministrationShell
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<IExtension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        public List<ILangStringNameType>? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The description can be provided in several languages.
        /// </para>
        /// <para>
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        /// </para>
        /// <para>
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </para>
        /// </remarks>
        public List<ILangStringTextType>? Description { get; set; }

        /// <summary>
        /// Administrative information of an identifiable element.
        /// </summary>
        /// <remarks>
        /// Some of the administrative information like the version number might need to
        /// be part of the identification.
        /// </remarks>
        public IAdministrativeInformation? Administration { get; set; }

        /// <summary>
        /// The globally unique identification of the element.
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Embedded data specification.
        /// </summary>
        public List<IEmbeddedDataSpecification>? EmbeddedDataSpecifications { get; set; }

        /// <summary>
        /// The reference to the AAS the AAS was derived from.
        /// </summary>
        public IReference? DerivedFrom { get; set; }

        /// <summary>
        /// Meta-information about the asset the AAS is representing.
        /// </summary>
        public IAssetInformation AssetInformation { get; set; }

        /// <summary>
        /// References to submodels of the AAS.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A submodel is a description of an aspect of the asset the AAS is representing.
        /// </para>
        /// <para>
        /// The asset of an AAS is typically described by one or more submodels.
        /// </para>
        /// <para>
        /// Temporarily no submodel might be assigned to the AAS.
        /// </para>
        /// </remarks>
        public List<IReference>? Submodels { get; set; }

        #region Parent
        [JsonIgnore]
        public IClass Parent { get; set; }
        #endregion

        #region TimeStamp
        [JsonIgnore]
        public DateTime TimeStampCreate { get; set; }
        [JsonIgnore]
        public DateTime TimeStamp { get; set; }
        [JsonIgnore]
        public DateTime TimeStampTree { get; set; }

        [JsonIgnore]
        private DiaryDataDef _diaryData = new DiaryDataDef();

        [JsonIgnore]
        public DiaryDataDef DiaryData { get { return _diaryData; } }

        #endregion

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IExtension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<IExtension>();
        }

        /// <summary>
        /// Iterate over DisplayName, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringNameType> OverDisplayNameOrEmpty()
        {
            return DisplayName
                ?? System.Linq.Enumerable.Empty<ILangStringNameType>();
        }

        /// <summary>
        /// Iterate over Description, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringTextType> OverDescriptionOrEmpty()
        {
            return Description
                ?? System.Linq.Enumerable.Empty<ILangStringTextType>();
        }

        /// <summary>
        /// Iterate over EmbeddedDataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IEmbeddedDataSpecification> OverEmbeddedDataSpecificationsOrEmpty()
        {
            return EmbeddedDataSpecifications
                ?? System.Linq.Enumerable.Empty<IEmbeddedDataSpecification>();
        }

        /// <summary>
        /// Iterate over Submodels, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IReference> OverSubmodelsOrEmpty()
        {
            return Submodels
                ?? System.Linq.Enumerable.Empty<IReference>();
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;
                }
            }

            if (Administration != null)
            {
                yield return Administration;
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (DerivedFrom != null)
            {
                yield return DerivedFrom;
            }

            yield return AssetInformation;

            if (Submodels != null)
            {
                foreach (var anItem in Submodels)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Administration != null)
            {
                yield return Administration;

                // Recurse
                foreach (var anItem in Administration.Descend())
                {
                    yield return anItem;
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DerivedFrom != null)
            {
                yield return DerivedFrom;

                // Recurse
                foreach (var anItem in DerivedFrom.Descend())
                {
                    yield return anItem;
                }
            }

            yield return AssetInformation;

            // Recurse
            foreach (var anItem in AssetInformation.Descend())
            {
                yield return anItem;
            }

            if (Submodels != null)
            {
                foreach (var anItem in Submodels)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitAssetAdministrationShell(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitAssetAdministrationShell(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformAssetAdministrationShell(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformAssetAdministrationShell(this, context);
        }

        public AssetAdministrationShell(
            string id,
            IAssetInformation assetInformation,
            List<IExtension>? extensions = null,
            string? category = null,
            string? idShort = null,
            List<ILangStringNameType>? displayName = null,
            List<ILangStringTextType>? description = null,
            IAdministrativeInformation? administration = null,
            List<IEmbeddedDataSpecification>? embeddedDataSpecifications = null,
            IReference? derivedFrom = null,
            List<IReference>? submodels = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Id = id;
            Administration = administration;
            EmbeddedDataSpecifications = embeddedDataSpecifications;
            DerivedFrom = derivedFrom;
            AssetInformation = assetInformation;
            Submodels = submodels;
        }
    }

    /// <summary>
    /// In <see cref="Aas.AssetInformation" /> identifying meta data of the asset that is
    /// represented by an AAS is defined.
    /// </summary>
    /// <remarks>
    /// <para>
    /// The asset may either represent an asset type or an asset instance.
    /// </para>
    /// <para>
    /// The asset has a globally unique identifier plus – if needed – additional domain
    /// specific (proprietary) identifiers. However, to support the corner case of very
    /// first phase of lifecycle where a stabilised/constant_set global asset identifier
    /// does not already exist, the corresponding attribute <see cref="Aas.AssetInformation.GlobalAssetId" /> is
    /// optional.
    /// </para>
    /// <para>
    /// Constraint AASd-116 is important to enable a generic search across global
    /// and specific asset IDs.
    /// </para>
    /// <para>
    /// <para>
    /// In the book, Constraint AASd-116 imposes a
    /// case-insensitive equality against <c>globalAssetId</c>. This is
    /// culturally-dependent, and depends on the system settings.
    /// For example, the case-folding for the letters "i" and "I" is
    /// different in Turkish from English.
    /// </para>
    /// <para>
    /// We implement the constraint as case-sensitive instead to allow
    /// for interoperability across different culture settings.
    /// </para>
    /// </para>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Constraint AASd-116:
    ///     <c>globalAssetId</c> is a reserved key. If used as value for
    ///     <see cref="Aas.SpecificAssetId.Name" /> then <see cref="Aas.SpecificAssetId.Value" /> shall be
    ///     identical to <see cref="Aas.AssetInformation.GlobalAssetId" />.
    ///   </li>
    ///   <li>
    ///     Constraint AASd-131:
    ///     For <see cref="Aas.AssetInformation" /> either the <see cref="Aas.AssetInformation.GlobalAssetId" /> shall be
    ///     defined or at least one item in <see cref="Aas.AssetInformation.SpecificAssetIds" />.
    ///   </li>
    /// </ul>
    /// </remarks>
    public interface IAssetInformation : IClass
    {
        /// <summary>
        /// Denotes whether the Asset is of kind <see cref="Aas.AssetKind.Type" /> or
        /// <see cref="Aas.AssetKind.Instance" />.
        /// </summary>
        public AssetKind AssetKind { get; set; }

        /// <summary>
        /// Global identifier of the asset the AAS is representing.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This attribute is required as soon as the AAS is exchanged via partners in the life
        /// cycle of the asset. In a first phase of the life cycle the asset might not yet have
        /// a global ID but already an internal identifier. The internal identifier would be
        /// modelled via <see cref="Aas.AssetInformation.SpecificAssetIds" />.
        /// </para>
        /// <para>
        /// This is a global reference.
        /// </para>
        /// </remarks>
        public string? GlobalAssetId { get; set; }

        /// <summary>
        /// Additional domain-specific, typically proprietary identifier for the asset like
        /// e.g., serial number etc.
        /// </summary>
        public List<ISpecificAssetId>? SpecificAssetIds { get; set; }

        /// <summary>
        /// In case <see cref="Aas.AssetInformation.AssetKind" /> is applicable the <see cref="Aas.AssetInformation.AssetType" /> is the asset ID
        /// of the type asset of the asset under consideration
        /// as identified by <see cref="Aas.AssetInformation.GlobalAssetId" />.
        /// </summary>
        /// <remarks>
        /// In case <see cref="Aas.AssetInformation.AssetKind" /> is "Instance" than the <see cref="Aas.AssetInformation.AssetType" /> denotes
        /// which "Type" the asset is of. But it is also possible
        /// to have an <see cref="Aas.AssetInformation.AssetType" /> of an asset of kind "Type".
        /// </remarks>
        public string? AssetType { get; set; }

        /// <summary>
        /// Thumbnail of the asset represented by the Asset Administration Shell.
        /// </summary>
        /// <remarks>
        /// Used as default.
        /// </remarks>
        public IResource? DefaultThumbnail { get; set; }

        /// <summary>
        /// Iterate over SpecificAssetIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ISpecificAssetId> OverSpecificAssetIdsOrEmpty();
    }

    /// <summary>
    /// In <see cref="Aas.AssetInformation" /> identifying meta data of the asset that is
    /// represented by an AAS is defined.
    /// </summary>
    /// <remarks>
    /// <para>
    /// The asset may either represent an asset type or an asset instance.
    /// </para>
    /// <para>
    /// The asset has a globally unique identifier plus – if needed – additional domain
    /// specific (proprietary) identifiers. However, to support the corner case of very
    /// first phase of lifecycle where a stabilised/constant_set global asset identifier
    /// does not already exist, the corresponding attribute <see cref="Aas.AssetInformation.GlobalAssetId" /> is
    /// optional.
    /// </para>
    /// <para>
    /// Constraint AASd-116 is important to enable a generic search across global
    /// and specific asset IDs.
    /// </para>
    /// <para>
    /// <para>
    /// In the book, Constraint AASd-116 imposes a
    /// case-insensitive equality against <c>globalAssetId</c>. This is
    /// culturally-dependent, and depends on the system settings.
    /// For example, the case-folding for the letters "i" and "I" is
    /// different in Turkish from English.
    /// </para>
    /// <para>
    /// We implement the constraint as case-sensitive instead to allow
    /// for interoperability across different culture settings.
    /// </para>
    /// </para>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Constraint AASd-116:
    ///     <c>globalAssetId</c> is a reserved key. If used as value for
    ///     <see cref="Aas.SpecificAssetId.Name" /> then <see cref="Aas.SpecificAssetId.Value" /> shall be
    ///     identical to <see cref="Aas.AssetInformation.GlobalAssetId" />.
    ///   </li>
    ///   <li>
    ///     Constraint AASd-131:
    ///     For <see cref="Aas.AssetInformation" /> either the <see cref="Aas.AssetInformation.GlobalAssetId" /> shall be
    ///     defined or at least one item in <see cref="Aas.AssetInformation.SpecificAssetIds" />.
    ///   </li>
    /// </ul>
    /// </remarks>
    public class AssetInformation : IAssetInformation
    {
        /// <summary>
        /// Denotes whether the Asset is of kind <see cref="Aas.AssetKind.Type" /> or
        /// <see cref="Aas.AssetKind.Instance" />.
        /// </summary>
        public AssetKind AssetKind { get; set; }

        /// <summary>
        /// Global identifier of the asset the AAS is representing.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This attribute is required as soon as the AAS is exchanged via partners in the life
        /// cycle of the asset. In a first phase of the life cycle the asset might not yet have
        /// a global ID but already an internal identifier. The internal identifier would be
        /// modelled via <see cref="Aas.AssetInformation.SpecificAssetIds" />.
        /// </para>
        /// <para>
        /// This is a global reference.
        /// </para>
        /// </remarks>
        public string? GlobalAssetId { get; set; }

        /// <summary>
        /// Additional domain-specific, typically proprietary identifier for the asset like
        /// e.g., serial number etc.
        /// </summary>
        public List<ISpecificAssetId>? SpecificAssetIds { get; set; }

        /// <summary>
        /// In case <see cref="Aas.AssetInformation.AssetKind" /> is applicable the <see cref="Aas.AssetInformation.AssetType" /> is the asset ID
        /// of the type asset of the asset under consideration
        /// as identified by <see cref="Aas.AssetInformation.GlobalAssetId" />.
        /// </summary>
        /// <remarks>
        /// In case <see cref="Aas.AssetInformation.AssetKind" /> is "Instance" than the <see cref="Aas.AssetInformation.AssetType" /> denotes
        /// which "Type" the asset is of. But it is also possible
        /// to have an <see cref="Aas.AssetInformation.AssetType" /> of an asset of kind "Type".
        /// </remarks>
        public string? AssetType { get; set; }

        /// <summary>
        /// Thumbnail of the asset represented by the Asset Administration Shell.
        /// </summary>
        /// <remarks>
        /// Used as default.
        /// </remarks>
        public IResource? DefaultThumbnail { get; set; }

        /// <summary>
        /// Iterate over SpecificAssetIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ISpecificAssetId> OverSpecificAssetIdsOrEmpty()
        {
            return SpecificAssetIds
                ?? System.Linq.Enumerable.Empty<ISpecificAssetId>();
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (SpecificAssetIds != null)
            {
                foreach (var anItem in SpecificAssetIds)
                {
                    yield return anItem;
                }
            }

            if (DefaultThumbnail != null)
            {
                yield return DefaultThumbnail;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (SpecificAssetIds != null)
            {
                foreach (var anItem in SpecificAssetIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DefaultThumbnail != null)
            {
                yield return DefaultThumbnail;

                // Recurse
                foreach (var anItem in DefaultThumbnail.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitAssetInformation(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitAssetInformation(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformAssetInformation(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformAssetInformation(this, context);
        }

        public AssetInformation(
            AssetKind assetKind,
            string? globalAssetId = null,
            List<ISpecificAssetId>? specificAssetIds = null,
            string? assetType = null,
            IResource? defaultThumbnail = null)
        {
            AssetKind = assetKind;
            GlobalAssetId = globalAssetId;
            SpecificAssetIds = specificAssetIds;
            AssetType = assetType;
            DefaultThumbnail = defaultThumbnail;
        }
    }

    /// <summary>
    /// Resource represents an address to a file (a locator). The value is an URI that
    /// can represent an absolute or relative path
    /// </summary>
    public interface IResource : IClass
    {
        /// <summary>
        /// Path and name of the resource (with file extension).
        /// </summary>
        /// <remarks>
        /// The path can be absolute or relative.
        /// </remarks>
        public string Path { get; set; }

        /// <summary>
        /// Content type of the content of the file.
        /// </summary>
        /// <remarks>
        /// The content type states which file extensions the file can have.
        /// </remarks>
        public string? ContentType { get; set; }
    }

    /// <summary>
    /// Resource represents an address to a file (a locator). The value is an URI that
    /// can represent an absolute or relative path
    /// </summary>
    public class Resource : IResource
    {
        /// <summary>
        /// Path and name of the resource (with file extension).
        /// </summary>
        /// <remarks>
        /// The path can be absolute or relative.
        /// </remarks>
        public string Path { get; set; }

        /// <summary>
        /// Content type of the content of the file.
        /// </summary>
        /// <remarks>
        /// The content type states which file extensions the file can have.
        /// </remarks>
        public string? ContentType { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitResource(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitResource(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformResource(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformResource(this, context);
        }

        public Resource(
            string path,
            string? contentType = null)
        {
            Path = path;
            ContentType = contentType;
        }
    }

    /// <summary>
    /// Enumeration for denoting whether an asset is a type asset or an instance asset.
    /// </summary>
    public enum AssetKind
    {
        /// <summary>
        /// Type asset
        /// </summary>
        [EnumMember(Value = "Type")]
        Type,

        /// <summary>
        /// Instance asset
        /// </summary>
        [EnumMember(Value = "Instance")]
        Instance,

        /// <summary>
        /// Neither a type asset nor an instance asset
        /// </summary>
        [EnumMember(Value = "NotApplicable")]
        NotApplicable
    }

    /// <summary>
    /// A specific asset ID describes a generic supplementary identifying attribute of the
    /// asset.
    /// </summary>
    /// <remarks>
    /// <para>
    /// The specific asset ID is not necessarily globally unique.
    /// </para>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Constraint AASd-133:
    ///     <see cref="Aas.SpecificAssetId.ExternalSubjectId" /> shall be an external reference,
    ///     i.e. <see cref="Aas.Reference.Type" /> = <see cref="Aas.ReferenceTypes.ExternalReference" />.
    ///   </li>
    /// </ul>
    /// </remarks>
    public interface ISpecificAssetId : IHasSemantics
    {
        /// <summary>
        /// Name of the identifier
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// The value of the specific asset identifier with the corresponding name.
        /// </summary>
        public string Value { get; set; }

        /// <summary>
        /// The (external) subject the key belongs to or has meaning to.
        /// </summary>
        /// <remarks>
        /// This is a global reference.
        /// </remarks>
        public IReference? ExternalSubjectId { get; set; }
    }

    /// <summary>
    /// A specific asset ID describes a generic supplementary identifying attribute of the
    /// asset.
    /// </summary>
    /// <remarks>
    /// <para>
    /// The specific asset ID is not necessarily globally unique.
    /// </para>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Constraint AASd-133:
    ///     <see cref="Aas.SpecificAssetId.ExternalSubjectId" /> shall be an external reference,
    ///     i.e. <see cref="Aas.Reference.Type" /> = <see cref="Aas.ReferenceTypes.ExternalReference" />.
    ///   </li>
    /// </ul>
    /// </remarks>
    public class SpecificAssetId : ISpecificAssetId
    {
        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<IReference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Name of the identifier
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// The value of the specific asset identifier with the corresponding name.
        /// </summary>
        public string Value { get; set; }

        /// <summary>
        /// The (external) subject the key belongs to or has meaning to.
        /// </summary>
        /// <remarks>
        /// This is a global reference.
        /// </remarks>
        public IReference? ExternalSubjectId { get; set; }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IReference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<IReference>();
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (ExternalSubjectId != null)
            {
                yield return ExternalSubjectId;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (ExternalSubjectId != null)
            {
                yield return ExternalSubjectId;

                // Recurse
                foreach (var anItem in ExternalSubjectId.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitSpecificAssetId(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitSpecificAssetId(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformSpecificAssetId(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformSpecificAssetId(this, context);
        }

        public SpecificAssetId(
            string name,
            string value,
            IReference? semanticId = null,
            List<IReference>? supplementalSemanticIds = null,
            IReference? externalSubjectId = null)
        {
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Name = name;
            Value = value;
            ExternalSubjectId = externalSubjectId;
        }
    }

    /// <summary>
    /// A submodel defines a specific aspect of the asset represented by the AAS.
    /// </summary>
    /// <remarks>
    /// A submodel is used to structure the digital representation and technical
    /// functionality of an Administration Shell into distinguishable parts. Each submodel
    /// refers to a well-defined domain or subject matter. Submodels can become
    /// standardized and, thus, become submodels templates.
    /// </remarks>
    public interface ISubmodel :
            IIdentifiable,
            IHasKind,
            IHasSemantics,
            IQualifiable,
            IHasDataSpecification
    {
        /// <summary>
        /// A submodel consists of zero or more submodel elements.
        /// </summary>
        public List<ISubmodelElement>? SubmodelElements { get; set; }

        /// <summary>
        /// Iterate over SubmodelElements, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ISubmodelElement> OverSubmodelElementsOrEmpty();
    }

    /// <summary>
    /// A submodel defines a specific aspect of the asset represented by the AAS.
    /// </summary>
    /// <remarks>
    /// A submodel is used to structure the digital representation and technical
    /// functionality of an Administration Shell into distinguishable parts. Each submodel
    /// refers to a well-defined domain or subject matter. Submodels can become
    /// standardized and, thus, become submodels templates.
    /// </remarks>
    public class Submodel : ISubmodel
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<IExtension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        public List<ILangStringNameType>? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The description can be provided in several languages.
        /// </para>
        /// <para>
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        /// </para>
        /// <para>
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </para>
        /// </remarks>
        public List<ILangStringTextType>? Description { get; set; }

        /// <summary>
        /// Administrative information of an identifiable element.
        /// </summary>
        /// <remarks>
        /// Some of the administrative information like the version number might need to
        /// be part of the identification.
        /// </remarks>
        public IAdministrativeInformation? Administration { get; set; }

        /// <summary>
        /// The globally unique identification of the element.
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Kind of the element: either type or instance.
        /// </summary>
        /// <remarks>
        /// Default: <see cref="Aas.ModellingKind.Instance" />
        /// </remarks>
        public ModellingKind? Kind { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<IReference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Constraints:
        /// </para>
        /// <ul>
        ///   <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///   </li>
        /// </ul>
        /// </remarks>
        public List<IQualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Embedded data specification.
        /// </summary>
        public List<IEmbeddedDataSpecification>? EmbeddedDataSpecifications { get; set; }

        /// <summary>
        /// A submodel consists of zero or more submodel elements.
        /// </summary>
        public List<ISubmodelElement>? SubmodelElements { get; set; }

        #region Parent
        [JsonIgnore]
        public IClass Parent { get; set; }
        #endregion

        #region TimeStamp
        [JsonIgnore]
        public DateTime TimeStampCreate { get; set; }
        [JsonIgnore]
        public DateTime TimeStamp { get; set; }
        [JsonIgnore]
        public DateTime TimeStampTree { get; set; }

        [JsonIgnore]
        private DiaryDataDef _diaryData = new DiaryDataDef();

        [JsonIgnore]
        public DiaryDataDef DiaryData { get { return _diaryData; } }

        #endregion

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IExtension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<IExtension>();
        }

        /// <summary>
        /// Iterate over DisplayName, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringNameType> OverDisplayNameOrEmpty()
        {
            return DisplayName
                ?? System.Linq.Enumerable.Empty<ILangStringNameType>();
        }

        /// <summary>
        /// Iterate over Description, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringTextType> OverDescriptionOrEmpty()
        {
            return Description
                ?? System.Linq.Enumerable.Empty<ILangStringTextType>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IReference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<IReference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IQualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<IQualifier>();
        }

        /// <summary>
        /// Iterate over EmbeddedDataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IEmbeddedDataSpecification> OverEmbeddedDataSpecificationsOrEmpty()
        {
            return EmbeddedDataSpecifications
                ?? System.Linq.Enumerable.Empty<IEmbeddedDataSpecification>();
        }

        /// <summary>
        /// Iterate over SubmodelElements, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ISubmodelElement> OverSubmodelElementsOrEmpty()
        {
            return SubmodelElements
                ?? System.Linq.Enumerable.Empty<ISubmodelElement>();
        }

        /// <summary>
        /// Return the <see cref="IHasKind.Kind" /> or the default value
        /// if it has not been set.
        /// </summary>
        public ModellingKind KindOrDefault()
        {
            return Kind ?? ModellingKind.Instance;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;
                }
            }

            if (Administration != null)
            {
                yield return Administration;
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (SubmodelElements != null)
            {
                foreach (var anItem in SubmodelElements)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Administration != null)
            {
                yield return Administration;

                // Recurse
                foreach (var anItem in Administration.Descend())
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (SubmodelElements != null)
            {
                foreach (var anItem in SubmodelElements)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitSubmodel(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitSubmodel(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformSubmodel(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformSubmodel(this, context);
        }

        public Submodel(
            string id,
            List<IExtension>? extensions = null,
            string? category = null,
            string? idShort = null,
            List<ILangStringNameType>? displayName = null,
            List<ILangStringTextType>? description = null,
            IAdministrativeInformation? administration = null,
            ModellingKind? kind = null,
            IReference? semanticId = null,
            List<IReference>? supplementalSemanticIds = null,
            List<IQualifier>? qualifiers = null,
            List<IEmbeddedDataSpecification>? embeddedDataSpecifications = null,
            List<ISubmodelElement>? submodelElements = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Id = id;
            Administration = administration;
            Kind = kind;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            EmbeddedDataSpecifications = embeddedDataSpecifications;
            SubmodelElements = submodelElements;
        }
    }

    /// <summary>
    /// A submodel element is an element suitable for the description and differentiation of
    /// assets.
    /// </summary>
    /// <remarks>
    /// <para>
    /// It is recommended to add a <see cref="Aas.IHasSemantics.SemanticId" /> to a submodel element.
    /// </para>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Constraint AASd-129:
    ///     If any <see cref="Aas.Qualifier.Kind" /> value of <see cref="Aas.ISubmodelElement.Qualifiers" /> (attribute qualifier
    ///     inherited via Qualifiable) is equal to <see cref="Aas.QualifierKind.TemplateQualifier" />
    ///     then the submodel element shall be part of a submodel template, i.e.
    ///     a Submodel with <see cref="Aas.Submodel.Kind" /> (attribute kind inherited via
    ///     <see cref="Aas.IHasKind" />) value is equal to <see cref="Aas.ModellingKind.Template" />.
    ///   </li>
    /// </ul>
    /// </remarks>
    public interface ISubmodelElement :
            IReferable,
            IHasSemantics,
            IQualifiable,
            IHasDataSpecification
    {
        // Intentionally empty.
    }

    /// <summary>
    /// A relationship element is used to define a relationship between two elements
    /// being either referable (model reference) or external (global reference).
    /// </summary>
    public interface IRelationshipElement : ISubmodelElement
    {
        /// <summary>
        /// Reference to the first element in the relationship taking the role of the subject.
        /// </summary>
        public IReference First { get; set; }

        /// <summary>
        /// Reference to the second element in the relationship taking the role of the object.
        /// </summary>
        public IReference Second { get; set; }
    }

    /// <summary>
    /// A relationship element is used to define a relationship between two elements
    /// being either referable (model reference) or external (global reference).
    /// </summary>
    public class RelationshipElement : IRelationshipElement
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<IExtension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        public List<ILangStringNameType>? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The description can be provided in several languages.
        /// </para>
        /// <para>
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        /// </para>
        /// <para>
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </para>
        /// </remarks>
        public List<ILangStringTextType>? Description { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<IReference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Constraints:
        /// </para>
        /// <ul>
        ///   <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///   </li>
        /// </ul>
        /// </remarks>
        public List<IQualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Embedded data specification.
        /// </summary>
        public List<IEmbeddedDataSpecification>? EmbeddedDataSpecifications { get; set; }

        /// <summary>
        /// Reference to the first element in the relationship taking the role of the subject.
        /// </summary>
        public IReference First { get; set; }

        /// <summary>
        /// Reference to the second element in the relationship taking the role of the object.
        /// </summary>
        public IReference Second { get; set; }

        #region Parent
        [JsonIgnore]
        public IClass Parent { get; set; }
        #endregion

        #region TimeStamp
        [JsonIgnore]
        public DateTime TimeStampCreate { get; set; }
        [JsonIgnore]
        public DateTime TimeStamp { get; set; }
        [JsonIgnore]
        public DateTime TimeStampTree { get; set; }

        [JsonIgnore]
        private DiaryDataDef _diaryData = new DiaryDataDef();

        [JsonIgnore]
        public DiaryDataDef DiaryData { get { return _diaryData; } }

        #endregion

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IExtension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<IExtension>();
        }

        /// <summary>
        /// Iterate over DisplayName, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringNameType> OverDisplayNameOrEmpty()
        {
            return DisplayName
                ?? System.Linq.Enumerable.Empty<ILangStringNameType>();
        }

        /// <summary>
        /// Iterate over Description, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringTextType> OverDescriptionOrEmpty()
        {
            return Description
                ?? System.Linq.Enumerable.Empty<ILangStringTextType>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IReference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<IReference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IQualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<IQualifier>();
        }

        /// <summary>
        /// Iterate over EmbeddedDataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IEmbeddedDataSpecification> OverEmbeddedDataSpecificationsOrEmpty()
        {
            return EmbeddedDataSpecifications
                ?? System.Linq.Enumerable.Empty<IEmbeddedDataSpecification>();
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;
                }
            }

            yield return First;

            yield return Second;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            yield return First;

            // Recurse
            foreach (var anItem in First.Descend())
            {
                yield return anItem;
            }

            yield return Second;

            // Recurse
            foreach (var anItem in Second.Descend())
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitRelationshipElement(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitRelationshipElement(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformRelationshipElement(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformRelationshipElement(this, context);
        }

        public RelationshipElement(
            IReference first,
            IReference second,
            List<IExtension>? extensions = null,
            string? category = null,
            string? idShort = null,
            List<ILangStringNameType>? displayName = null,
            List<ILangStringTextType>? description = null,
            IReference? semanticId = null,
            List<IReference>? supplementalSemanticIds = null,
            List<IQualifier>? qualifiers = null,
            List<IEmbeddedDataSpecification>? embeddedDataSpecifications = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            EmbeddedDataSpecifications = embeddedDataSpecifications;
            First = first;
            Second = second;
        }
    }

    /// <summary>
    /// Enumeration of all possible elements of a <see cref="Aas.SubmodelElementList" />.
    /// </summary>
    public enum AasSubmodelElements
    {
        [EnumMember(Value = "AnnotatedRelationshipElement")]
        AnnotatedRelationshipElement,

        [EnumMember(Value = "BasicEventElement")]
        BasicEventElement,

        [EnumMember(Value = "Blob")]
        Blob,

        [EnumMember(Value = "Capability")]
        Capability,

        [EnumMember(Value = "DataElement")]
        DataElement,

        [EnumMember(Value = "Entity")]
        Entity,

        [EnumMember(Value = "EventElement")]
        EventElement,

        [EnumMember(Value = "File")]
        File,

        [EnumMember(Value = "MultiLanguageProperty")]
        MultiLanguageProperty,

        [EnumMember(Value = "Operation")]
        Operation,

        [EnumMember(Value = "Property")]
        Property,

        [EnumMember(Value = "Range")]
        Range,

        [EnumMember(Value = "ReferenceElement")]
        ReferenceElement,

        [EnumMember(Value = "RelationshipElement")]
        RelationshipElement,

        [EnumMember(Value = "SubmodelElement")]
        SubmodelElement,

        [EnumMember(Value = "SubmodelElementList")]
        SubmodelElementList,

        [EnumMember(Value = "SubmodelElementCollection")]
        SubmodelElementCollection
    }

    /// <summary>
    /// A submodel element list is an ordered list of submodel elements.
    /// </summary>
    /// <remarks>
    /// <para>
    /// The numbering starts with zero (0).
    /// </para>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Constraint AASd-107:
    ///     If a first level child element in a <see cref="Aas.SubmodelElementList" /> has
    ///     a <see cref="Aas.IHasSemantics.SemanticId" /> it
    ///     shall be identical to <see cref="Aas.SubmodelElementList.SemanticIdListElement" />.
    ///   </li>
    ///   <li>
    ///     Constraint AASd-114:
    ///     If two first level child elements in a <see cref="Aas.SubmodelElementList" /> have
    ///     a <see cref="Aas.IHasSemantics.SemanticId" /> then they shall be identical.
    ///   </li>
    ///   <li>
    ///     Constraint AASd-115:
    ///     If a first level child element in a <see cref="Aas.SubmodelElementList" /> does not
    ///     specify a <see cref="Aas.IHasSemantics.SemanticId" /> then the value is assumed to be
    ///     identical to <see cref="Aas.SubmodelElementList.SemanticIdListElement" />.
    ///   </li>
    ///   <li>
    ///     Constraint AASd-108:
    ///     All first level child elements in a <see cref="Aas.SubmodelElementList" /> shall have
    ///     the same submodel element type as specified in <see cref="Aas.SubmodelElementList.TypeValueListElement" />.
    ///   </li>
    ///   <li>
    ///     Constraint AASd-109:
    ///     If <see cref="Aas.SubmodelElementList.TypeValueListElement" /> is equal to
    ///     <see cref="Aas.AasSubmodelElements.Property" /> or
    ///     <see cref="Aas.AasSubmodelElements.Range" />
    ///     <see cref="Aas.SubmodelElementList.ValueTypeListElement" /> shall be set and all first
    ///     level child elements in the <see cref="Aas.SubmodelElementList" /> shall have
    ///     the value type as specified in <see cref="Aas.SubmodelElementList.ValueTypeListElement" />.
    ///   </li>
    /// </ul>
    /// </remarks>
    public interface ISubmodelElementList : ISubmodelElement
    {
        /// <summary>
        /// Defines whether order in list is relevant. If <see cref="Aas.SubmodelElementList.OrderRelevant" /> = <c>False</c>
        /// then the list is representing a set or a bag.
        /// </summary>
        /// <remarks>
        /// Default: <c>True</c>
        /// </remarks>
        public bool? OrderRelevant { get; set; }

        /// <summary>
        /// Semantic ID the submodel elements contained in the list match to.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? SemanticIdListElement { get; set; }

        /// <summary>
        /// The submodel element type of the submodel elements contained in the list.
        /// </summary>
        public AasSubmodelElements TypeValueListElement { get; set; }

        /// <summary>
        /// The value type of the submodel element contained in the list.
        /// </summary>
        public DataTypeDefXsd? ValueTypeListElement { get; set; }

        /// <summary>
        /// Submodel element contained in the list.
        /// </summary>
        /// <remarks>
        /// The list is ordered.
        /// </remarks>
        public List<ISubmodelElement>? Value { get; set; }

        public bool OrderRelevantOrDefault();

        /// <summary>
        /// Iterate over Value, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ISubmodelElement> OverValueOrEmpty();
    }

    /// <summary>
    /// A submodel element list is an ordered list of submodel elements.
    /// </summary>
    /// <remarks>
    /// <para>
    /// The numbering starts with zero (0).
    /// </para>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Constraint AASd-107:
    ///     If a first level child element in a <see cref="Aas.SubmodelElementList" /> has
    ///     a <see cref="Aas.IHasSemantics.SemanticId" /> it
    ///     shall be identical to <see cref="Aas.SubmodelElementList.SemanticIdListElement" />.
    ///   </li>
    ///   <li>
    ///     Constraint AASd-114:
    ///     If two first level child elements in a <see cref="Aas.SubmodelElementList" /> have
    ///     a <see cref="Aas.IHasSemantics.SemanticId" /> then they shall be identical.
    ///   </li>
    ///   <li>
    ///     Constraint AASd-115:
    ///     If a first level child element in a <see cref="Aas.SubmodelElementList" /> does not
    ///     specify a <see cref="Aas.IHasSemantics.SemanticId" /> then the value is assumed to be
    ///     identical to <see cref="Aas.SubmodelElementList.SemanticIdListElement" />.
    ///   </li>
    ///   <li>
    ///     Constraint AASd-108:
    ///     All first level child elements in a <see cref="Aas.SubmodelElementList" /> shall have
    ///     the same submodel element type as specified in <see cref="Aas.SubmodelElementList.TypeValueListElement" />.
    ///   </li>
    ///   <li>
    ///     Constraint AASd-109:
    ///     If <see cref="Aas.SubmodelElementList.TypeValueListElement" /> is equal to
    ///     <see cref="Aas.AasSubmodelElements.Property" /> or
    ///     <see cref="Aas.AasSubmodelElements.Range" />
    ///     <see cref="Aas.SubmodelElementList.ValueTypeListElement" /> shall be set and all first
    ///     level child elements in the <see cref="Aas.SubmodelElementList" /> shall have
    ///     the value type as specified in <see cref="Aas.SubmodelElementList.ValueTypeListElement" />.
    ///   </li>
    /// </ul>
    /// </remarks>
    public class SubmodelElementList : ISubmodelElementList
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<IExtension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        public List<ILangStringNameType>? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The description can be provided in several languages.
        /// </para>
        /// <para>
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        /// </para>
        /// <para>
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </para>
        /// </remarks>
        public List<ILangStringTextType>? Description { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<IReference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Constraints:
        /// </para>
        /// <ul>
        ///   <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///   </li>
        /// </ul>
        /// </remarks>
        public List<IQualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Embedded data specification.
        /// </summary>
        public List<IEmbeddedDataSpecification>? EmbeddedDataSpecifications { get; set; }

        /// <summary>
        /// Defines whether order in list is relevant. If <see cref="Aas.SubmodelElementList.OrderRelevant" /> = <c>False</c>
        /// then the list is representing a set or a bag.
        /// </summary>
        /// <remarks>
        /// Default: <c>True</c>
        /// </remarks>
        public bool? OrderRelevant { get; set; }

        /// <summary>
        /// Semantic ID the submodel elements contained in the list match to.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? SemanticIdListElement { get; set; }

        /// <summary>
        /// The submodel element type of the submodel elements contained in the list.
        /// </summary>
        public AasSubmodelElements TypeValueListElement { get; set; }

        /// <summary>
        /// The value type of the submodel element contained in the list.
        /// </summary>
        public DataTypeDefXsd? ValueTypeListElement { get; set; }

        /// <summary>
        /// Submodel element contained in the list.
        /// </summary>
        /// <remarks>
        /// The list is ordered.
        /// </remarks>
        public List<ISubmodelElement>? Value { get; set; }

        #region Parent
        [JsonIgnore]
        public IClass Parent { get; set; }
        #endregion

        #region TimeStamp
        [JsonIgnore]
        public DateTime TimeStampCreate { get; set; }
        [JsonIgnore]
        public DateTime TimeStamp { get; set; }
        [JsonIgnore]
        public DateTime TimeStampTree { get; set; }

        [JsonIgnore]
        private DiaryDataDef _diaryData = new DiaryDataDef();

        [JsonIgnore]
        public DiaryDataDef DiaryData { get { return _diaryData; } }

        #endregion

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IExtension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<IExtension>();
        }

        /// <summary>
        /// Iterate over DisplayName, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringNameType> OverDisplayNameOrEmpty()
        {
            return DisplayName
                ?? System.Linq.Enumerable.Empty<ILangStringNameType>();
        }

        /// <summary>
        /// Iterate over Description, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringTextType> OverDescriptionOrEmpty()
        {
            return Description
                ?? System.Linq.Enumerable.Empty<ILangStringTextType>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IReference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<IReference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IQualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<IQualifier>();
        }

        /// <summary>
        /// Iterate over EmbeddedDataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IEmbeddedDataSpecification> OverEmbeddedDataSpecificationsOrEmpty()
        {
            return EmbeddedDataSpecifications
                ?? System.Linq.Enumerable.Empty<IEmbeddedDataSpecification>();
        }

        /// <summary>
        /// Iterate over Value, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ISubmodelElement> OverValueOrEmpty()
        {
            return Value
                ?? System.Linq.Enumerable.Empty<ISubmodelElement>();
        }

        /// <summary>
        /// Return the <see cref="SubmodelElementList.OrderRelevant" /> or the default value
        /// if it has not been set.
        /// </summary>
        public bool OrderRelevantOrDefault()
        {
            return OrderRelevant ?? true;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (SemanticIdListElement != null)
            {
                yield return SemanticIdListElement;
            }

            if (Value != null)
            {
                foreach (var anItem in Value)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (SemanticIdListElement != null)
            {
                yield return SemanticIdListElement;

                // Recurse
                foreach (var anItem in SemanticIdListElement.Descend())
                {
                    yield return anItem;
                }
            }

            if (Value != null)
            {
                foreach (var anItem in Value)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitSubmodelElementList(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitSubmodelElementList(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformSubmodelElementList(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformSubmodelElementList(this, context);
        }

        public SubmodelElementList(
            AasSubmodelElements typeValueListElement,
            List<IExtension>? extensions = null,
            string? category = null,
            string? idShort = null,
            List<ILangStringNameType>? displayName = null,
            List<ILangStringTextType>? description = null,
            IReference? semanticId = null,
            List<IReference>? supplementalSemanticIds = null,
            List<IQualifier>? qualifiers = null,
            List<IEmbeddedDataSpecification>? embeddedDataSpecifications = null,
            bool? orderRelevant = null,
            IReference? semanticIdListElement = null,
            DataTypeDefXsd? valueTypeListElement = null,
            List<ISubmodelElement>? value = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            EmbeddedDataSpecifications = embeddedDataSpecifications;
            TypeValueListElement = typeValueListElement;
            OrderRelevant = orderRelevant;
            SemanticIdListElement = semanticIdListElement;
            ValueTypeListElement = valueTypeListElement;
            Value = value;
        }
    }

    /// <summary>
    /// A submodel element collection is a kind of struct, i.e. a a logical encapsulation
    /// of multiple named values. It has a fixed number of submodel elements.
    /// </summary>
    public interface ISubmodelElementCollection : ISubmodelElement
    {
        /// <summary>
        /// Submodel element contained in the collection.
        /// </summary>
        public List<ISubmodelElement>? Value { get; set; }

        /// <summary>
        /// Iterate over Value, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ISubmodelElement> OverValueOrEmpty();
    }

    /// <summary>
    /// A submodel element collection is a kind of struct, i.e. a a logical encapsulation
    /// of multiple named values. It has a fixed number of submodel elements.
    /// </summary>
    public class SubmodelElementCollection : ISubmodelElementCollection
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<IExtension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        public List<ILangStringNameType>? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The description can be provided in several languages.
        /// </para>
        /// <para>
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        /// </para>
        /// <para>
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </para>
        /// </remarks>
        public List<ILangStringTextType>? Description { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<IReference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Constraints:
        /// </para>
        /// <ul>
        ///   <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///   </li>
        /// </ul>
        /// </remarks>
        public List<IQualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Embedded data specification.
        /// </summary>
        public List<IEmbeddedDataSpecification>? EmbeddedDataSpecifications { get; set; }

        /// <summary>
        /// Submodel element contained in the collection.
        /// </summary>
        public List<ISubmodelElement>? Value { get; set; }

        #region Parent
        [JsonIgnore]
        public IClass Parent { get; set; }
        #endregion

        #region TimeStamp
        [JsonIgnore]
        public DateTime TimeStampCreate { get; set; }
        [JsonIgnore]
        public DateTime TimeStamp { get; set; }
        [JsonIgnore]
        public DateTime TimeStampTree { get; set; }

        [JsonIgnore]
        private DiaryDataDef _diaryData = new DiaryDataDef();

        [JsonIgnore]
        public DiaryDataDef DiaryData { get { return _diaryData; } }

        #endregion

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IExtension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<IExtension>();
        }

        /// <summary>
        /// Iterate over DisplayName, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringNameType> OverDisplayNameOrEmpty()
        {
            return DisplayName
                ?? System.Linq.Enumerable.Empty<ILangStringNameType>();
        }

        /// <summary>
        /// Iterate over Description, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringTextType> OverDescriptionOrEmpty()
        {
            return Description
                ?? System.Linq.Enumerable.Empty<ILangStringTextType>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IReference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<IReference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IQualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<IQualifier>();
        }

        /// <summary>
        /// Iterate over EmbeddedDataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IEmbeddedDataSpecification> OverEmbeddedDataSpecificationsOrEmpty()
        {
            return EmbeddedDataSpecifications
                ?? System.Linq.Enumerable.Empty<IEmbeddedDataSpecification>();
        }

        /// <summary>
        /// Iterate over Value, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ISubmodelElement> OverValueOrEmpty()
        {
            return Value
                ?? System.Linq.Enumerable.Empty<ISubmodelElement>();
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (Value != null)
            {
                foreach (var anItem in Value)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Value != null)
            {
                foreach (var anItem in Value)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitSubmodelElementCollection(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitSubmodelElementCollection(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformSubmodelElementCollection(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformSubmodelElementCollection(this, context);
        }

        public SubmodelElementCollection(
            List<IExtension>? extensions = null,
            string? category = null,
            string? idShort = null,
            List<ILangStringNameType>? displayName = null,
            List<ILangStringTextType>? description = null,
            IReference? semanticId = null,
            List<IReference>? supplementalSemanticIds = null,
            List<IQualifier>? qualifiers = null,
            List<IEmbeddedDataSpecification>? embeddedDataSpecifications = null,
            List<ISubmodelElement>? value = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            EmbeddedDataSpecifications = embeddedDataSpecifications;
            Value = value;
        }
    }

    /// <summary>
    /// A data element is a submodel element that is not further composed out of
    /// other submodel elements.
    /// </summary>
    /// <remarks>
    /// <para>
    /// A data element is a submodel element that has a value. The type of value differs
    /// for different subtypes of data elements.
    /// </para>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     <para>
    ///     Constraint AASd-090:
    ///     For data elements <see cref="Aas.IDataElement.Category" /> shall be one of the following
    ///     values: <c>CONSTANT</c>, <c>PARAMETER</c> or <c>VARIABLE</c>.
    ///     </para>
    ///     <para>
    ///     Default: <c>VARIABLE</c>
    ///     </para>
    ///   </li>
    /// </ul>
    /// </remarks>
    public interface IDataElement : ISubmodelElement
    {
        public string CategoryOrDefault();
    }

    /// <summary>
    /// A property is a data element that has a single value.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Constraint AASd-007:
    ///     If both, the <see cref="Aas.Property.Value" /> and the <see cref="Aas.Property.ValueId" /> are
    ///     present then the value of <see cref="Aas.Property.Value" /> needs to be identical to
    ///     the value of the referenced coded value in <see cref="Aas.Property.ValueId" />.
    ///   </li>
    /// </ul>
    /// </remarks>
    public interface IProperty : IDataElement
    {
        /// <summary>
        /// Data type of the value
        /// </summary>
        public DataTypeDefXsd ValueType { get; set; }

        /// <summary>
        /// The value of the property instance.
        /// </summary>
        public string? Value { get; set; }

        /// <summary>
        /// Reference to the global unique ID of a coded value.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? ValueId { get; set; }
    }

    /// <summary>
    /// A property is a data element that has a single value.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Constraint AASd-007:
    ///     If both, the <see cref="Aas.Property.Value" /> and the <see cref="Aas.Property.ValueId" /> are
    ///     present then the value of <see cref="Aas.Property.Value" /> needs to be identical to
    ///     the value of the referenced coded value in <see cref="Aas.Property.ValueId" />.
    ///   </li>
    /// </ul>
    /// </remarks>
    public class Property : IProperty
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<IExtension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        public List<ILangStringNameType>? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The description can be provided in several languages.
        /// </para>
        /// <para>
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        /// </para>
        /// <para>
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </para>
        /// </remarks>
        public List<ILangStringTextType>? Description { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<IReference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Constraints:
        /// </para>
        /// <ul>
        ///   <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///   </li>
        /// </ul>
        /// </remarks>
        public List<IQualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Embedded data specification.
        /// </summary>
        public List<IEmbeddedDataSpecification>? EmbeddedDataSpecifications { get; set; }

        /// <summary>
        /// Data type of the value
        /// </summary>
        public DataTypeDefXsd ValueType { get; set; }

        /// <summary>
        /// The value of the property instance.
        /// </summary>
        public string? Value { get; set; }

        /// <summary>
        /// Reference to the global unique ID of a coded value.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? ValueId { get; set; }

        #region Parent
        [JsonIgnore]
        public IClass Parent { get; set; }
        #endregion

        #region TimeStamp
        [JsonIgnore]
        public DateTime TimeStampCreate { get; set; }
        [JsonIgnore]
        public DateTime TimeStamp { get; set; }
        [JsonIgnore]
        public DateTime TimeStampTree { get; set; }

        [JsonIgnore]
        private DiaryDataDef _diaryData = new DiaryDataDef();

        [JsonIgnore]
        public DiaryDataDef DiaryData { get { return _diaryData; } }

        #endregion

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IExtension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<IExtension>();
        }

        /// <summary>
        /// Iterate over DisplayName, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringNameType> OverDisplayNameOrEmpty()
        {
            return DisplayName
                ?? System.Linq.Enumerable.Empty<ILangStringNameType>();
        }

        /// <summary>
        /// Iterate over Description, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringTextType> OverDescriptionOrEmpty()
        {
            return Description
                ?? System.Linq.Enumerable.Empty<ILangStringTextType>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IReference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<IReference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IQualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<IQualifier>();
        }

        /// <summary>
        /// Iterate over EmbeddedDataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IEmbeddedDataSpecification> OverEmbeddedDataSpecificationsOrEmpty()
        {
            return EmbeddedDataSpecifications
                ?? System.Linq.Enumerable.Empty<IEmbeddedDataSpecification>();
        }

        /// <summary>
        /// Return the <see cref="IReferable.Category" /> or the default value
        /// if it has not been set.
        /// </summary>
        public string CategoryOrDefault()
        {
            string result = Category ?? "VARIABLE";

#if DEBUG
            if (!Constants.ValidCategoriesForDataElement.Contains(
                    result))
            {
                throw new System.InvalidOperationException(
                    $"Unexpected default category: {result}"
                );
            }
#endif

            return result;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (ValueId != null)
            {
                yield return ValueId;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (ValueId != null)
            {
                yield return ValueId;

                // Recurse
                foreach (var anItem in ValueId.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitProperty(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitProperty(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformProperty(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformProperty(this, context);
        }

        public Property(
            DataTypeDefXsd valueType,
            List<IExtension>? extensions = null,
            string? category = null,
            string? idShort = null,
            List<ILangStringNameType>? displayName = null,
            List<ILangStringTextType>? description = null,
            IReference? semanticId = null,
            List<IReference>? supplementalSemanticIds = null,
            List<IQualifier>? qualifiers = null,
            List<IEmbeddedDataSpecification>? embeddedDataSpecifications = null,
            string? value = null,
            IReference? valueId = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            EmbeddedDataSpecifications = embeddedDataSpecifications;
            ValueType = valueType;
            Value = value;
            ValueId = valueId;
        }
    }

    /// <summary>
    /// A property is a data element that has a multi-language value.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Constraint AASd-012:
    ///     If both the <see cref="Aas.MultiLanguageProperty.Value" /> and the <see cref="Aas.MultiLanguageProperty.ValueId" /> are present then for each
    ///     string in a specific language the meaning must be the same as specified in
    ///     <see cref="Aas.MultiLanguageProperty.ValueId" />.
    ///   </li>
    /// </ul>
    /// </remarks>
    public interface IMultiLanguageProperty : IDataElement
    {
        /// <summary>
        /// The value of the property instance.
        /// </summary>
        public List<ILangStringTextType>? Value { get; set; }

        /// <summary>
        /// Reference to the global unique ID of a coded value.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? ValueId { get; set; }

        /// <summary>
        /// Iterate over Value, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringTextType> OverValueOrEmpty();
    }

    /// <summary>
    /// A property is a data element that has a multi-language value.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Constraint AASd-012:
    ///     If both the <see cref="Aas.MultiLanguageProperty.Value" /> and the <see cref="Aas.MultiLanguageProperty.ValueId" /> are present then for each
    ///     string in a specific language the meaning must be the same as specified in
    ///     <see cref="Aas.MultiLanguageProperty.ValueId" />.
    ///   </li>
    /// </ul>
    /// </remarks>
    public class MultiLanguageProperty : IMultiLanguageProperty
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<IExtension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        public List<ILangStringNameType>? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The description can be provided in several languages.
        /// </para>
        /// <para>
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        /// </para>
        /// <para>
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </para>
        /// </remarks>
        public List<ILangStringTextType>? Description { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<IReference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Constraints:
        /// </para>
        /// <ul>
        ///   <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///   </li>
        /// </ul>
        /// </remarks>
        public List<IQualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Embedded data specification.
        /// </summary>
        public List<IEmbeddedDataSpecification>? EmbeddedDataSpecifications { get; set; }

        /// <summary>
        /// The value of the property instance.
        /// </summary>
        public List<ILangStringTextType>? Value { get; set; }

        /// <summary>
        /// Reference to the global unique ID of a coded value.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? ValueId { get; set; }
        #region Parent
        [JsonIgnore]
        public IClass Parent { get; set; }
        #endregion

        #region TimeStamp
        [JsonIgnore]
        public DateTime TimeStampCreate { get; set; }
        [JsonIgnore]
        public DateTime TimeStamp { get; set; }
        [JsonIgnore]
        public DateTime TimeStampTree { get; set; }

        [JsonIgnore]
        private DiaryDataDef _diaryData = new DiaryDataDef();

        [JsonIgnore]
        public DiaryDataDef DiaryData { get { return _diaryData; } }

        #endregion

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IExtension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<IExtension>();
        }

        /// <summary>
        /// Iterate over DisplayName, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringNameType> OverDisplayNameOrEmpty()
        {
            return DisplayName
                ?? System.Linq.Enumerable.Empty<ILangStringNameType>();
        }

        /// <summary>
        /// Iterate over Description, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringTextType> OverDescriptionOrEmpty()
        {
            return Description
                ?? System.Linq.Enumerable.Empty<ILangStringTextType>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IReference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<IReference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IQualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<IQualifier>();
        }

        /// <summary>
        /// Iterate over EmbeddedDataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IEmbeddedDataSpecification> OverEmbeddedDataSpecificationsOrEmpty()
        {
            return EmbeddedDataSpecifications
                ?? System.Linq.Enumerable.Empty<IEmbeddedDataSpecification>();
        }

        /// <summary>
        /// Iterate over Value, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringTextType> OverValueOrEmpty()
        {
            return Value
                ?? System.Linq.Enumerable.Empty<ILangStringTextType>();
        }

        /// <summary>
        /// Return the <see cref="IReferable.Category" /> or the default value
        /// if it has not been set.
        /// </summary>
        public string CategoryOrDefault()
        {
            string result = Category ?? "VARIABLE";

#if DEBUG
            if (!Constants.ValidCategoriesForDataElement.Contains(
                    result))
            {
                throw new System.InvalidOperationException(
                    $"Unexpected default category: {result}"
                );
            }
#endif

            return result;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (Value != null)
            {
                foreach (var anItem in Value)
                {
                    yield return anItem;
                }
            }

            if (ValueId != null)
            {
                yield return ValueId;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Value != null)
            {
                foreach (var anItem in Value)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (ValueId != null)
            {
                yield return ValueId;

                // Recurse
                foreach (var anItem in ValueId.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitMultiLanguageProperty(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitMultiLanguageProperty(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformMultiLanguageProperty(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformMultiLanguageProperty(this, context);
        }

        public MultiLanguageProperty(
            List<IExtension>? extensions = null,
            string? category = null,
            string? idShort = null,
            List<ILangStringNameType>? displayName = null,
            List<ILangStringTextType>? description = null,
            IReference? semanticId = null,
            List<IReference>? supplementalSemanticIds = null,
            List<IQualifier>? qualifiers = null,
            List<IEmbeddedDataSpecification>? embeddedDataSpecifications = null,
            List<ILangStringTextType>? value = null,
            IReference? valueId = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            EmbeddedDataSpecifications = embeddedDataSpecifications;
            Value = value;
            ValueId = valueId;
        }
    }

    /// <summary>
    /// A range data element is a data element that defines a range with min and max.
    /// </summary>
    public interface IRange : IDataElement
    {
        /// <summary>
        /// Data type of the min und max
        /// </summary>
        public DataTypeDefXsd ValueType { get; set; }

        /// <summary>
        /// The minimum value of the range.
        /// </summary>
        /// <remarks>
        /// If the min value is missing, then the value is assumed to be negative infinite.
        /// </remarks>
        public string? Min { get; set; }

        /// <summary>
        /// The maximum value of the range.
        /// </summary>
        /// <remarks>
        /// If the max value is missing, then the value is assumed to be positive infinite.
        /// </remarks>
        public string? Max { get; set; }
    }

    /// <summary>
    /// A range data element is a data element that defines a range with min and max.
    /// </summary>
    public class Range : IRange
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<IExtension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        public List<ILangStringNameType>? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The description can be provided in several languages.
        /// </para>
        /// <para>
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        /// </para>
        /// <para>
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </para>
        /// </remarks>
        public List<ILangStringTextType>? Description { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<IReference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Constraints:
        /// </para>
        /// <ul>
        ///   <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///   </li>
        /// </ul>
        /// </remarks>
        public List<IQualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Embedded data specification.
        /// </summary>
        public List<IEmbeddedDataSpecification>? EmbeddedDataSpecifications { get; set; }

        /// <summary>
        /// Data type of the min und max
        /// </summary>
        public DataTypeDefXsd ValueType { get; set; }

        /// <summary>
        /// The minimum value of the range.
        /// </summary>
        /// <remarks>
        /// If the min value is missing, then the value is assumed to be negative infinite.
        /// </remarks>
        public string? Min { get; set; }

        /// <summary>
        /// The maximum value of the range.
        /// </summary>
        /// <remarks>
        /// If the max value is missing, then the value is assumed to be positive infinite.
        /// </remarks>
        public string? Max { get; set; }

        #region Parent
        [JsonIgnore]
        public IClass Parent { get; set; }
        #endregion

        #region TimeStamp
        [JsonIgnore]
        public DateTime TimeStampCreate { get; set; }
        [JsonIgnore]
        public DateTime TimeStamp { get; set; }
        [JsonIgnore]
        public DateTime TimeStampTree { get; set; }

        [JsonIgnore]
        private DiaryDataDef _diaryData = new DiaryDataDef();

        [JsonIgnore]
        public DiaryDataDef DiaryData { get { return _diaryData; } }

        #endregion

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IExtension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<IExtension>();
        }

        /// <summary>
        /// Iterate over DisplayName, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringNameType> OverDisplayNameOrEmpty()
        {
            return DisplayName
                ?? System.Linq.Enumerable.Empty<ILangStringNameType>();
        }

        /// <summary>
        /// Iterate over Description, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringTextType> OverDescriptionOrEmpty()
        {
            return Description
                ?? System.Linq.Enumerable.Empty<ILangStringTextType>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IReference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<IReference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IQualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<IQualifier>();
        }

        /// <summary>
        /// Iterate over EmbeddedDataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IEmbeddedDataSpecification> OverEmbeddedDataSpecificationsOrEmpty()
        {
            return EmbeddedDataSpecifications
                ?? System.Linq.Enumerable.Empty<IEmbeddedDataSpecification>();
        }

        /// <summary>
        /// Return the <see cref="IReferable.Category" /> or the default value
        /// if it has not been set.
        /// </summary>
        public string CategoryOrDefault()
        {
            string result = Category ?? "VARIABLE";

#if DEBUG
            if (!Constants.ValidCategoriesForDataElement.Contains(
                    result))
            {
                throw new System.InvalidOperationException(
                    $"Unexpected default category: {result}"
                );
            }
#endif

            return result;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitRange(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitRange(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformRange(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformRange(this, context);
        }

        public Range(
            DataTypeDefXsd valueType,
            List<IExtension>? extensions = null,
            string? category = null,
            string? idShort = null,
            List<ILangStringNameType>? displayName = null,
            List<ILangStringTextType>? description = null,
            IReference? semanticId = null,
            List<IReference>? supplementalSemanticIds = null,
            List<IQualifier>? qualifiers = null,
            List<IEmbeddedDataSpecification>? embeddedDataSpecifications = null,
            string? min = null,
            string? max = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            EmbeddedDataSpecifications = embeddedDataSpecifications;
            ValueType = valueType;
            Min = min;
            Max = max;
        }
    }

    /// <summary>
    /// A reference element is a data element that defines a logical reference to another
    /// element within the same or another AAS or a reference to an external object or
    /// entity.
    /// </summary>
    public interface IReferenceElement : IDataElement
    {
        /// <summary>
        /// Global reference to an external object or entity or a logical reference to
        /// another element within the same or another AAS (i.e. a model reference to
        /// a Referable).
        /// </summary>
        public IReference? Value { get; set; }
    }

    /// <summary>
    /// A reference element is a data element that defines a logical reference to another
    /// element within the same or another AAS or a reference to an external object or
    /// entity.
    /// </summary>
    public class ReferenceElement : IReferenceElement
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<IExtension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        public List<ILangStringNameType>? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The description can be provided in several languages.
        /// </para>
        /// <para>
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        /// </para>
        /// <para>
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </para>
        /// </remarks>
        public List<ILangStringTextType>? Description { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<IReference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Constraints:
        /// </para>
        /// <ul>
        ///   <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///   </li>
        /// </ul>
        /// </remarks>
        public List<IQualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Embedded data specification.
        /// </summary>
        public List<IEmbeddedDataSpecification>? EmbeddedDataSpecifications { get; set; }

        /// <summary>
        /// Global reference to an external object or entity or a logical reference to
        /// another element within the same or another AAS (i.e. a model reference to
        /// a Referable).
        /// </summary>
        public IReference? Value { get; set; }

        #region Parent
        [JsonIgnore]
        public IClass Parent { get; set; }
        #endregion

        #region TimeStamp
        [JsonIgnore]
        public DateTime TimeStampCreate { get; set; }
        [JsonIgnore]
        public DateTime TimeStamp { get; set; }
        [JsonIgnore]
        public DateTime TimeStampTree { get; set; }

        [JsonIgnore]
        private DiaryDataDef _diaryData = new DiaryDataDef();

        [JsonIgnore]
        public DiaryDataDef DiaryData { get { return _diaryData; } }

        #endregion

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IExtension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<IExtension>();
        }

        /// <summary>
        /// Iterate over DisplayName, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringNameType> OverDisplayNameOrEmpty()
        {
            return DisplayName
                ?? System.Linq.Enumerable.Empty<ILangStringNameType>();
        }

        /// <summary>
        /// Iterate over Description, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringTextType> OverDescriptionOrEmpty()
        {
            return Description
                ?? System.Linq.Enumerable.Empty<ILangStringTextType>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IReference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<IReference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IQualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<IQualifier>();
        }

        /// <summary>
        /// Iterate over EmbeddedDataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IEmbeddedDataSpecification> OverEmbeddedDataSpecificationsOrEmpty()
        {
            return EmbeddedDataSpecifications
                ?? System.Linq.Enumerable.Empty<IEmbeddedDataSpecification>();
        }

        /// <summary>
        /// Return the <see cref="IReferable.Category" /> or the default value
        /// if it has not been set.
        /// </summary>
        public string CategoryOrDefault()
        {
            string result = Category ?? "VARIABLE";

#if DEBUG
            if (!Constants.ValidCategoriesForDataElement.Contains(
                    result))
            {
                throw new System.InvalidOperationException(
                    $"Unexpected default category: {result}"
                );
            }
#endif

            return result;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (Value != null)
            {
                yield return Value;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Value != null)
            {
                yield return Value;

                // Recurse
                foreach (var anItem in Value.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitReferenceElement(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitReferenceElement(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformReferenceElement(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformReferenceElement(this, context);
        }

        public ReferenceElement(
            List<IExtension>? extensions = null,
            string? category = null,
            string? idShort = null,
            List<ILangStringNameType>? displayName = null,
            List<ILangStringTextType>? description = null,
            IReference? semanticId = null,
            List<IReference>? supplementalSemanticIds = null,
            List<IQualifier>? qualifiers = null,
            List<IEmbeddedDataSpecification>? embeddedDataSpecifications = null,
            IReference? value = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            EmbeddedDataSpecifications = embeddedDataSpecifications;
            Value = value;
        }
    }

    /// <summary>
    /// A <see cref="Aas.Blob" /> is a data element that represents a file that is contained with its
    /// source code in the value attribute.
    /// </summary>
    public interface IBlob : IDataElement
    {
        /// <summary>
        /// The value of the <see cref="Aas.Blob" /> instance of a blob data element.
        /// </summary>
        /// <remarks>
        /// In contrast to the file property the file content is stored directly as value
        /// in the <see cref="Aas.Blob" /> data element.
        /// </remarks>
        public byte[]? Value { get; set; }

        /// <summary>
        /// Content type of the content of the <see cref="Aas.Blob" />.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The content type (MIME type) states which file extensions the file can have.
        /// </para>
        /// <para>
        /// Valid values are content types like e.g. <c>application/json</c>, <c>application/xls</c>,
        /// <c>image/jpg</c>.
        /// </para>
        /// <para>
        /// The allowed values are defined as in RFC2046.
        /// </para>
        /// </remarks>
        public string ContentType { get; set; }
    }

    /// <summary>
    /// A <see cref="Aas.Blob" /> is a data element that represents a file that is contained with its
    /// source code in the value attribute.
    /// </summary>
    public class Blob : IBlob
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<IExtension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        public List<ILangStringNameType>? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The description can be provided in several languages.
        /// </para>
        /// <para>
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        /// </para>
        /// <para>
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </para>
        /// </remarks>
        public List<ILangStringTextType>? Description { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<IReference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Constraints:
        /// </para>
        /// <ul>
        ///   <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///   </li>
        /// </ul>
        /// </remarks>
        public List<IQualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Embedded data specification.
        /// </summary>
        public List<IEmbeddedDataSpecification>? EmbeddedDataSpecifications { get; set; }

        /// <summary>
        /// The value of the <see cref="Aas.Blob" /> instance of a blob data element.
        /// </summary>
        /// <remarks>
        /// In contrast to the file property the file content is stored directly as value
        /// in the <see cref="Aas.Blob" /> data element.
        /// </remarks>
        public byte[]? Value { get; set; }

        /// <summary>
        /// Content type of the content of the <see cref="Aas.Blob" />.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The content type (MIME type) states which file extensions the file can have.
        /// </para>
        /// <para>
        /// Valid values are content types like e.g. <c>application/json</c>, <c>application/xls</c>,
        /// <c>image/jpg</c>.
        /// </para>
        /// <para>
        /// The allowed values are defined as in RFC2046.
        /// </para>
        /// </remarks>
        public string ContentType { get; set; }
        #region Parent
        [JsonIgnore]
        public IClass Parent { get; set; }
        #endregion

        #region TimeStamp
        [JsonIgnore]
        public DateTime TimeStampCreate { get; set; }
        [JsonIgnore]
        public DateTime TimeStamp { get; set; }
        [JsonIgnore]
        public DateTime TimeStampTree { get; set; }

        [JsonIgnore]
        private DiaryDataDef _diaryData = new DiaryDataDef();

        [JsonIgnore]
        public DiaryDataDef DiaryData { get { return _diaryData; } }

        #endregion

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IExtension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<IExtension>();
        }

        /// <summary>
        /// Iterate over DisplayName, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringNameType> OverDisplayNameOrEmpty()
        {
            return DisplayName
                ?? System.Linq.Enumerable.Empty<ILangStringNameType>();
        }

        /// <summary>
        /// Iterate over Description, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringTextType> OverDescriptionOrEmpty()
        {
            return Description
                ?? System.Linq.Enumerable.Empty<ILangStringTextType>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IReference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<IReference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IQualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<IQualifier>();
        }

        /// <summary>
        /// Iterate over EmbeddedDataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IEmbeddedDataSpecification> OverEmbeddedDataSpecificationsOrEmpty()
        {
            return EmbeddedDataSpecifications
                ?? System.Linq.Enumerable.Empty<IEmbeddedDataSpecification>();
        }

        /// <summary>
        /// Return the <see cref="IReferable.Category" /> or the default value
        /// if it has not been set.
        /// </summary>
        public string CategoryOrDefault()
        {
            string result = Category ?? "VARIABLE";

#if DEBUG
            if (!Constants.ValidCategoriesForDataElement.Contains(
                    result))
            {
                throw new System.InvalidOperationException(
                    $"Unexpected default category: {result}"
                );
            }
#endif

            return result;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitBlob(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitBlob(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformBlob(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformBlob(this, context);
        }

        public Blob(
            string contentType,
            List<IExtension>? extensions = null,
            string? category = null,
            string? idShort = null,
            List<ILangStringNameType>? displayName = null,
            List<ILangStringTextType>? description = null,
            IReference? semanticId = null,
            List<IReference>? supplementalSemanticIds = null,
            List<IQualifier>? qualifiers = null,
            List<IEmbeddedDataSpecification>? embeddedDataSpecifications = null,
            byte[]? value = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            EmbeddedDataSpecifications = embeddedDataSpecifications;
            ContentType = contentType;
            Value = value;
        }
    }

    /// <summary>
    /// A File is a data element that represents an address to a file (a locator).
    /// </summary>
    /// <remarks>
    /// The value is an URI that can represent an absolute or relative path.
    /// </remarks>
    public interface IFile : IDataElement
    {
        /// <summary>
        /// Path and name of the referenced file (with file extension).
        /// </summary>
        /// <remarks>
        /// The path can be absolute or relative.
        /// </remarks>
        public string? Value { get; set; }

        /// <summary>
        /// Content type of the content of the file.
        /// </summary>
        /// <remarks>
        /// The content type states which file extensions the file can have.
        /// </remarks>
        public string ContentType { get; set; }
    }

    /// <summary>
    /// A File is a data element that represents an address to a file (a locator).
    /// </summary>
    /// <remarks>
    /// The value is an URI that can represent an absolute or relative path.
    /// </remarks>
    public class File : IFile
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<IExtension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        public List<ILangStringNameType>? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The description can be provided in several languages.
        /// </para>
        /// <para>
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        /// </para>
        /// <para>
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </para>
        /// </remarks>
        public List<ILangStringTextType>? Description { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<IReference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Constraints:
        /// </para>
        /// <ul>
        ///   <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///   </li>
        /// </ul>
        /// </remarks>
        public List<IQualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Embedded data specification.
        /// </summary>
        public List<IEmbeddedDataSpecification>? EmbeddedDataSpecifications { get; set; }

        /// <summary>
        /// Path and name of the referenced file (with file extension).
        /// </summary>
        /// <remarks>
        /// The path can be absolute or relative.
        /// </remarks>
        public string? Value { get; set; }

        /// <summary>
        /// Content type of the content of the file.
        /// </summary>
        /// <remarks>
        /// The content type states which file extensions the file can have.
        /// </remarks>
        public string ContentType { get; set; }
        #region Parent
        [JsonIgnore]
        public IClass Parent { get; set; }
        #endregion

        #region TimeStamp
        [JsonIgnore]
        public DateTime TimeStampCreate { get; set; }
        [JsonIgnore]
        public DateTime TimeStamp { get; set; }
        [JsonIgnore]
        public DateTime TimeStampTree { get; set; }

        [JsonIgnore]
        private DiaryDataDef _diaryData = new DiaryDataDef();

        [JsonIgnore]
        public DiaryDataDef DiaryData { get { return _diaryData; } }

        #endregion

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IExtension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<IExtension>();
        }

        /// <summary>
        /// Iterate over DisplayName, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringNameType> OverDisplayNameOrEmpty()
        {
            return DisplayName
                ?? System.Linq.Enumerable.Empty<ILangStringNameType>();
        }

        /// <summary>
        /// Iterate over Description, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringTextType> OverDescriptionOrEmpty()
        {
            return Description
                ?? System.Linq.Enumerable.Empty<ILangStringTextType>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IReference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<IReference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IQualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<IQualifier>();
        }

        /// <summary>
        /// Iterate over EmbeddedDataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IEmbeddedDataSpecification> OverEmbeddedDataSpecificationsOrEmpty()
        {
            return EmbeddedDataSpecifications
                ?? System.Linq.Enumerable.Empty<IEmbeddedDataSpecification>();
        }

        /// <summary>
        /// Return the <see cref="IReferable.Category" /> or the default value
        /// if it has not been set.
        /// </summary>
        public string CategoryOrDefault()
        {
            string result = Category ?? "VARIABLE";

#if DEBUG
            if (!Constants.ValidCategoriesForDataElement.Contains(
                    result))
            {
                throw new System.InvalidOperationException(
                    $"Unexpected default category: {result}"
                );
            }
#endif

            return result;
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitFile(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitFile(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformFile(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformFile(this, context);
        }

        public File(
            string contentType,
            List<IExtension>? extensions = null,
            string? category = null,
            string? idShort = null,
            List<ILangStringNameType>? displayName = null,
            List<ILangStringTextType>? description = null,
            IReference? semanticId = null,
            List<IReference>? supplementalSemanticIds = null,
            List<IQualifier>? qualifiers = null,
            List<IEmbeddedDataSpecification>? embeddedDataSpecifications = null,
            string? value = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            EmbeddedDataSpecifications = embeddedDataSpecifications;
            ContentType = contentType;
            Value = value;
        }
    }

    /// <summary>
    /// An annotated relationship element is a relationship element that can be annotated
    /// with additional data elements.
    /// </summary>
    public interface IAnnotatedRelationshipElement : IRelationshipElement
    {
        /// <summary>
        /// A data element that represents an annotation that holds for the relationship
        /// between the two elements
        /// </summary>
        public List<IDataElement>? Annotations { get; set; }

        /// <summary>
        /// Iterate over Annotations, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IDataElement> OverAnnotationsOrEmpty();
    }

    /// <summary>
    /// An annotated relationship element is a relationship element that can be annotated
    /// with additional data elements.
    /// </summary>
    public class AnnotatedRelationshipElement : IAnnotatedRelationshipElement
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<IExtension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        public List<ILangStringNameType>? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The description can be provided in several languages.
        /// </para>
        /// <para>
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        /// </para>
        /// <para>
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </para>
        /// </remarks>
        public List<ILangStringTextType>? Description { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<IReference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Constraints:
        /// </para>
        /// <ul>
        ///   <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///   </li>
        /// </ul>
        /// </remarks>
        public List<IQualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Embedded data specification.
        /// </summary>
        public List<IEmbeddedDataSpecification>? EmbeddedDataSpecifications { get; set; }

        /// <summary>
        /// Reference to the first element in the relationship taking the role of the subject.
        /// </summary>
        public IReference First { get; set; }

        /// <summary>
        /// Reference to the second element in the relationship taking the role of the object.
        /// </summary>
        public IReference Second { get; set; }

        /// <summary>
        /// A data element that represents an annotation that holds for the relationship
        /// between the two elements
        /// </summary>
        public List<IDataElement>? Annotations { get; set; }
        #region Parent
        [JsonIgnore]
        public IClass Parent { get; set; }
        #endregion

        #region TimeStamp
        [JsonIgnore]
        public DateTime TimeStampCreate { get; set; }
        [JsonIgnore]
        public DateTime TimeStamp { get; set; }
        [JsonIgnore]
        public DateTime TimeStampTree { get; set; }

        [JsonIgnore]
        private DiaryDataDef _diaryData = new DiaryDataDef();

        [JsonIgnore]
        public DiaryDataDef DiaryData { get { return _diaryData; } }

        #endregion

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IExtension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<IExtension>();
        }

        /// <summary>
        /// Iterate over DisplayName, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringNameType> OverDisplayNameOrEmpty()
        {
            return DisplayName
                ?? System.Linq.Enumerable.Empty<ILangStringNameType>();
        }

        /// <summary>
        /// Iterate over Description, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringTextType> OverDescriptionOrEmpty()
        {
            return Description
                ?? System.Linq.Enumerable.Empty<ILangStringTextType>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IReference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<IReference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IQualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<IQualifier>();
        }

        /// <summary>
        /// Iterate over EmbeddedDataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IEmbeddedDataSpecification> OverEmbeddedDataSpecificationsOrEmpty()
        {
            return EmbeddedDataSpecifications
                ?? System.Linq.Enumerable.Empty<IEmbeddedDataSpecification>();
        }

        /// <summary>
        /// Iterate over Annotations, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IDataElement> OverAnnotationsOrEmpty()
        {
            return Annotations
                ?? System.Linq.Enumerable.Empty<IDataElement>();
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;
                }
            }

            yield return First;

            yield return Second;

            if (Annotations != null)
            {
                foreach (var anItem in Annotations)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            yield return First;

            // Recurse
            foreach (var anItem in First.Descend())
            {
                yield return anItem;
            }

            yield return Second;

            // Recurse
            foreach (var anItem in Second.Descend())
            {
                yield return anItem;
            }

            if (Annotations != null)
            {
                foreach (var anItem in Annotations)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitAnnotatedRelationshipElement(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitAnnotatedRelationshipElement(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformAnnotatedRelationshipElement(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformAnnotatedRelationshipElement(this, context);
        }

        public AnnotatedRelationshipElement(
            IReference first,
            IReference second,
            List<IExtension>? extensions = null,
            string? category = null,
            string? idShort = null,
            List<ILangStringNameType>? displayName = null,
            List<ILangStringTextType>? description = null,
            IReference? semanticId = null,
            List<IReference>? supplementalSemanticIds = null,
            List<IQualifier>? qualifiers = null,
            List<IEmbeddedDataSpecification>? embeddedDataSpecifications = null,
            List<IDataElement>? annotations = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            EmbeddedDataSpecifications = embeddedDataSpecifications;
            First = first;
            Second = second;
            Annotations = annotations;
        }
    }

    /// <summary>
    /// An entity is a submodel element that is used to model entities.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Constraint AASd-014:
    ///     Either the attribute <see cref="Aas.Entity.GlobalAssetId" /> or <see cref="Aas.Entity.SpecificAssetIds" />
    ///     of an <see cref="Aas.Entity" /> must be set if <see cref="Aas.Entity.EntityType" /> is set to
    ///     <see cref="Aas.EntityType.SelfManagedEntity" />. They are not existing otherwise.
    ///   </li>
    /// </ul>
    /// </remarks>
    public interface IEntity : ISubmodelElement
    {
        /// <summary>
        /// Describes statements applicable to the entity by a set of submodel elements,
        /// typically with a qualified value.
        /// </summary>
        public List<ISubmodelElement>? Statements { get; set; }

        /// <summary>
        /// Describes whether the entity is a co-managed entity or a self-managed entity.
        /// </summary>
        public EntityType EntityType { get; set; }

        /// <summary>
        /// Global identifier of the asset the entity is representing.
        /// </summary>
        /// <remarks>
        /// This is a global reference.
        /// </remarks>
        public string? GlobalAssetId { get; set; }

        /// <summary>
        /// Reference to a specific asset ID representing a supplementary identifier
        /// of the asset represented by the Asset Administration Shell.
        /// </summary>
        public List<ISpecificAssetId>? SpecificAssetIds { get; set; }

        /// <summary>
        /// Iterate over Statements, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ISubmodelElement> OverStatementsOrEmpty();

        /// <summary>
        /// Iterate over SpecificAssetIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ISpecificAssetId> OverSpecificAssetIdsOrEmpty();
    }

    /// <summary>
    /// An entity is a submodel element that is used to model entities.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Constraint AASd-014:
    ///     Either the attribute <see cref="Aas.Entity.GlobalAssetId" /> or <see cref="Aas.Entity.SpecificAssetIds" />
    ///     of an <see cref="Aas.Entity" /> must be set if <see cref="Aas.Entity.EntityType" /> is set to
    ///     <see cref="Aas.EntityType.SelfManagedEntity" />. They are not existing otherwise.
    ///   </li>
    /// </ul>
    /// </remarks>
    public class Entity : IEntity
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<IExtension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        public List<ILangStringNameType>? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The description can be provided in several languages.
        /// </para>
        /// <para>
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        /// </para>
        /// <para>
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </para>
        /// </remarks>
        public List<ILangStringTextType>? Description { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<IReference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Constraints:
        /// </para>
        /// <ul>
        ///   <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///   </li>
        /// </ul>
        /// </remarks>
        public List<IQualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Embedded data specification.
        /// </summary>
        public List<IEmbeddedDataSpecification>? EmbeddedDataSpecifications { get; set; }

        /// <summary>
        /// Describes statements applicable to the entity by a set of submodel elements,
        /// typically with a qualified value.
        /// </summary>
        public List<ISubmodelElement>? Statements { get; set; }

        /// <summary>
        /// Describes whether the entity is a co-managed entity or a self-managed entity.
        /// </summary>
        public EntityType EntityType { get; set; }

        /// <summary>
        /// Global identifier of the asset the entity is representing.
        /// </summary>
        /// <remarks>
        /// This is a global reference.
        /// </remarks>
        public string? GlobalAssetId { get; set; }

        /// <summary>
        /// Reference to a specific asset ID representing a supplementary identifier
        /// of the asset represented by the Asset Administration Shell.
        /// </summary>
        public List<ISpecificAssetId>? SpecificAssetIds { get; set; }
        #region Parent
        [JsonIgnore]
        public IClass Parent { get; set; }
        #endregion

        #region TimeStamp
        [JsonIgnore]
        public DateTime TimeStampCreate { get; set; }
        [JsonIgnore]
        public DateTime TimeStamp { get; set; }
        [JsonIgnore]
        public DateTime TimeStampTree { get; set; }

        [JsonIgnore]
        private DiaryDataDef _diaryData = new DiaryDataDef();

        [JsonIgnore]
        public DiaryDataDef DiaryData { get { return _diaryData; } }

        #endregion

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IExtension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<IExtension>();
        }

        /// <summary>
        /// Iterate over DisplayName, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringNameType> OverDisplayNameOrEmpty()
        {
            return DisplayName
                ?? System.Linq.Enumerable.Empty<ILangStringNameType>();
        }

        /// <summary>
        /// Iterate over Description, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringTextType> OverDescriptionOrEmpty()
        {
            return Description
                ?? System.Linq.Enumerable.Empty<ILangStringTextType>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IReference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<IReference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IQualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<IQualifier>();
        }

        /// <summary>
        /// Iterate over EmbeddedDataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IEmbeddedDataSpecification> OverEmbeddedDataSpecificationsOrEmpty()
        {
            return EmbeddedDataSpecifications
                ?? System.Linq.Enumerable.Empty<IEmbeddedDataSpecification>();
        }

        /// <summary>
        /// Iterate over Statements, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ISubmodelElement> OverStatementsOrEmpty()
        {
            return Statements
                ?? System.Linq.Enumerable.Empty<ISubmodelElement>();
        }

        /// <summary>
        /// Iterate over SpecificAssetIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ISpecificAssetId> OverSpecificAssetIdsOrEmpty()
        {
            return SpecificAssetIds
                ?? System.Linq.Enumerable.Empty<ISpecificAssetId>();
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (Statements != null)
            {
                foreach (var anItem in Statements)
                {
                    yield return anItem;
                }
            }

            if (SpecificAssetIds != null)
            {
                foreach (var anItem in SpecificAssetIds)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Statements != null)
            {
                foreach (var anItem in Statements)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (SpecificAssetIds != null)
            {
                foreach (var anItem in SpecificAssetIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitEntity(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitEntity(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformEntity(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformEntity(this, context);
        }

        public Entity(
            EntityType entityType,
            List<IExtension>? extensions = null,
            string? category = null,
            string? idShort = null,
            List<ILangStringNameType>? displayName = null,
            List<ILangStringTextType>? description = null,
            IReference? semanticId = null,
            List<IReference>? supplementalSemanticIds = null,
            List<IQualifier>? qualifiers = null,
            List<IEmbeddedDataSpecification>? embeddedDataSpecifications = null,
            List<ISubmodelElement>? statements = null,
            string? globalAssetId = null,
            List<ISpecificAssetId>? specificAssetIds = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            EmbeddedDataSpecifications = embeddedDataSpecifications;
            Statements = statements;
            EntityType = entityType;
            GlobalAssetId = globalAssetId;
            SpecificAssetIds = specificAssetIds;
        }
    }

    /// <summary>
    /// Enumeration for denoting whether an entity is a self-managed entity or a co-managed
    /// entity.
    /// </summary>
    public enum EntityType
    {
        /// <summary>
        /// For co-managed entities there is no separate AAS. Co-managed entities need to be
        /// part of a self-managed entity.
        /// </summary>
        [EnumMember(Value = "CoManagedEntity")]
        CoManagedEntity,

        /// <summary>
        /// Self-Managed Entities have their own AAS but can be part of the bill of material of
        /// a composite self-managed entity.
        /// </summary>
        /// <remarks>
        /// The asset of an I4.0 Component is a self-managed entity per definition.
        /// </remarks>
        [EnumMember(Value = "SelfManagedEntity")]
        SelfManagedEntity
    }

    /// <summary>
    /// Direction
    /// </summary>
    /// <remarks>
    /// This element is experimental and therefore may be subject to change or may be
    /// removed completely in future versions of the meta-model.
    /// </remarks>
    public enum Direction
    {
        /// <summary>
        /// Input direction.
        /// </summary>
        [EnumMember(Value = "input")]
        Input,

        /// <summary>
        /// Output direction
        /// </summary>
        [EnumMember(Value = "output")]
        Output
    }

    /// <summary>
    /// State of an event
    /// </summary>
    /// <remarks>
    /// This element is experimental and therefore may be subject to change or may be
    /// removed completely in future versions of the meta-model.
    /// </remarks>
    public enum StateOfEvent
    {
        /// <summary>
        /// Event is on
        /// </summary>
        [EnumMember(Value = "on")]
        On,

        /// <summary>
        /// Event is off.
        /// </summary>
        [EnumMember(Value = "off")]
        Off
    }

    /// <summary>
    /// Defines the necessary information of an event instance sent out or received.
    /// </summary>
    /// <remarks>
    /// This element is experimental and therefore may be subject to change or may be
    /// removed completely in future versions of the meta-model.
    /// </remarks>
    public interface IEventPayload : IClass
    {
        /// <summary>
        /// Reference to the source event element, including identification of
        /// <see cref="Aas.AssetAdministrationShell" />, <see cref="Aas.Submodel" />,
        /// <see cref="Aas.ISubmodelElement" />'s.
        /// </summary>
        public IReference Source { get; set; }

        /// <summary>
        /// <see cref="Aas.IHasSemantics.SemanticId" /> of the source event element, if available
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? SourceSemanticId { get; set; }

        /// <summary>
        /// Reference to the referable, which defines the scope of the event.
        /// </summary>
        /// <remarks>
        /// Can be <see cref="Aas.AssetAdministrationShell" />, <see cref="Aas.Submodel" /> or
        /// <see cref="Aas.ISubmodelElement" />.
        /// </remarks>
        public IReference ObservableReference { get; set; }

        /// <summary>
        /// <see cref="Aas.IHasSemantics.SemanticId" /> of the referable which defines the scope of
        /// the event, if available.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? ObservableSemanticId { get; set; }

        /// <summary>
        /// Information for the outer message infrastructure for scheduling the event to
        /// the respective communication channel.
        /// </summary>
        public string? Topic { get; set; }

        /// <summary>
        /// Subject, who/which initiated the creation.
        /// </summary>
        /// <remarks>
        /// This is an external reference.
        /// </remarks>
        public IReference? SubjectId { get; set; }

        /// <summary>
        /// Timestamp in UTC, when this event was triggered.
        /// </summary>
        public string TimeStamp { get; set; }

        /// <summary>
        /// Event specific payload.
        /// </summary>
        public byte[]? Payload { get; set; }
    }

    /// <summary>
    /// Defines the necessary information of an event instance sent out or received.
    /// </summary>
    /// <remarks>
    /// This element is experimental and therefore may be subject to change or may be
    /// removed completely in future versions of the meta-model.
    /// </remarks>
    public class EventPayload : IEventPayload
    {
        /// <summary>
        /// Reference to the source event element, including identification of
        /// <see cref="Aas.AssetAdministrationShell" />, <see cref="Aas.Submodel" />,
        /// <see cref="Aas.ISubmodelElement" />'s.
        /// </summary>
        public IReference Source { get; set; }

        /// <summary>
        /// <see cref="Aas.IHasSemantics.SemanticId" /> of the source event element, if available
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? SourceSemanticId { get; set; }

        /// <summary>
        /// Reference to the referable, which defines the scope of the event.
        /// </summary>
        /// <remarks>
        /// Can be <see cref="Aas.AssetAdministrationShell" />, <see cref="Aas.Submodel" /> or
        /// <see cref="Aas.ISubmodelElement" />.
        /// </remarks>
        public IReference ObservableReference { get; set; }

        /// <summary>
        /// <see cref="Aas.IHasSemantics.SemanticId" /> of the referable which defines the scope of
        /// the event, if available.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? ObservableSemanticId { get; set; }

        /// <summary>
        /// Information for the outer message infrastructure for scheduling the event to
        /// the respective communication channel.
        /// </summary>
        public string? Topic { get; set; }

        /// <summary>
        /// Subject, who/which initiated the creation.
        /// </summary>
        /// <remarks>
        /// This is an external reference.
        /// </remarks>
        public IReference? SubjectId { get; set; }

        /// <summary>
        /// Timestamp in UTC, when this event was triggered.
        /// </summary>
        public string TimeStamp { get; set; }

        /// <summary>
        /// Event specific payload.
        /// </summary>
        public byte[]? Payload { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            yield return Source;

            if (SourceSemanticId != null)
            {
                yield return SourceSemanticId;
            }

            yield return ObservableReference;

            if (ObservableSemanticId != null)
            {
                yield return ObservableSemanticId;
            }

            if (SubjectId != null)
            {
                yield return SubjectId;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            yield return Source;

            // Recurse
            foreach (var anItem in Source.Descend())
            {
                yield return anItem;
            }

            if (SourceSemanticId != null)
            {
                yield return SourceSemanticId;

                // Recurse
                foreach (var anItem in SourceSemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            yield return ObservableReference;

            // Recurse
            foreach (var anItem in ObservableReference.Descend())
            {
                yield return anItem;
            }

            if (ObservableSemanticId != null)
            {
                yield return ObservableSemanticId;

                // Recurse
                foreach (var anItem in ObservableSemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SubjectId != null)
            {
                yield return SubjectId;

                // Recurse
                foreach (var anItem in SubjectId.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitEventPayload(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitEventPayload(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformEventPayload(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformEventPayload(this, context);
        }

        public EventPayload(
            IReference source,
            IReference observableReference,
            string timeStamp,
            IReference? sourceSemanticId = null,
            IReference? observableSemanticId = null,
            string? topic = null,
            IReference? subjectId = null,
            byte[]? payload = null)
        {
            Source = source;
            ObservableReference = observableReference;
            TimeStamp = timeStamp;
            SourceSemanticId = sourceSemanticId;
            ObservableSemanticId = observableSemanticId;
            Topic = topic;
            SubjectId = subjectId;
            Payload = payload;
        }
    }

    /// <summary>
    /// An event element.
    /// </summary>
    /// <remarks>
    /// This element is experimental and therefore may be subject to change or may be
    /// removed completely in future versions of the meta-model.
    /// </remarks>
    public interface IEventElement : ISubmodelElement
    {
        // Intentionally empty.
    }

    /// <summary>
    /// A basic event element.
    /// </summary>
    /// <remarks>
    /// This element is experimental and therefore may be subject to change or may be
    /// removed completely in future versions of the meta-model.
    /// </remarks>
    public interface IBasicEventElement : IEventElement
    {
        /// <summary>
        /// Reference to the <see cref="Aas.IReferable" />, which defines the scope of the event.
        /// Can be <see cref="Aas.AssetAdministrationShell" />, <see cref="Aas.Submodel" />, or
        /// <see cref="Aas.ISubmodelElement" />.
        /// </summary>
        /// <remarks>
        /// Reference to a referable, e.g., a data element or
        /// a submodel, that is being observed.
        /// </remarks>
        public IReference Observed { get; set; }

        /// <summary>
        /// Direction of event.
        /// </summary>
        /// <remarks>
        /// Can be <c>{ Input, Output }</c>.
        /// </remarks>
        public Direction Direction { get; set; }

        /// <summary>
        /// State of event.
        /// </summary>
        /// <remarks>
        /// Can be <c>{ On, Off }</c>.
        /// </remarks>
        public StateOfEvent State { get; set; }

        /// <summary>
        /// Information for the outer message infrastructure for scheduling the event to the
        /// respective communication channel.
        /// </summary>
        public string? MessageTopic { get; set; }

        /// <summary>
        /// Information, which outer message infrastructure shall handle messages for
        /// the <see cref="Aas.IEventElement" />. Refers to a <see cref="Aas.Submodel" />,
        /// <see cref="Aas.SubmodelElementList" />, <see cref="Aas.SubmodelElementCollection" /> or
        /// <see cref="Aas.Entity" />, which contains <see cref="Aas.IDataElement" />'s describing
        /// the proprietary specification for the message broker.
        /// </summary>
        /// <remarks>
        /// For different message infrastructure, e.g., OPC UA or MQTT or AMQP, this
        /// proprietary specification could be standardized by having respective Submodels.
        /// </remarks>
        public IReference? MessageBroker { get; set; }

        /// <summary>
        /// Timestamp in UTC, when the last event was received (input direction) or sent
        /// (output direction).
        /// </summary>
        public string? LastUpdate { get; set; }

        /// <summary>
        /// For input direction, reports on the maximum frequency, the software entity behind
        /// the respective Referable can handle input events.
        /// </summary>
        /// <remarks>
        /// <para>
        /// For output events, specifies the maximum frequency of outputting this event to
        /// an outer infrastructure.
        /// </para>
        /// <para>
        /// Might be not specified, that is, there is no minimum interval.
        /// </para>
        /// </remarks>
        public string? MinInterval { get; set; }

        /// <summary>
        /// For input direction: not applicable.
        /// </summary>
        /// <remarks>
        /// <para>
        /// For output direction: maximum interval in time, the respective Referable shall send
        /// an update of the status of the event, even if no other trigger condition for
        /// the event was not met.
        /// </para>
        /// <para>
        /// Might be not specified, that is, there is no maximum interval
        /// </para>
        /// </remarks>
        public string? MaxInterval { get; set; }
    }

    /// <summary>
    /// A basic event element.
    /// </summary>
    /// <remarks>
    /// This element is experimental and therefore may be subject to change or may be
    /// removed completely in future versions of the meta-model.
    /// </remarks>
    public class BasicEventElement : IBasicEventElement
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<IExtension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        public List<ILangStringNameType>? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The description can be provided in several languages.
        /// </para>
        /// <para>
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        /// </para>
        /// <para>
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </para>
        /// </remarks>
        public List<ILangStringTextType>? Description { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<IReference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Constraints:
        /// </para>
        /// <ul>
        ///   <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///   </li>
        /// </ul>
        /// </remarks>
        public List<IQualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Embedded data specification.
        /// </summary>
        public List<IEmbeddedDataSpecification>? EmbeddedDataSpecifications { get; set; }

        /// <summary>
        /// Reference to the <see cref="Aas.IReferable" />, which defines the scope of the event.
        /// Can be <see cref="Aas.AssetAdministrationShell" />, <see cref="Aas.Submodel" />, or
        /// <see cref="Aas.ISubmodelElement" />.
        /// </summary>
        /// <remarks>
        /// Reference to a referable, e.g., a data element or
        /// a submodel, that is being observed.
        /// </remarks>
        public IReference Observed { get; set; }

        /// <summary>
        /// Direction of event.
        /// </summary>
        /// <remarks>
        /// Can be <c>{ Input, Output }</c>.
        /// </remarks>
        public Direction Direction { get; set; }

        /// <summary>
        /// State of event.
        /// </summary>
        /// <remarks>
        /// Can be <c>{ On, Off }</c>.
        /// </remarks>
        public StateOfEvent State { get; set; }

        /// <summary>
        /// Information for the outer message infrastructure for scheduling the event to the
        /// respective communication channel.
        /// </summary>
        public string? MessageTopic { get; set; }

        /// <summary>
        /// Information, which outer message infrastructure shall handle messages for
        /// the <see cref="Aas.IEventElement" />. Refers to a <see cref="Aas.Submodel" />,
        /// <see cref="Aas.SubmodelElementList" />, <see cref="Aas.SubmodelElementCollection" /> or
        /// <see cref="Aas.Entity" />, which contains <see cref="Aas.IDataElement" />'s describing
        /// the proprietary specification for the message broker.
        /// </summary>
        /// <remarks>
        /// For different message infrastructure, e.g., OPC UA or MQTT or AMQP, this
        /// proprietary specification could be standardized by having respective Submodels.
        /// </remarks>
        public IReference? MessageBroker { get; set; }

        /// <summary>
        /// Timestamp in UTC, when the last event was received (input direction) or sent
        /// (output direction).
        /// </summary>
        public string? LastUpdate { get; set; }

        /// <summary>
        /// For input direction, reports on the maximum frequency, the software entity behind
        /// the respective Referable can handle input events.
        /// </summary>
        /// <remarks>
        /// <para>
        /// For output events, specifies the maximum frequency of outputting this event to
        /// an outer infrastructure.
        /// </para>
        /// <para>
        /// Might be not specified, that is, there is no minimum interval.
        /// </para>
        /// </remarks>
        public string? MinInterval { get; set; }

        /// <summary>
        /// For input direction: not applicable.
        /// </summary>
        /// <remarks>
        /// <para>
        /// For output direction: maximum interval in time, the respective Referable shall send
        /// an update of the status of the event, even if no other trigger condition for
        /// the event was not met.
        /// </para>
        /// <para>
        /// Might be not specified, that is, there is no maximum interval
        /// </para>
        /// </remarks>
        public string? MaxInterval { get; set; }
        #region Parent
        [JsonIgnore]
        public IClass Parent { get; set; }
        #endregion

        #region TimeStamp
        [JsonIgnore]
        public DateTime TimeStampCreate { get; set; }
        [JsonIgnore]
        public DateTime TimeStamp { get; set; }
        [JsonIgnore]
        public DateTime TimeStampTree { get; set; }

        [JsonIgnore]
        private DiaryDataDef _diaryData = new DiaryDataDef();

        [JsonIgnore]
        public DiaryDataDef DiaryData { get { return _diaryData; } }

        #endregion

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IExtension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<IExtension>();
        }

        /// <summary>
        /// Iterate over DisplayName, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringNameType> OverDisplayNameOrEmpty()
        {
            return DisplayName
                ?? System.Linq.Enumerable.Empty<ILangStringNameType>();
        }

        /// <summary>
        /// Iterate over Description, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringTextType> OverDescriptionOrEmpty()
        {
            return Description
                ?? System.Linq.Enumerable.Empty<ILangStringTextType>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IReference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<IReference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IQualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<IQualifier>();
        }

        /// <summary>
        /// Iterate over EmbeddedDataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IEmbeddedDataSpecification> OverEmbeddedDataSpecificationsOrEmpty()
        {
            return EmbeddedDataSpecifications
                ?? System.Linq.Enumerable.Empty<IEmbeddedDataSpecification>();
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;
                }
            }

            yield return Observed;

            if (MessageBroker != null)
            {
                yield return MessageBroker;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            yield return Observed;

            // Recurse
            foreach (var anItem in Observed.Descend())
            {
                yield return anItem;
            }

            if (MessageBroker != null)
            {
                yield return MessageBroker;

                // Recurse
                foreach (var anItem in MessageBroker.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitBasicEventElement(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitBasicEventElement(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformBasicEventElement(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformBasicEventElement(this, context);
        }

        public BasicEventElement(
            IReference observed,
            Direction direction,
            StateOfEvent state,
            List<IExtension>? extensions = null,
            string? category = null,
            string? idShort = null,
            List<ILangStringNameType>? displayName = null,
            List<ILangStringTextType>? description = null,
            IReference? semanticId = null,
            List<IReference>? supplementalSemanticIds = null,
            List<IQualifier>? qualifiers = null,
            List<IEmbeddedDataSpecification>? embeddedDataSpecifications = null,
            string? messageTopic = null,
            IReference? messageBroker = null,
            string? lastUpdate = null,
            string? minInterval = null,
            string? maxInterval = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            EmbeddedDataSpecifications = embeddedDataSpecifications;
            Observed = observed;
            Direction = direction;
            State = state;
            MessageTopic = messageTopic;
            MessageBroker = messageBroker;
            LastUpdate = lastUpdate;
            MinInterval = minInterval;
            MaxInterval = maxInterval;
        }
    }

    /// <summary>
    /// An operation is a submodel element with input and output variables.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Constraint AASd-134:
    ///     For an <see cref="Aas.Operation" /> the <see cref="Aas.IReferable.IdShort" /> of all
    ///     <see cref="Aas.OperationVariable.Value" />'s in
    ///     <see cref="Aas.Operation.InputVariables" />, <see cref="Aas.Operation.OutputVariables" />
    ///     and <see cref="Aas.Operation.InoutputVariables" /> shall be unique.
    ///   </li>
    /// </ul>
    /// </remarks>
    public interface IOperation : ISubmodelElement
    {
        /// <summary>
        /// Input parameter of the operation.
        /// </summary>
        public List<IOperationVariable>? InputVariables { get; set; }

        /// <summary>
        /// Output parameter of the operation.
        /// </summary>
        public List<IOperationVariable>? OutputVariables { get; set; }

        /// <summary>
        /// Parameter that is input and output of the operation.
        /// </summary>
        public List<IOperationVariable>? InoutputVariables { get; set; }

        /// <summary>
        /// Iterate over InputVariables, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IOperationVariable> OverInputVariablesOrEmpty();

        /// <summary>
        /// Iterate over OutputVariables, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IOperationVariable> OverOutputVariablesOrEmpty();

        /// <summary>
        /// Iterate over InoutputVariables, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IOperationVariable> OverInoutputVariablesOrEmpty();
    }

    /// <summary>
    /// An operation is a submodel element with input and output variables.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Constraint AASd-134:
    ///     For an <see cref="Aas.Operation" /> the <see cref="Aas.IReferable.IdShort" /> of all
    ///     <see cref="Aas.OperationVariable.Value" />'s in
    ///     <see cref="Aas.Operation.InputVariables" />, <see cref="Aas.Operation.OutputVariables" />
    ///     and <see cref="Aas.Operation.InoutputVariables" /> shall be unique.
    ///   </li>
    /// </ul>
    /// </remarks>
    public class Operation : IOperation
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<IExtension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        public List<ILangStringNameType>? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The description can be provided in several languages.
        /// </para>
        /// <para>
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        /// </para>
        /// <para>
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </para>
        /// </remarks>
        public List<ILangStringTextType>? Description { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<IReference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Constraints:
        /// </para>
        /// <ul>
        ///   <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///   </li>
        /// </ul>
        /// </remarks>
        public List<IQualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Embedded data specification.
        /// </summary>
        public List<IEmbeddedDataSpecification>? EmbeddedDataSpecifications { get; set; }

        /// <summary>
        /// Input parameter of the operation.
        /// </summary>
        public List<IOperationVariable>? InputVariables { get; set; }

        /// <summary>
        /// Output parameter of the operation.
        /// </summary>
        public List<IOperationVariable>? OutputVariables { get; set; }

        /// <summary>
        /// Parameter that is input and output of the operation.
        /// </summary>
        public List<IOperationVariable>? InoutputVariables { get; set; }
        #region Parent
        [JsonIgnore]
        public IClass Parent { get; set; }
        #endregion

        #region TimeStamp
        [JsonIgnore]
        public DateTime TimeStampCreate { get; set; }
        [JsonIgnore]
        public DateTime TimeStamp { get; set; }
        [JsonIgnore]
        public DateTime TimeStampTree { get; set; }

        [JsonIgnore]
        private DiaryDataDef _diaryData = new DiaryDataDef();

        [JsonIgnore]
        public DiaryDataDef DiaryData { get { return _diaryData; } }

        #endregion

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IExtension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<IExtension>();
        }

        /// <summary>
        /// Iterate over DisplayName, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringNameType> OverDisplayNameOrEmpty()
        {
            return DisplayName
                ?? System.Linq.Enumerable.Empty<ILangStringNameType>();
        }

        /// <summary>
        /// Iterate over Description, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringTextType> OverDescriptionOrEmpty()
        {
            return Description
                ?? System.Linq.Enumerable.Empty<ILangStringTextType>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IReference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<IReference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IQualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<IQualifier>();
        }

        /// <summary>
        /// Iterate over EmbeddedDataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IEmbeddedDataSpecification> OverEmbeddedDataSpecificationsOrEmpty()
        {
            return EmbeddedDataSpecifications
                ?? System.Linq.Enumerable.Empty<IEmbeddedDataSpecification>();
        }

        /// <summary>
        /// Iterate over InputVariables, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IOperationVariable> OverInputVariablesOrEmpty()
        {
            return InputVariables
                ?? System.Linq.Enumerable.Empty<IOperationVariable>();
        }

        /// <summary>
        /// Iterate over OutputVariables, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IOperationVariable> OverOutputVariablesOrEmpty()
        {
            return OutputVariables
                ?? System.Linq.Enumerable.Empty<IOperationVariable>();
        }

        /// <summary>
        /// Iterate over InoutputVariables, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IOperationVariable> OverInoutputVariablesOrEmpty()
        {
            return InoutputVariables
                ?? System.Linq.Enumerable.Empty<IOperationVariable>();
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (InputVariables != null)
            {
                foreach (var anItem in InputVariables)
                {
                    yield return anItem;
                }
            }

            if (OutputVariables != null)
            {
                foreach (var anItem in OutputVariables)
                {
                    yield return anItem;
                }
            }

            if (InoutputVariables != null)
            {
                foreach (var anItem in InoutputVariables)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (InputVariables != null)
            {
                foreach (var anItem in InputVariables)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (OutputVariables != null)
            {
                foreach (var anItem in OutputVariables)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (InoutputVariables != null)
            {
                foreach (var anItem in InoutputVariables)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitOperation(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitOperation(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformOperation(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformOperation(this, context);
        }

        public Operation(
            List<IExtension>? extensions = null,
            string? category = null,
            string? idShort = null,
            List<ILangStringNameType>? displayName = null,
            List<ILangStringTextType>? description = null,
            IReference? semanticId = null,
            List<IReference>? supplementalSemanticIds = null,
            List<IQualifier>? qualifiers = null,
            List<IEmbeddedDataSpecification>? embeddedDataSpecifications = null,
            List<IOperationVariable>? inputVariables = null,
            List<IOperationVariable>? outputVariables = null,
            List<IOperationVariable>? inoutputVariables = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            EmbeddedDataSpecifications = embeddedDataSpecifications;
            InputVariables = inputVariables;
            OutputVariables = outputVariables;
            InoutputVariables = inoutputVariables;
        }
    }

    /// <summary>
    /// The value of an operation variable is a submodel element that is used as input
    /// and/or output variable of an operation.
    /// </summary>
    public interface IOperationVariable : IClass
    {
        /// <summary>
        /// Describes an argument or result of an operation via a submodel element
        /// </summary>
        public ISubmodelElement Value { get; set; }
    }

    /// <summary>
    /// The value of an operation variable is a submodel element that is used as input
    /// and/or output variable of an operation.
    /// </summary>
    public class OperationVariable : IOperationVariable
    {
        /// <summary>
        /// Describes an argument or result of an operation via a submodel element
        /// </summary>
        public ISubmodelElement Value { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            yield return Value;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            yield return Value;

            // Recurse
            foreach (var anItem in Value.Descend())
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitOperationVariable(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitOperationVariable(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformOperationVariable(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformOperationVariable(this, context);
        }

        public OperationVariable(ISubmodelElement value)
        {
            Value = value;
        }
    }

    /// <summary>
    /// A capability is the implementation-independent description of the potential of an
    /// asset to achieve a certain effect in the physical or virtual world.
    /// </summary>
    /// <remarks>
    /// The <see cref="Aas.Capability.SemanticId" /> of a capability is typically an ontology.
    /// Thus, reasoning on capabilities is enabled.
    /// </remarks>
    public interface ICapability : ISubmodelElement
    {
        // Intentionally empty.
    }

    /// <summary>
    /// A capability is the implementation-independent description of the potential of an
    /// asset to achieve a certain effect in the physical or virtual world.
    /// </summary>
    /// <remarks>
    /// The <see cref="Aas.Capability.SemanticId" /> of a capability is typically an ontology.
    /// Thus, reasoning on capabilities is enabled.
    /// </remarks>
    public class Capability : ICapability
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<IExtension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        public List<ILangStringNameType>? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The description can be provided in several languages.
        /// </para>
        /// <para>
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        /// </para>
        /// <para>
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </para>
        /// </remarks>
        public List<ILangStringTextType>? Description { get; set; }

        /// <summary>
        /// Identifier of the semantic definition of the element. It is called semantic ID
        /// of the element or also main semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference? SemanticId { get; set; }

        /// <summary>
        /// Identifier of a supplemental semantic definition of the element.
        /// It is called supplemental semantic ID of the element.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public List<IReference>? SupplementalSemanticIds { get; set; }

        /// <summary>
        /// Additional qualification of a qualifiable element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Constraints:
        /// </para>
        /// <ul>
        ///   <li>
        ///     Constraint AASd-021:
        ///     Every qualifiable can only have one qualifier with the same
        ///     <see cref="Aas.Qualifier.Type" />.
        ///   </li>
        /// </ul>
        /// </remarks>
        public List<IQualifier>? Qualifiers { get; set; }

        /// <summary>
        /// Embedded data specification.
        /// </summary>
        public List<IEmbeddedDataSpecification>? EmbeddedDataSpecifications { get; set; }
        #region Parent
        [JsonIgnore]
        public IClass Parent { get; set; }
        #endregion

        #region TimeStamp
        [JsonIgnore]
        public DateTime TimeStampCreate { get; set; }
        [JsonIgnore]
        public DateTime TimeStamp { get; set; }
        [JsonIgnore]
        public DateTime TimeStampTree { get; set; }

        [JsonIgnore]
        private DiaryDataDef _diaryData = new DiaryDataDef();

        [JsonIgnore]
        public DiaryDataDef DiaryData { get { return _diaryData; } }

        #endregion

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IExtension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<IExtension>();
        }

        /// <summary>
        /// Iterate over DisplayName, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringNameType> OverDisplayNameOrEmpty()
        {
            return DisplayName
                ?? System.Linq.Enumerable.Empty<ILangStringNameType>();
        }

        /// <summary>
        /// Iterate over Description, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringTextType> OverDescriptionOrEmpty()
        {
            return Description
                ?? System.Linq.Enumerable.Empty<ILangStringTextType>();
        }

        /// <summary>
        /// Iterate over SupplementalSemanticIds, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IReference> OverSupplementalSemanticIdsOrEmpty()
        {
            return SupplementalSemanticIds
                ?? System.Linq.Enumerable.Empty<IReference>();
        }

        /// <summary>
        /// Iterate over Qualifiers, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IQualifier> OverQualifiersOrEmpty()
        {
            return Qualifiers
                ?? System.Linq.Enumerable.Empty<IQualifier>();
        }

        /// <summary>
        /// Iterate over EmbeddedDataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IEmbeddedDataSpecification> OverEmbeddedDataSpecificationsOrEmpty()
        {
            return EmbeddedDataSpecifications
                ?? System.Linq.Enumerable.Empty<IEmbeddedDataSpecification>();
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (SemanticId != null)
            {
                yield return SemanticId;

                // Recurse
                foreach (var anItem in SemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            if (SupplementalSemanticIds != null)
            {
                foreach (var anItem in SupplementalSemanticIds)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Qualifiers != null)
            {
                foreach (var anItem in Qualifiers)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitCapability(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitCapability(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformCapability(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformCapability(this, context);
        }

        public Capability(
            List<IExtension>? extensions = null,
            string? category = null,
            string? idShort = null,
            List<ILangStringNameType>? displayName = null,
            List<ILangStringTextType>? description = null,
            IReference? semanticId = null,
            List<IReference>? supplementalSemanticIds = null,
            List<IQualifier>? qualifiers = null,
            List<IEmbeddedDataSpecification>? embeddedDataSpecifications = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            SemanticId = semanticId;
            SupplementalSemanticIds = supplementalSemanticIds;
            Qualifiers = qualifiers;
            EmbeddedDataSpecifications = embeddedDataSpecifications;
        }
    }

    /// <summary>
    /// The semantics of a property or other elements that may have a semantic description
    /// is defined by a concept description.
    /// </summary>
    /// <remarks>
    /// <para>
    /// The description of the concept should follow a standardized schema (realized as
    /// data specification template).
    /// </para>
    /// <para>
    /// Note: categories are deprecated since V3.0 of Part 1a of the document series
    /// "Details of the Asset Administration Shell".
    /// </para>
    /// <para>
    /// Note: categories are deprecated since V3.0 of Part 1a of the document series
    /// "Details of the Asset Administration Shell".
    /// </para>
    /// <para>
    /// Categories are deprecated since V3.0 of Part 1a of the document series
    /// "Details of the Asset Administration Shell".
    /// </para>
    /// <para>
    /// Categories are deprecated since V3.0 of Part 1a of the document series
    /// "Details of the Asset Administration Shell".
    /// </para>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     <para>
    ///     Constraint AASc-3a-008:
    ///     For a <see cref="Aas.ConceptDescription" /> using data specification template IEC61360,
    ///     <see cref="Aas.DataSpecificationIec61360.Definition" /> is mandatory and shall be
    ///     defined at least in English.
    ///     </para>
    ///     <para>
    ///     Exception: The concept description describes a value, i.e.
    ///     <see cref="Aas.DataSpecificationIec61360.Value" /> is defined.
    ///     </para>
    ///   </li>
    ///   <li>
    ///     Constraint AASc-3a-003:
    ///     For a <see cref="Aas.ConceptDescription" /> using data specification template IEC61360,
    ///     referenced via <see cref="Aas.DataSpecificationIec61360.ValueList" />
    ///     <see cref="Aas.ValueReferencePair.ValueId" />
    ///     the <see cref="Aas.DataSpecificationIec61360.Value" /> shall be set.
    ///   </li>
    /// </ul>
    /// </remarks>
    public interface IConceptDescription :
            IIdentifiable,
            IHasDataSpecification
    {
        /// <summary>
        /// Reference to an external definition the concept is compatible to or was derived
        /// from.
        /// </summary>
        /// <remarks>
        /// <para>
        /// It is recommended to use a global reference.
        /// </para>
        /// <para>
        /// Compare to is-case-of relationship in ISO 13584-32 &amp; IEC EN 61360
        /// </para>
        /// </remarks>
        public List<IReference>? IsCaseOf { get; set; }

        /// <summary>
        /// Iterate over IsCaseOf, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IReference> OverIsCaseOfOrEmpty();
    }

    /// <summary>
    /// The semantics of a property or other elements that may have a semantic description
    /// is defined by a concept description.
    /// </summary>
    /// <remarks>
    /// <para>
    /// The description of the concept should follow a standardized schema (realized as
    /// data specification template).
    /// </para>
    /// <para>
    /// Note: categories are deprecated since V3.0 of Part 1a of the document series
    /// "Details of the Asset Administration Shell".
    /// </para>
    /// <para>
    /// Note: categories are deprecated since V3.0 of Part 1a of the document series
    /// "Details of the Asset Administration Shell".
    /// </para>
    /// <para>
    /// Categories are deprecated since V3.0 of Part 1a of the document series
    /// "Details of the Asset Administration Shell".
    /// </para>
    /// <para>
    /// Categories are deprecated since V3.0 of Part 1a of the document series
    /// "Details of the Asset Administration Shell".
    /// </para>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     <para>
    ///     Constraint AASc-3a-008:
    ///     For a <see cref="Aas.ConceptDescription" /> using data specification template IEC61360,
    ///     <see cref="Aas.DataSpecificationIec61360.Definition" /> is mandatory and shall be
    ///     defined at least in English.
    ///     </para>
    ///     <para>
    ///     Exception: The concept description describes a value, i.e.
    ///     <see cref="Aas.DataSpecificationIec61360.Value" /> is defined.
    ///     </para>
    ///   </li>
    ///   <li>
    ///     Constraint AASc-3a-003:
    ///     For a <see cref="Aas.ConceptDescription" /> using data specification template IEC61360,
    ///     referenced via <see cref="Aas.DataSpecificationIec61360.ValueList" />
    ///     <see cref="Aas.ValueReferencePair.ValueId" />
    ///     the <see cref="Aas.DataSpecificationIec61360.Value" /> shall be set.
    ///   </li>
    /// </ul>
    /// </remarks>
    public class ConceptDescription : IConceptDescription
    {
        /// <summary>
        /// An extension of the element.
        /// </summary>
        public List<IExtension>? Extensions { get; set; }

        /// <summary>
        /// The category is a value that gives further meta information
        /// w.r.t. to the class of the element.
        /// It affects the expected existence of attributes and the applicability of
        /// constraints.
        /// </summary>
        /// <remarks>
        /// The category is not identical to the semantic definition
        /// (<see cref="Aas.IHasSemantics" />) of an element. The category e.g. could denote that
        /// the element is a measurement value whereas the semantic definition of
        /// the element would denote that it is the measured temperature.
        /// </remarks>
        public string? Category { get; set; }

        /// <summary>
        /// In case of identifiables this attribute is a short name of the element.
        /// In case of referable this ID is an identifying string of the element within
        /// its name space.
        /// </summary>
        /// <remarks>
        /// In case the element is a property and the property has a semantic definition
        /// (<see cref="Aas.IHasSemantics.SemanticId" />) conformant to IEC61360
        /// the <see cref="Aas.IReferable.IdShort" /> is typically identical to the short name in English.
        /// </remarks>
        public string? IdShort { get; set; }

        /// <summary>
        /// Display name. Can be provided in several languages.
        /// </summary>
        public List<ILangStringNameType>? DisplayName { get; set; }

        /// <summary>
        /// Description or comments on the element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The description can be provided in several languages.
        /// </para>
        /// <para>
        /// If no description is defined, then the definition of the concept
        /// description that defines the semantics of the element is used.
        /// </para>
        /// <para>
        /// Additional information can be provided, e.g., if the element is
        /// qualified and which qualifier types can be expected in which
        /// context or which additional data specification templates are
        /// provided.
        /// </para>
        /// </remarks>
        public List<ILangStringTextType>? Description { get; set; }

        /// <summary>
        /// Administrative information of an identifiable element.
        /// </summary>
        /// <remarks>
        /// Some of the administrative information like the version number might need to
        /// be part of the identification.
        /// </remarks>
        public IAdministrativeInformation? Administration { get; set; }

        /// <summary>
        /// The globally unique identification of the element.
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Embedded data specification.
        /// </summary>
        public List<IEmbeddedDataSpecification>? EmbeddedDataSpecifications { get; set; }

        /// <summary>
        /// Reference to an external definition the concept is compatible to or was derived
        /// from.
        /// </summary>
        /// <remarks>
        /// <para>
        /// It is recommended to use a global reference.
        /// </para>
        /// <para>
        /// Compare to is-case-of relationship in ISO 13584-32 &amp; IEC EN 61360
        /// </para>
        /// </remarks>
        public List<IReference>? IsCaseOf { get; set; }
        #region Parent
        [JsonIgnore]
        public IClass Parent { get; set; }
        #endregion

        #region TimeStamp
        [JsonIgnore]
        public DateTime TimeStampCreate { get; set; }
        [JsonIgnore]
        public DateTime TimeStamp { get; set; }
        [JsonIgnore]
        public DateTime TimeStampTree { get; set; }

        [JsonIgnore]
        private DiaryDataDef _diaryData = new DiaryDataDef();

        [JsonIgnore]
        public DiaryDataDef DiaryData { get { return _diaryData; } }

        #endregion

        /// <summary>
        /// Iterate over Extensions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IExtension> OverExtensionsOrEmpty()
        {
            return Extensions
                ?? System.Linq.Enumerable.Empty<IExtension>();
        }

        /// <summary>
        /// Iterate over DisplayName, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringNameType> OverDisplayNameOrEmpty()
        {
            return DisplayName
                ?? System.Linq.Enumerable.Empty<ILangStringNameType>();
        }

        /// <summary>
        /// Iterate over Description, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringTextType> OverDescriptionOrEmpty()
        {
            return Description
                ?? System.Linq.Enumerable.Empty<ILangStringTextType>();
        }

        /// <summary>
        /// Iterate over EmbeddedDataSpecifications, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IEmbeddedDataSpecification> OverEmbeddedDataSpecificationsOrEmpty()
        {
            return EmbeddedDataSpecifications
                ?? System.Linq.Enumerable.Empty<IEmbeddedDataSpecification>();
        }

        /// <summary>
        /// Iterate over IsCaseOf, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IReference> OverIsCaseOfOrEmpty()
        {
            return IsCaseOf
                ?? System.Linq.Enumerable.Empty<IReference>();
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;
                }
            }

            if (Administration != null)
            {
                yield return Administration;
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;
                }
            }

            if (IsCaseOf != null)
            {
                foreach (var anItem in IsCaseOf)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (Extensions != null)
            {
                foreach (var anItem in Extensions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (DisplayName != null)
            {
                foreach (var anItem in DisplayName)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Description != null)
            {
                foreach (var anItem in Description)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Administration != null)
            {
                yield return Administration;

                // Recurse
                foreach (var anItem in Administration.Descend())
                {
                    yield return anItem;
                }
            }

            if (EmbeddedDataSpecifications != null)
            {
                foreach (var anItem in EmbeddedDataSpecifications)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (IsCaseOf != null)
            {
                foreach (var anItem in IsCaseOf)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitConceptDescription(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitConceptDescription(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformConceptDescription(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformConceptDescription(this, context);
        }

        public ConceptDescription(
            string id,
            List<IExtension>? extensions = null,
            string? category = null,
            string? idShort = null,
            List<ILangStringNameType>? displayName = null,
            List<ILangStringTextType>? description = null,
            IAdministrativeInformation? administration = null,
            List<IEmbeddedDataSpecification>? embeddedDataSpecifications = null,
            List<IReference>? isCaseOf = null)
        {
            Extensions = extensions;
            IdShort = idShort;
            DisplayName = displayName;
            Category = category;
            Description = description;
            Id = id;
            Administration = administration;
            EmbeddedDataSpecifications = embeddedDataSpecifications;
            IsCaseOf = isCaseOf;
        }
    }

    /// <summary>
    /// Reference types
    /// </summary>
    public enum ReferenceTypes
    {
        /// <summary>
        /// External reference.
        /// </summary>
        [EnumMember(Value = "ExternalReference")]
        ExternalReference,

        /// <summary>
        /// Model reference.
        /// </summary>
        [EnumMember(Value = "ModelReference")]
        ModelReference
    }

    /// <summary>
    /// Reference to either a model element of the same or another AAS or to an external
    /// entity.
    /// </summary>
    /// <remarks>
    /// <para>
    /// A reference is an ordered list of keys.
    /// </para>
    /// <para>
    /// A model reference is an ordered list of keys, each key referencing an element. The
    /// complete list of keys may for example be concatenated to a path that then gives
    /// unique access to an element.
    /// </para>
    /// <para>
    /// An external reference is a reference to an external entity.
    /// </para>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Constraint AASd-121:
    ///     For <see cref="Aas.Reference" />'s the value of <see cref="Aas.Key.Type" /> of the first key of "
    ///     <see cref="Aas.Reference.Keys" /> shall be one of <see cref="Aas.Constants.GloballyIdentifiables" />.
    ///   </li>
    ///   <li>
    ///     Constraint AASd-122:
    ///     For external references, i.e. <see cref="Aas.Reference" />'s with
    ///     <see cref="Aas.Reference.Type" /> = <see cref="Aas.ReferenceTypes.ExternalReference" />, the value
    ///     of <see cref="Aas.Key.Type" /> of the first key of <see cref="Aas.Reference.Keys" /> shall be one of
    ///     <see cref="Aas.Constants.GenericGloballyIdentifiables" />.
    ///   </li>
    ///   <li>
    ///     Constraint AASd-123:
    ///     For model references, i.e. <see cref="Aas.Reference" />'s with
    ///     <see cref="Aas.Reference.Type" /> = <see cref="Aas.ReferenceTypes.ModelReference" />, the value
    ///     of <see cref="Aas.Key.Type" /> of the first key of <see cref="Aas.Reference.Keys" /> shall be one of
    ///     <see cref="Aas.Constants.AasIdentifiables" />.
    ///   </li>
    ///   <li>
    ///     Constraint AASd-124:
    ///     For external references, i.e. <see cref="Aas.Reference" />'s with
    ///     <see cref="Aas.Reference.Type" /> = <see cref="Aas.ReferenceTypes.ExternalReference" />, the last
    ///     key of <see cref="Aas.Reference.Keys" /> shall be either one of
    ///     <see cref="Aas.Constants.GenericGloballyIdentifiables" /> or one of
    ///     <see cref="Aas.Constants.GenericFragmentKeys" />.
    ///   </li>
    ///   <li>
    ///     <para>
    ///     Constraint AASd-125:
    ///     For model references, i.e. <see cref="Aas.Reference" />'s with
    ///     <see cref="Aas.Reference.Type" /> = <see cref="Aas.ReferenceTypes.ModelReference" />, with more
    ///     than one key in <see cref="Aas.Reference.Keys" /> the value of <see cref="Aas.Key.Type" />
    ///     of each of the keys following the first
    ///     key of <see cref="Aas.Reference.Keys" /> shall be one of <see cref="Aas.Constants.FragmentKeys" />.
    ///     </para>
    ///     <para>
    ///     Constraint AASd-125 ensures that the shortest path is used.
    ///     </para>
    ///   </li>
    ///   <li>
    ///     Constraint AASd-126:
    ///     For model references, i.e. <see cref="Aas.Reference" />'s with
    ///     <see cref="Aas.Reference.Type" /> = <see cref="Aas.ReferenceTypes.ModelReference" />, with more
    ///     than one key in <see cref="Aas.Reference.Keys" /> the value of <see cref="Aas.Key.Type" />
    ///     of the last key in the reference key chain may be
    ///     one of <see cref="Aas.Constants.GenericFragmentKeys" /> or no key at all
    ///     shall have a value out of <see cref="Aas.Constants.GenericFragmentKeys" />.
    ///   </li>
    ///   <li>
    ///     <para>
    ///     Constraint AASd-127:
    ///     For model references, i.e. <see cref="Aas.Reference" />'s with
    ///     <see cref="Aas.Reference.Type" /> = <see cref="Aas.ReferenceTypes.ModelReference" />, with more
    ///     than one key in <see cref="Aas.Reference.Keys" /> a key with <see cref="Aas.Key.Type" />
    ///     <see cref="Aas.KeyTypes.FragmentReference" /> shall be preceded by a key with
    ///     <see cref="Aas.Key.Type" /> <see cref="Aas.KeyTypes.File" /> or <see cref="Aas.KeyTypes.Blob" />. All other
    ///     AAS fragments, i.e. <see cref="Aas.Key.Type" /> values
    ///     out of <see cref="Aas.Constants.AasSubmodelElementsAsKeys" />, do not support fragments.
    ///     </para>
    ///     <para>
    ///     Which kind of fragments are supported depends on the content type and the
    ///     specification of allowed fragment identifiers for the corresponding resource
    ///     being referenced via the reference.
    ///     </para>
    ///   </li>
    ///   <li>
    ///     Constraint AASd-128:
    ///     For model references, i.e. <see cref="Aas.Reference" />'s with
    ///     <see cref="Aas.Reference.Type" /> = <see cref="Aas.ReferenceTypes.ModelReference" />, the
    ///     <see cref="Aas.Key.Value" /> of a <see cref="Aas.Key" /> preceded by a <see cref="Aas.Key" /> with
    ///     <see cref="Aas.Key.Type" /> = <see cref="Aas.KeyTypes.SubmodelElementList" /> is an integer
    ///     number denoting the position in the array of the submodel element list.
    ///   </li>
    /// </ul>
    /// </remarks>
    public interface IReference : IClass
    {
        /// <summary>
        /// Type of the reference.
        /// </summary>
        /// <remarks>
        /// Denotes, whether reference is an external reference or a model reference.
        /// </remarks>
        public ReferenceTypes Type { get; set; }

        /// <summary>
        /// <see cref="Aas.IHasSemantics.SemanticId" /> of the referenced model element
        /// (<see cref="Aas.Reference.Type" /> = <see cref="Aas.ReferenceTypes.ModelReference" />).
        /// </summary>
        /// <remarks>
        /// <para>
        /// For external references there typically is no semantic ID.
        /// </para>
        /// <para>
        /// It is recommended to use a external reference.
        /// </para>
        /// </remarks>
        public IReference? ReferredSemanticId { get; set; }

        /// <summary>
        /// Unique references in their name space.
        /// </summary>
        public List<IKey> Keys { get; set; }
    }

    /// <summary>
    /// Reference to either a model element of the same or another AAS or to an external
    /// entity.
    /// </summary>
    /// <remarks>
    /// <para>
    /// A reference is an ordered list of keys.
    /// </para>
    /// <para>
    /// A model reference is an ordered list of keys, each key referencing an element. The
    /// complete list of keys may for example be concatenated to a path that then gives
    /// unique access to an element.
    /// </para>
    /// <para>
    /// An external reference is a reference to an external entity.
    /// </para>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Constraint AASd-121:
    ///     For <see cref="Aas.Reference" />'s the value of <see cref="Aas.Key.Type" /> of the first key of "
    ///     <see cref="Aas.Reference.Keys" /> shall be one of <see cref="Aas.Constants.GloballyIdentifiables" />.
    ///   </li>
    ///   <li>
    ///     Constraint AASd-122:
    ///     For external references, i.e. <see cref="Aas.Reference" />'s with
    ///     <see cref="Aas.Reference.Type" /> = <see cref="Aas.ReferenceTypes.ExternalReference" />, the value
    ///     of <see cref="Aas.Key.Type" /> of the first key of <see cref="Aas.Reference.Keys" /> shall be one of
    ///     <see cref="Aas.Constants.GenericGloballyIdentifiables" />.
    ///   </li>
    ///   <li>
    ///     Constraint AASd-123:
    ///     For model references, i.e. <see cref="Aas.Reference" />'s with
    ///     <see cref="Aas.Reference.Type" /> = <see cref="Aas.ReferenceTypes.ModelReference" />, the value
    ///     of <see cref="Aas.Key.Type" /> of the first key of <see cref="Aas.Reference.Keys" /> shall be one of
    ///     <see cref="Aas.Constants.AasIdentifiables" />.
    ///   </li>
    ///   <li>
    ///     Constraint AASd-124:
    ///     For external references, i.e. <see cref="Aas.Reference" />'s with
    ///     <see cref="Aas.Reference.Type" /> = <see cref="Aas.ReferenceTypes.ExternalReference" />, the last
    ///     key of <see cref="Aas.Reference.Keys" /> shall be either one of
    ///     <see cref="Aas.Constants.GenericGloballyIdentifiables" /> or one of
    ///     <see cref="Aas.Constants.GenericFragmentKeys" />.
    ///   </li>
    ///   <li>
    ///     <para>
    ///     Constraint AASd-125:
    ///     For model references, i.e. <see cref="Aas.Reference" />'s with
    ///     <see cref="Aas.Reference.Type" /> = <see cref="Aas.ReferenceTypes.ModelReference" />, with more
    ///     than one key in <see cref="Aas.Reference.Keys" /> the value of <see cref="Aas.Key.Type" />
    ///     of each of the keys following the first
    ///     key of <see cref="Aas.Reference.Keys" /> shall be one of <see cref="Aas.Constants.FragmentKeys" />.
    ///     </para>
    ///     <para>
    ///     Constraint AASd-125 ensures that the shortest path is used.
    ///     </para>
    ///   </li>
    ///   <li>
    ///     Constraint AASd-126:
    ///     For model references, i.e. <see cref="Aas.Reference" />'s with
    ///     <see cref="Aas.Reference.Type" /> = <see cref="Aas.ReferenceTypes.ModelReference" />, with more
    ///     than one key in <see cref="Aas.Reference.Keys" /> the value of <see cref="Aas.Key.Type" />
    ///     of the last key in the reference key chain may be
    ///     one of <see cref="Aas.Constants.GenericFragmentKeys" /> or no key at all
    ///     shall have a value out of <see cref="Aas.Constants.GenericFragmentKeys" />.
    ///   </li>
    ///   <li>
    ///     <para>
    ///     Constraint AASd-127:
    ///     For model references, i.e. <see cref="Aas.Reference" />'s with
    ///     <see cref="Aas.Reference.Type" /> = <see cref="Aas.ReferenceTypes.ModelReference" />, with more
    ///     than one key in <see cref="Aas.Reference.Keys" /> a key with <see cref="Aas.Key.Type" />
    ///     <see cref="Aas.KeyTypes.FragmentReference" /> shall be preceded by a key with
    ///     <see cref="Aas.Key.Type" /> <see cref="Aas.KeyTypes.File" /> or <see cref="Aas.KeyTypes.Blob" />. All other
    ///     AAS fragments, i.e. <see cref="Aas.Key.Type" /> values
    ///     out of <see cref="Aas.Constants.AasSubmodelElementsAsKeys" />, do not support fragments.
    ///     </para>
    ///     <para>
    ///     Which kind of fragments are supported depends on the content type and the
    ///     specification of allowed fragment identifiers for the corresponding resource
    ///     being referenced via the reference.
    ///     </para>
    ///   </li>
    ///   <li>
    ///     Constraint AASd-128:
    ///     For model references, i.e. <see cref="Aas.Reference" />'s with
    ///     <see cref="Aas.Reference.Type" /> = <see cref="Aas.ReferenceTypes.ModelReference" />, the
    ///     <see cref="Aas.Key.Value" /> of a <see cref="Aas.Key" /> preceded by a <see cref="Aas.Key" /> with
    ///     <see cref="Aas.Key.Type" /> = <see cref="Aas.KeyTypes.SubmodelElementList" /> is an integer
    ///     number denoting the position in the array of the submodel element list.
    ///   </li>
    /// </ul>
    /// </remarks>
    public class Reference : IReference
    {
        /// <summary>
        /// Type of the reference.
        /// </summary>
        /// <remarks>
        /// Denotes, whether reference is an external reference or a model reference.
        /// </remarks>
        public ReferenceTypes Type { get; set; }

        /// <summary>
        /// <see cref="Aas.IHasSemantics.SemanticId" /> of the referenced model element
        /// (<see cref="Aas.Reference.Type" /> = <see cref="Aas.ReferenceTypes.ModelReference" />).
        /// </summary>
        /// <remarks>
        /// <para>
        /// For external references there typically is no semantic ID.
        /// </para>
        /// <para>
        /// It is recommended to use a external reference.
        /// </para>
        /// </remarks>
        public IReference? ReferredSemanticId { get; set; }

        /// <summary>
        /// Unique references in their name space.
        /// </summary>
        public List<IKey> Keys { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (ReferredSemanticId != null)
            {
                yield return ReferredSemanticId;
            }

            foreach (var anItem in Keys)
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (ReferredSemanticId != null)
            {
                yield return ReferredSemanticId;

                // Recurse
                foreach (var anItem in ReferredSemanticId.Descend())
                {
                    yield return anItem;
                }
            }

            foreach (var anItem in Keys)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitReference(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitReference(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformReference(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformReference(this, context);
        }

        public Reference(
            ReferenceTypes type,
            List<IKey> keys,
            IReference? referredSemanticId = null)
        {
            Type = type;
            Keys = keys;
            ReferredSemanticId = referredSemanticId;
        }
    }

    /// <summary>
    /// A key is a reference to an element by its ID.
    /// </summary>
    public interface IKey : IClass
    {
        /// <summary>
        /// Denotes which kind of entity is referenced.
        /// </summary>
        /// <remarks>
        /// <para>
        /// In case <see cref="Aas.Key.Type" /> = <see cref="Aas.KeyTypes.FragmentReference" /> the key represents
        /// a bookmark or a similar local identifier within its parent element as specified
        /// by the key that precedes this key.
        /// </para>
        /// <para>
        /// In all other cases the key references a model element of the same or of another AAS.
        /// The name of the model element is explicitly listed.
        /// </para>
        /// </remarks>
        public KeyTypes Type { get; set; }

        /// <summary>
        /// The key value, for example an IRDI or an URI
        /// </summary>
        public string Value { get; set; }
    }

    /// <summary>
    /// A key is a reference to an element by its ID.
    /// </summary>
    public class Key : IKey
    {
        /// <summary>
        /// Denotes which kind of entity is referenced.
        /// </summary>
        /// <remarks>
        /// <para>
        /// In case <see cref="Aas.Key.Type" /> = <see cref="Aas.KeyTypes.FragmentReference" /> the key represents
        /// a bookmark or a similar local identifier within its parent element as specified
        /// by the key that precedes this key.
        /// </para>
        /// <para>
        /// In all other cases the key references a model element of the same or of another AAS.
        /// The name of the model element is explicitly listed.
        /// </para>
        /// </remarks>
        public KeyTypes Type { get; set; }

        /// <summary>
        /// The key value, for example an IRDI or an URI
        /// </summary>
        public string Value { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitKey(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitKey(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformKey(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformKey(this, context);
        }

        public Key(
            KeyTypes type,
            string value)
        {
            Type = type;
            Value = value;
        }
    }

    /// <summary>
    /// Enumeration of different key value types within a key.
    /// </summary>
    public enum KeyTypes
    {
        [EnumMember(Value = "AnnotatedRelationshipElement")]
        AnnotatedRelationshipElement,

        [EnumMember(Value = "AssetAdministrationShell")]
        AssetAdministrationShell,

        [EnumMember(Value = "BasicEventElement")]
        BasicEventElement,

        [EnumMember(Value = "Blob")]
        Blob,

        [EnumMember(Value = "Capability")]
        Capability,

        [EnumMember(Value = "ConceptDescription")]
        ConceptDescription,

        /// <summary>
        /// Data element.
        /// </summary>
        /// <remarks>
        /// Data Element is abstract, <em>i.e.</em> if a key uses <see cref="Aas.KeyTypes.DataElement" />
        /// the reference may be a Property, a File etc.
        /// </remarks>
        [EnumMember(Value = "DataElement")]
        DataElement,

        [EnumMember(Value = "Entity")]
        Entity,

        /// <summary>
        /// Event.
        /// </summary>
        /// <remarks>
        /// <see cref="Aas.IEventElement" /> is abstract.
        /// </remarks>
        [EnumMember(Value = "EventElement")]
        EventElement,

        [EnumMember(Value = "File")]
        File,

        /// <summary>
        /// Bookmark or a similar local identifier of a subordinate part of
        /// a primary resource
        /// </summary>
        [EnumMember(Value = "FragmentReference")]
        FragmentReference,

        [EnumMember(Value = "GlobalReference")]
        GlobalReference,

        /// <summary>
        /// Identifiable.
        /// </summary>
        /// <remarks>
        /// Identifiable is abstract, i.e. if a key uses “Identifiable” the reference
        /// may be an Asset Administration Shell, a Submodel or a Concept Description.
        /// </remarks>
        [EnumMember(Value = "Identifiable")]
        Identifiable,

        /// <summary>
        /// Property with a value that can be provided in multiple languages
        /// </summary>
        [EnumMember(Value = "MultiLanguageProperty")]
        MultiLanguageProperty,

        [EnumMember(Value = "Operation")]
        Operation,

        [EnumMember(Value = "Property")]
        Property,

        /// <summary>
        /// Range with min and max
        /// </summary>
        [EnumMember(Value = "Range")]
        Range,

        [EnumMember(Value = "Referable")]
        Referable,

        /// <summary>
        /// Reference
        /// </summary>
        [EnumMember(Value = "ReferenceElement")]
        ReferenceElement,

        /// <summary>
        /// Relationship
        /// </summary>
        [EnumMember(Value = "RelationshipElement")]
        RelationshipElement,

        [EnumMember(Value = "Submodel")]
        Submodel,

        /// <summary>
        /// Submodel Element
        /// </summary>
        /// <remarks>
        /// Submodel Element is abstract, <em>i.e.</em> if a key uses <see cref="Aas.KeyTypes.SubmodelElement" />
        /// the reference may be a <see cref="Aas.Property" />, an <see cref="Aas.Operation" /> etc.
        /// </remarks>
        [EnumMember(Value = "SubmodelElement")]
        SubmodelElement,

        /// <summary>
        /// Struct of Submodel Elements
        /// </summary>
        [EnumMember(Value = "SubmodelElementCollection")]
        SubmodelElementCollection,

        /// <summary>
        /// List of Submodel Elements
        /// </summary>
        [EnumMember(Value = "SubmodelElementList")]
        SubmodelElementList
    }

    /// <summary>
    /// Enumeration listing all XSD anySimpleTypes
    /// </summary>
    public enum DataTypeDefXsd
    {
        [EnumMember(Value = "xs:anyURI")]
        AnyUri,

        [EnumMember(Value = "xs:base64Binary")]
        Base64Binary,

        [EnumMember(Value = "xs:boolean")]
        Boolean,

        [EnumMember(Value = "xs:byte")]
        Byte,

        [EnumMember(Value = "xs:date")]
        Date,

        [EnumMember(Value = "xs:dateTime")]
        DateTime,

        [EnumMember(Value = "xs:decimal")]
        Decimal,

        [EnumMember(Value = "xs:double")]
        Double,

        [EnumMember(Value = "xs:duration")]
        Duration,

        [EnumMember(Value = "xs:float")]
        Float,

        [EnumMember(Value = "xs:gDay")]
        GDay,

        [EnumMember(Value = "xs:gMonth")]
        GMonth,

        [EnumMember(Value = "xs:gMonthDay")]
        GMonthDay,

        [EnumMember(Value = "xs:gYear")]
        GYear,

        [EnumMember(Value = "xs:gYearMonth")]
        GYearMonth,

        [EnumMember(Value = "xs:hexBinary")]
        HexBinary,

        [EnumMember(Value = "xs:int")]
        Int,

        [EnumMember(Value = "xs:integer")]
        Integer,

        [EnumMember(Value = "xs:long")]
        Long,

        [EnumMember(Value = "xs:negativeInteger")]
        NegativeInteger,

        [EnumMember(Value = "xs:nonNegativeInteger")]
        NonNegativeInteger,

        [EnumMember(Value = "xs:nonPositiveInteger")]
        NonPositiveInteger,

        [EnumMember(Value = "xs:positiveInteger")]
        PositiveInteger,

        [EnumMember(Value = "xs:short")]
        Short,

        [EnumMember(Value = "xs:string")]
        String,

        [EnumMember(Value = "xs:time")]
        Time,

        [EnumMember(Value = "xs:unsignedByte")]
        UnsignedByte,

        [EnumMember(Value = "xs:unsignedInt")]
        UnsignedInt,

        [EnumMember(Value = "xs:unsignedLong")]
        UnsignedLong,

        [EnumMember(Value = "xs:unsignedShort")]
        UnsignedShort
    }

    /// <summary>
    /// Strings with language tags
    /// </summary>
    public interface IAbstractLangString : IClass
    {
        /// <summary>
        /// Language tag conforming to BCP 47
        /// </summary>
        public string Language { get; set; }

        /// <summary>
        /// Text in the <see cref="Aas.IAbstractLangString.Language" />
        /// </summary>
        public string Text { get; set; }
    }

    /// <summary>
    /// String with length 128 maximum and minimum 1 characters and with language tags
    /// </summary>
    public interface ILangStringNameType : IAbstractLangString
    {
        // Intentionally empty.
    }

    /// <summary>
    /// String with length 128 maximum and minimum 1 characters and with language tags
    /// </summary>
    public class LangStringNameType : ILangStringNameType
    {
        /// <summary>
        /// Language tag conforming to BCP 47
        /// </summary>
        public string Language { get; set; }

        /// <summary>
        /// Text in the <see cref="Aas.IAbstractLangString.Language" />
        /// </summary>
        public string Text { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitLangStringNameType(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitLangStringNameType(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformLangStringNameType(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformLangStringNameType(this, context);
        }

        public LangStringNameType(
            string language,
            string text)
        {
            Language = language;
            Text = text;
        }
    }

    /// <summary>
    /// String with length 1023 maximum and minimum 1 characters and with language tags
    /// </summary>
    public interface ILangStringTextType : IAbstractLangString
    {
        // Intentionally empty.
    }

    /// <summary>
    /// String with length 1023 maximum and minimum 1 characters and with language tags
    /// </summary>
    public class LangStringTextType : ILangStringTextType
    {
        /// <summary>
        /// Language tag conforming to BCP 47
        /// </summary>
        public string Language { get; set; }

        /// <summary>
        /// Text in the <see cref="Aas.IAbstractLangString.Language" />
        /// </summary>
        public string Text { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitLangStringTextType(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitLangStringTextType(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformLangStringTextType(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformLangStringTextType(this, context);
        }

        public LangStringTextType(
            string language,
            string text)
        {
            Language = language;
            Text = text;
        }
    }

    /// <summary>
    /// Container for the sets of different identifiables.
    /// </summary>
    /// <remarks>
    /// w.r.t. file exchange: There is exactly one environment independent on how many
    /// files the contained elements are split. If the file is split then there
    /// shall be no element with the same identifier in two different files.
    /// </remarks>
    public interface IEnvironment : IClass, IDiaryData
    {
        /// <summary>
        /// Asset administration shell
        /// </summary>
        public List<IAssetAdministrationShell>? AssetAdministrationShells { get; set; }

        /// <summary>
        /// Submodel
        /// </summary>
        public List<ISubmodel>? Submodels { get; set; }

        /// <summary>
        /// Concept description
        /// </summary>
        public List<IConceptDescription>? ConceptDescriptions { get; set; }

        /// <summary>
        /// Iterate over AssetAdministrationShells, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IAssetAdministrationShell> OverAssetAdministrationShellsOrEmpty();

        /// <summary>
        /// Iterate over Submodels, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ISubmodel> OverSubmodelsOrEmpty();

        /// <summary>
        /// Iterate over ConceptDescriptions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IConceptDescription> OverConceptDescriptionsOrEmpty();
    }

    /// <summary>
    /// Container for the sets of different identifiables.
    /// </summary>
    /// <remarks>
    /// w.r.t. file exchange: There is exactly one environment independent on how many
    /// files the contained elements are split. If the file is split then there
    /// shall be no element with the same identifier in two different files.
    /// </remarks>
    public class Environment : IEnvironment
    {
        /// <summary>
        /// Asset administration shell
        /// </summary>
        public List<IAssetAdministrationShell>? AssetAdministrationShells { get; set; }

        /// <summary>
        /// Submodel
        /// </summary>
        public List<ISubmodel>? Submodels { get; set; }

        /// <summary>
        /// Concept description
        /// </summary>
        public List<IConceptDescription>? ConceptDescriptions { get; set; }

        /// <summary>
        /// Iterate over AssetAdministrationShells, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IAssetAdministrationShell> OverAssetAdministrationShellsOrEmpty()
        {
            return AssetAdministrationShells
                ?? System.Linq.Enumerable.Empty<IAssetAdministrationShell>();
        }

        [JsonIgnore]
        private DiaryDataDef _diaryData = new DiaryDataDef();

        [JsonIgnore]
        public DiaryDataDef DiaryData { get { return _diaryData; } }

        /// <summary>
        /// Iterate over Submodels, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ISubmodel> OverSubmodelsOrEmpty()
        {
            return Submodels
                ?? System.Linq.Enumerable.Empty<ISubmodel>();
        }

        /// <summary>
        /// Iterate over ConceptDescriptions, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<IConceptDescription> OverConceptDescriptionsOrEmpty()
        {
            return ConceptDescriptions
                ?? System.Linq.Enumerable.Empty<IConceptDescription>();
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            if (AssetAdministrationShells != null)
            {
                foreach (var anItem in AssetAdministrationShells)
                {
                    yield return anItem;
                }
            }

            if (Submodels != null)
            {
                foreach (var anItem in Submodels)
                {
                    yield return anItem;
                }
            }

            if (ConceptDescriptions != null)
            {
                foreach (var anItem in ConceptDescriptions)
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            if (AssetAdministrationShells != null)
            {
                foreach (var anItem in AssetAdministrationShells)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (Submodels != null)
            {
                foreach (var anItem in Submodels)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (ConceptDescriptions != null)
            {
                foreach (var anItem in ConceptDescriptions)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitEnvironment(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitEnvironment(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformEnvironment(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformEnvironment(this, context);
        }

        public Environment(
            List<IAssetAdministrationShell>? assetAdministrationShells = null,
            List<ISubmodel>? submodels = null,
            List<IConceptDescription>? conceptDescriptions = null)
        {
            AssetAdministrationShells = assetAdministrationShells;
            Submodels = submodels;
            ConceptDescriptions = conceptDescriptions;
        }
    }

    /// <summary>
    /// Data specification content is part of a data specification template and defines
    /// which additional attributes shall be added to the element instance that references
    /// the data specification template and meta information about the template itself.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Constraint AASc-3a-050:
    ///     If the <see cref="Aas.DataSpecificationIec61360" /> is used
    ///     for an element, the value of
    ///     <see cref="Aas.IHasDataSpecification.EmbeddedDataSpecifications" />
    ///     shall contain the global reference to the IRI of the corresponding
    ///     data specification template
    ///     https://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/3/0
    ///   </li>
    /// </ul>
    /// </remarks>
    public interface IDataSpecificationContent : IClass
    {
        // Intentionally empty.
    }

    /// <summary>
    /// Embed the content of a data specification.
    /// </summary>
    public interface IEmbeddedDataSpecification : IClass
    {
        /// <summary>
        /// Reference to the data specification
        /// </summary>
        public IReference DataSpecification { get; set; }

        /// <summary>
        /// Actual content of the data specification
        /// </summary>
        public IDataSpecificationContent DataSpecificationContent { get; set; }
    }

    /// <summary>
    /// Embed the content of a data specification.
    /// </summary>
    public class EmbeddedDataSpecification : IEmbeddedDataSpecification
    {
        /// <summary>
        /// Reference to the data specification
        /// </summary>
        public IReference DataSpecification { get; set; }

        /// <summary>
        /// Actual content of the data specification
        /// </summary>
        public IDataSpecificationContent DataSpecificationContent { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            yield return DataSpecification;

            yield return DataSpecificationContent;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            yield return DataSpecification;

            // Recurse
            foreach (var anItem in DataSpecification.Descend())
            {
                yield return anItem;
            }

            yield return DataSpecificationContent;

            // Recurse
            // TODO (MIHO, 2023-06-05): give to AAS core
            if (DataSpecificationContent != null)
                foreach (var anItem in DataSpecificationContent.Descend())
                {
                    yield return anItem;
                }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitEmbeddedDataSpecification(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitEmbeddedDataSpecification(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformEmbeddedDataSpecification(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformEmbeddedDataSpecification(this, context);
        }

        public EmbeddedDataSpecification(
            IReference dataSpecification,
            IDataSpecificationContent dataSpecificationContent)
        {
            DataSpecification = dataSpecification;
            DataSpecificationContent = dataSpecificationContent;
        }
    }

    public enum DataTypeIec61360
    {
        /// <summary>
        /// values containing a calendar date, conformant to ISO 8601:2004 Format yyyy-mm-dd
        /// Example from IEC 61360-1:2017: "1999-05-31" is the [DATE] representation of:
        /// "31 May 1999".
        /// </summary>
        [EnumMember(Value = "DATE")]
        Date,

        /// <summary>
        /// values consisting of sequence of characters but cannot be translated into other
        /// languages
        /// </summary>
        [EnumMember(Value = "STRING")]
        String,

        /// <summary>
        /// values containing string but shall be represented as different string in different
        /// languages
        /// </summary>
        [EnumMember(Value = "STRING_TRANSLATABLE")]
        StringTranslatable,

        /// <summary>
        /// values containing values that are measure of type INTEGER. In addition such a value
        /// comes with a physical unit.
        /// </summary>
        [EnumMember(Value = "INTEGER_MEASURE")]
        IntegerMeasure,

        /// <summary>
        /// values containing values of type INTEGER but are no currencies or measures
        /// </summary>
        [EnumMember(Value = "INTEGER_COUNT")]
        IntegerCount,

        /// <summary>
        /// values containing values of type INTEGER that are currencies
        /// </summary>
        [EnumMember(Value = "INTEGER_CURRENCY")]
        IntegerCurrency,

        /// <summary>
        /// values containing values that are measures of type REAL. In addition such a value
        /// comes with a physical unit.
        /// </summary>
        [EnumMember(Value = "REAL_MEASURE")]
        RealMeasure,

        /// <summary>
        /// values containing numbers that can be written as a terminating or non-terminating
        /// decimal; a rational or irrational number but are no currencies or measures
        /// </summary>
        [EnumMember(Value = "REAL_COUNT")]
        RealCount,

        /// <summary>
        /// values containing values of type REAL that are currencies
        /// </summary>
        [EnumMember(Value = "REAL_CURRENCY")]
        RealCurrency,

        /// <summary>
        /// values representing truth of logic or Boolean algebra (TRUE, FALSE)
        /// </summary>
        [EnumMember(Value = "BOOLEAN")]
        Boolean,

        /// <summary>
        /// values containing values of type STRING conformant to Rfc 3987
        /// </summary>
        /// <remarks>
        /// In IEC61360-1 (2017) only URI is supported.
        /// An IRI type allows in particular to express an URL or an URI.
        /// </remarks>
        [EnumMember(Value = "IRI")]
        Iri,

        /// <summary>
        /// values conforming to ISO/IEC 11179 series global identifier sequences
        /// </summary>
        /// <remarks>
        /// <para>
        /// IRDI can be used instead of the more specific data types ICID or ISO29002_IRDI.
        /// </para>
        /// <para>
        /// ICID values are value conformant to an IRDI, where the delimiter between RAI and ID
        /// is “#” while the delimiter between DI and VI is confined to “##”
        /// </para>
        /// <para>
        /// ISO29002_IRDI values are values containing a global identifier that identifies an
        /// administrated item in a registry. The structure of this identifier complies with
        /// identifier syntax defined in ISO/TS 29002-5. The identifier shall fulfil the
        /// requirements specified in ISO/TS 29002-5 for an "international registration data
        /// identifier" (IRDI).
        /// </para>
        /// </remarks>
        [EnumMember(Value = "IRDI")]
        Irdi,

        /// <summary>
        /// values containing values of type rational
        /// </summary>
        [EnumMember(Value = "RATIONAL")]
        Rational,

        /// <summary>
        /// values containing values of type rational. In addition such a value comes with a
        /// physical unit.
        /// </summary>
        [EnumMember(Value = "RATIONAL_MEASURE")]
        RationalMeasure,

        /// <summary>
        /// values containing a time, conformant to ISO 8601:2004 but restricted to what is
        /// allowed in the corresponding type in xml.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Format hh:mm (ECLASS)
        /// </para>
        /// <para>
        /// Example from IEC 61360-1:2017: "13:20:00-05:00" is the [TIME] representation of:
        /// 1.20 p.m. for Eastern Standard Time, which is 5 hours behind Coordinated
        /// Universal Time (UTC).
        /// </para>
        /// </remarks>
        [EnumMember(Value = "TIME")]
        Time,

        /// <summary>
        /// values containing a time, conformant to ISO 8601:2004 but restricted to what is
        /// allowed in the corresponding type in xml.
        /// </summary>
        /// <remarks>
        /// Format yyyy-mm-dd hh:mm (ECLASS)
        /// </remarks>
        [EnumMember(Value = "TIMESTAMP")]
        Timestamp,

        /// <summary>
        /// values containing an address to a file. The values are of type URI and can represent
        /// an absolute or relative path.
        /// </summary>
        /// <remarks>
        /// IEC61360 does not support the file type.
        /// </remarks>
        [EnumMember(Value = "FILE")]
        File,

        /// <summary>
        /// Values containing string with any sequence of characters, using the syntax of HTML5
        /// (see W3C Recommendation 28:2014)
        /// </summary>
        [EnumMember(Value = "HTML")]
        Html,

        /// <summary>
        /// values containing the content of a file. Values may be binaries.
        /// </summary>
        /// <remarks>
        /// <para>
        /// HTML conformant to HTML5 is a special blob.
        /// </para>
        /// <para>
        /// In IEC61360 binary is for a sequence of bits, each bit being represented by “0” and
        /// “1” only. A binary is a blob but a blob may also contain other source code.
        /// </para>
        /// </remarks>
        [EnumMember(Value = "BLOB")]
        Blob
    }

    /// <summary>
    /// Value represented by up to four variants of a numeric value in a specific role:
    /// <c>MIN</c>, <c>NOM</c>, <c>TYP</c> and <c>MAX</c>. True means that the value is available,
    /// false means the value is not available.
    /// </summary>
    /// <remarks>
    /// <para>
    /// EXAMPLE from [IEC61360-1]: In the case of having a property which is
    /// of the LEVEL_TYPE min/max − expressing a range − only those two values
    /// need to be provided.
    /// </para>
    /// <para>
    /// <para>
    /// This is how AAS deals with the following combinations of level types:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Either all attributes are false. In this case the concept is mapped
    ///     to a <see cref="Aas.Property" /> and level type is ignored.
    ///   </li>
    ///   <li>
    ///     At most one of the attributes is set to true. In this case
    ///     the concept is mapped to a <see cref="Aas.Property" />.
    ///   </li>
    ///   <li>
    ///     Min and max are set to true. In this case the concept is mapped
    ///     to a <see cref="Aas.Range" />.
    ///   </li>
    ///   <li>
    ///     More than one attribute is set to true but not min and max only
    ///     (see second case). In this case the concept is mapped
    ///     to a <see cref="Aas.SubmodelElementCollection" /> with the corresponding
    ///     number of Properties.
    ///     Example: If attribute <see cref="Aas.LevelType.Min" /> and <see cref="Aas.LevelType.Nom" /> are set to true
    ///     then the concept is mapped to a <see cref="Aas.SubmodelElementCollection" />
    ///     with two Properties within: min and nom.
    ///     The data type of both Properties is the same.
    ///   </li>
    /// </ul>
    /// </para>
    /// <para>
    /// In the cases 2. and 4. the <see cref="Aas.Property.SemanticId" /> of the Property
    /// or Properties within the <see cref="Aas.SubmodelElementCollection" /> needs to include
    /// information about the level type. Otherwise, the semantics is not described
    /// in a unique way. Please refer to the specification.
    /// </para>
    /// </remarks>
    public interface ILevelType : IClass
    {
        /// <summary>
        /// Minimum of the value
        /// </summary>
        public bool Min { get; set; }

        /// <summary>
        /// Nominal value (value as designated)
        /// </summary>
        public bool Nom { get; set; }

        /// <summary>
        /// Value as typically present
        /// </summary>
        public bool Typ { get; set; }

        /// <summary>
        /// Maximum of the value
        /// </summary>
        public bool Max { get; set; }
    }

    /// <summary>
    /// Value represented by up to four variants of a numeric value in a specific role:
    /// <c>MIN</c>, <c>NOM</c>, <c>TYP</c> and <c>MAX</c>. True means that the value is available,
    /// false means the value is not available.
    /// </summary>
    /// <remarks>
    /// <para>
    /// EXAMPLE from [IEC61360-1]: In the case of having a property which is
    /// of the LEVEL_TYPE min/max − expressing a range − only those two values
    /// need to be provided.
    /// </para>
    /// <para>
    /// <para>
    /// This is how AAS deals with the following combinations of level types:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Either all attributes are false. In this case the concept is mapped
    ///     to a <see cref="Aas.Property" /> and level type is ignored.
    ///   </li>
    ///   <li>
    ///     At most one of the attributes is set to true. In this case
    ///     the concept is mapped to a <see cref="Aas.Property" />.
    ///   </li>
    ///   <li>
    ///     Min and max are set to true. In this case the concept is mapped
    ///     to a <see cref="Aas.Range" />.
    ///   </li>
    ///   <li>
    ///     More than one attribute is set to true but not min and max only
    ///     (see second case). In this case the concept is mapped
    ///     to a <see cref="Aas.SubmodelElementCollection" /> with the corresponding
    ///     number of Properties.
    ///     Example: If attribute <see cref="Aas.LevelType.Min" /> and <see cref="Aas.LevelType.Nom" /> are set to true
    ///     then the concept is mapped to a <see cref="Aas.SubmodelElementCollection" />
    ///     with two Properties within: min and nom.
    ///     The data type of both Properties is the same.
    ///   </li>
    /// </ul>
    /// </para>
    /// <para>
    /// In the cases 2. and 4. the <see cref="Aas.Property.SemanticId" /> of the Property
    /// or Properties within the <see cref="Aas.SubmodelElementCollection" /> needs to include
    /// information about the level type. Otherwise, the semantics is not described
    /// in a unique way. Please refer to the specification.
    /// </para>
    /// </remarks>
    public class LevelType : ILevelType
    {
        /// <summary>
        /// Minimum of the value
        /// </summary>
        public bool Min { get; set; }

        /// <summary>
        /// Nominal value (value as designated)
        /// </summary>
        public bool Nom { get; set; }

        /// <summary>
        /// Value as typically present
        /// </summary>
        public bool Typ { get; set; }

        /// <summary>
        /// Maximum of the value
        /// </summary>
        public bool Max { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitLevelType(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitLevelType(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformLevelType(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformLevelType(this, context);
        }

        public LevelType(
            bool min,
            bool nom,
            bool typ,
            bool max)
        {
            Min = min;
            Nom = nom;
            Typ = typ;
            Max = max;
        }
    }

    /// <summary>
    /// A value reference pair within a value list. Each value has a global unique id
    /// defining its semantic.
    /// </summary>
    public interface IValueReferencePair : IClass
    {
        /// <summary>
        /// The value of the referenced concept definition of the value in <see cref="Aas.ValueReferencePair.ValueId" />.
        /// </summary>
        public string Value { get; set; }

        /// <summary>
        /// Global unique id of the value.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference ValueId { get; set; }
    }

    /// <summary>
    /// A value reference pair within a value list. Each value has a global unique id
    /// defining its semantic.
    /// </summary>
    public class ValueReferencePair : IValueReferencePair
    {
        /// <summary>
        /// The value of the referenced concept definition of the value in <see cref="Aas.ValueReferencePair.ValueId" />.
        /// </summary>
        public string Value { get; set; }

        /// <summary>
        /// Global unique id of the value.
        /// </summary>
        /// <remarks>
        /// It is recommended to use a global reference.
        /// </remarks>
        public IReference ValueId { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            yield return ValueId;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            yield return ValueId;

            // Recurse
            foreach (var anItem in ValueId.Descend())
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitValueReferencePair(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitValueReferencePair(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformValueReferencePair(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformValueReferencePair(this, context);
        }

        public ValueReferencePair(
            string value,
            IReference valueId)
        {
            Value = value;
            ValueId = valueId;
        }
    }

    /// <summary>
    /// A set of value reference pairs.
    /// </summary>
    public interface IValueList : IClass
    {
        /// <summary>
        /// A pair of a value together with its global unique id.
        /// </summary>
        public List<IValueReferencePair> ValueReferencePairs { get; set; }
    }

    /// <summary>
    /// A set of value reference pairs.
    /// </summary>
    public class ValueList : IValueList
    {
        /// <summary>
        /// A pair of a value together with its global unique id.
        /// </summary>
        public List<IValueReferencePair> ValueReferencePairs { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            foreach (var anItem in ValueReferencePairs)
            {
                yield return anItem;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            foreach (var anItem in ValueReferencePairs)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitValueList(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitValueList(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformValueList(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformValueList(this, context);
        }

        public ValueList(List<IValueReferencePair> valueReferencePairs)
        {
            ValueReferencePairs = valueReferencePairs;
        }
    }

    /// <summary>
    /// String with length 255 maximum and minimum 1 characters and with language tags
    /// </summary>
    /// <remarks>
    /// It is advised to keep the length of the name limited to 35 characters.
    /// </remarks>
    public interface ILangStringPreferredNameTypeIec61360 : IAbstractLangString
    {
        // Intentionally empty.
    }

    /// <summary>
    /// String with length 255 maximum and minimum 1 characters and with language tags
    /// </summary>
    /// <remarks>
    /// It is advised to keep the length of the name limited to 35 characters.
    /// </remarks>
    public class LangStringPreferredNameTypeIec61360 : ILangStringPreferredNameTypeIec61360
    {
        /// <summary>
        /// Language tag conforming to BCP 47
        /// </summary>
        public string Language { get; set; }

        /// <summary>
        /// Text in the <see cref="Aas.IAbstractLangString.Language" />
        /// </summary>
        public string Text { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitLangStringPreferredNameTypeIec61360(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitLangStringPreferredNameTypeIec61360(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformLangStringPreferredNameTypeIec61360(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformLangStringPreferredNameTypeIec61360(this, context);
        }

        public LangStringPreferredNameTypeIec61360(
            string language,
            string text)
        {
            Language = language;
            Text = text;
        }
    }

    /// <summary>
    /// String with length 18 maximum and minimum 1 characters and with language tags
    /// </summary>
    public interface ILangStringShortNameTypeIec61360 : IAbstractLangString
    {
        // Intentionally empty.
    }

    /// <summary>
    /// String with length 18 maximum and minimum 1 characters and with language tags
    /// </summary>
    public class LangStringShortNameTypeIec61360 : ILangStringShortNameTypeIec61360
    {
        /// <summary>
        /// Language tag conforming to BCP 47
        /// </summary>
        public string Language { get; set; }

        /// <summary>
        /// Text in the <see cref="Aas.IAbstractLangString.Language" />
        /// </summary>
        public string Text { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitLangStringShortNameTypeIec61360(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitLangStringShortNameTypeIec61360(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformLangStringShortNameTypeIec61360(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformLangStringShortNameTypeIec61360(this, context);
        }

        public LangStringShortNameTypeIec61360(
            string language,
            string text)
        {
            Language = language;
            Text = text;
        }
    }

    /// <summary>
    /// String with length 1023 maximum and minimum 1 characters and with language tags
    /// </summary>
    public interface ILangStringDefinitionTypeIec61360 : IAbstractLangString
    {
        // Intentionally empty.
    }

    /// <summary>
    /// String with length 1023 maximum and minimum 1 characters and with language tags
    /// </summary>
    public class LangStringDefinitionTypeIec61360 : ILangStringDefinitionTypeIec61360
    {
        /// <summary>
        /// Language tag conforming to BCP 47
        /// </summary>
        public string Language { get; set; }

        /// <summary>
        /// Text in the <see cref="Aas.IAbstractLangString.Language" />
        /// </summary>
        public string Text { get; set; }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            // No descendable properties
            yield break;
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitLangStringDefinitionTypeIec61360(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitLangStringDefinitionTypeIec61360(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformLangStringDefinitionTypeIec61360(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformLangStringDefinitionTypeIec61360(this, context);
        }

        public LangStringDefinitionTypeIec61360(
            string language,
            string text)
        {
            Language = language;
            Text = text;
        }
    }

    /// <summary>
    /// Content of data specification template for concept descriptions for properties,
    /// values and value lists conformant to IEC 61360.
    /// </summary>
    /// <remarks>
    /// <para>
    /// It is also possible that both <see cref="Aas.DataSpecificationIec61360.Value" /> and <see cref="Aas.DataSpecificationIec61360.ValueList" /> are empty.
    /// This is the case for concept descriptions that define the semantics of a
    /// property but do not have an enumeration (<see cref="Aas.DataSpecificationIec61360.ValueList" />) as data type.
    /// </para>
    /// <para>
    /// Although it is possible to define a <see cref="Aas.ConceptDescription" /> for a
    /// :attr:´value_list`,
    /// it is not possible to reuse this <see cref="Aas.DataSpecificationIec61360.ValueList" />.
    /// It is only possible to directly add a <see cref="Aas.DataSpecificationIec61360.ValueList" /> as data type
    /// to a specific semantic definition of a property.
    /// </para>
    /// <para>
    /// IEC61360 requires also a globally unique identifier for a concept
    /// description. This ID is not part of the data specification template.
    /// Instead the <see cref="Aas.ConceptDescription.Id" /> as inherited via
    /// <see cref="Aas.IIdentifiable" /> is used. Same holds for administrative
    /// information like the version and revision.
    /// </para>
    /// <para>
    /// <see cref="Aas.ConceptDescription.IdShort" /> and <see cref="Aas.DataSpecificationIec61360.ShortName" /> are very
    /// similar. However, in this case the decision was to add
    /// <see cref="Aas.DataSpecificationIec61360.ShortName" /> explicitly to the data specification. Same holds for
    /// <see cref="Aas.ConceptDescription.DisplayName" /> and
    /// <see cref="Aas.DataSpecificationIec61360.PreferredName" />. Same holds for
    /// <see cref="Aas.ConceptDescription.Description" /> and <see cref="Aas.DataSpecificationIec61360.Definition" />.
    /// </para>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Constraint AASc-3a-009:
    ///     If <see cref="Aas.DataSpecificationIec61360.DataType" /> one of:
    ///     <see cref="Aas.DataTypeIec61360.IntegerMeasure" />,
    ///     <see cref="Aas.DataTypeIec61360.RealMeasure" />,
    ///     <see cref="Aas.DataTypeIec61360.RationalMeasure" />,
    ///     <see cref="Aas.DataTypeIec61360.IntegerCurrency" />,
    ///     <see cref="Aas.DataTypeIec61360.RealCurrency" />, then <see cref="Aas.DataSpecificationIec61360.Unit" /> or
    ///     <see cref="Aas.DataSpecificationIec61360.UnitId" /> shall be defined.
    ///   </li>
    /// </ul>
    /// </remarks>
    public interface IDataSpecificationIec61360 : IDataSpecificationContent
    {
        /// <summary>
        /// Preferred name
        /// </summary>
        /// <remarks>
        /// <para>
        /// It is advised to keep the length of the name limited to 35 characters.
        /// </para>
        /// <para>
        /// Constraints:
        /// </para>
        /// <ul>
        ///   <li>
        ///     Constraint AASc-3a-002:
        ///     <see cref="Aas.DataSpecificationIec61360.PreferredName" /> shall be provided at least in English.
        ///   </li>
        /// </ul>
        /// </remarks>
        public List<ILangStringPreferredNameTypeIec61360> PreferredName { get; set; }

        /// <summary>
        /// Short name
        /// </summary>
        public List<ILangStringShortNameTypeIec61360>? ShortName { get; set; }

        /// <summary>
        /// Unit
        /// </summary>
        public string? Unit { get; set; }

        /// <summary>
        /// Unique unit id
        /// </summary>
        /// <remarks>
        /// <para>
        /// <see cref="Aas.DataSpecificationIec61360.Unit" /> and <see cref="Aas.DataSpecificationIec61360.UnitId" /> need to be consistent if both attributes
        /// are set
        /// </para>
        /// <para>
        /// It is recommended to use an external reference ID.
        /// </para>
        /// </remarks>
        public IReference? UnitId { get; set; }

        /// <summary>
        /// Source of definition
        /// </summary>
        public string? SourceOfDefinition { get; set; }

        /// <summary>
        /// Symbol
        /// </summary>
        public string? Symbol { get; set; }

        /// <summary>
        /// Data Type
        /// </summary>
        public DataTypeIec61360? DataType { get; set; }

        /// <summary>
        /// Definition in different languages
        /// </summary>
        public List<ILangStringDefinitionTypeIec61360>? Definition { get; set; }

        /// <summary>
        /// Value Format
        /// </summary>
        /// <remarks>
        /// The value format is based on ISO 13584-42 and IEC 61360-2.
        /// </remarks>
        public string? ValueFormat { get; set; }

        /// <summary>
        /// List of allowed values
        /// </summary>
        public IValueList? ValueList { get; set; }

        /// <summary>
        /// Value
        /// </summary>
        public string? Value { get; set; }

        /// <summary>
        /// Set of levels.
        /// </summary>
        public ILevelType? LevelType { get; set; }

        /// <summary>
        /// Iterate over ShortName, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringShortNameTypeIec61360> OverShortNameOrEmpty();

        /// <summary>
        /// Iterate over Definition, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringDefinitionTypeIec61360> OverDefinitionOrEmpty();
    }

    /// <summary>
    /// Content of data specification template for concept descriptions for properties,
    /// values and value lists conformant to IEC 61360.
    /// </summary>
    /// <remarks>
    /// <para>
    /// It is also possible that both <see cref="Aas.DataSpecificationIec61360.Value" /> and <see cref="Aas.DataSpecificationIec61360.ValueList" /> are empty.
    /// This is the case for concept descriptions that define the semantics of a
    /// property but do not have an enumeration (<see cref="Aas.DataSpecificationIec61360.ValueList" />) as data type.
    /// </para>
    /// <para>
    /// Although it is possible to define a <see cref="Aas.ConceptDescription" /> for a
    /// :attr:´value_list`,
    /// it is not possible to reuse this <see cref="Aas.DataSpecificationIec61360.ValueList" />.
    /// It is only possible to directly add a <see cref="Aas.DataSpecificationIec61360.ValueList" /> as data type
    /// to a specific semantic definition of a property.
    /// </para>
    /// <para>
    /// IEC61360 requires also a globally unique identifier for a concept
    /// description. This ID is not part of the data specification template.
    /// Instead the <see cref="Aas.ConceptDescription.Id" /> as inherited via
    /// <see cref="Aas.IIdentifiable" /> is used. Same holds for administrative
    /// information like the version and revision.
    /// </para>
    /// <para>
    /// <see cref="Aas.ConceptDescription.IdShort" /> and <see cref="Aas.DataSpecificationIec61360.ShortName" /> are very
    /// similar. However, in this case the decision was to add
    /// <see cref="Aas.DataSpecificationIec61360.ShortName" /> explicitly to the data specification. Same holds for
    /// <see cref="Aas.ConceptDescription.DisplayName" /> and
    /// <see cref="Aas.DataSpecificationIec61360.PreferredName" />. Same holds for
    /// <see cref="Aas.ConceptDescription.Description" /> and <see cref="Aas.DataSpecificationIec61360.Definition" />.
    /// </para>
    /// <para>
    /// Constraints:
    /// </para>
    /// <ul>
    ///   <li>
    ///     Constraint AASc-3a-009:
    ///     If <see cref="Aas.DataSpecificationIec61360.DataType" /> one of:
    ///     <see cref="Aas.DataTypeIec61360.IntegerMeasure" />,
    ///     <see cref="Aas.DataTypeIec61360.RealMeasure" />,
    ///     <see cref="Aas.DataTypeIec61360.RationalMeasure" />,
    ///     <see cref="Aas.DataTypeIec61360.IntegerCurrency" />,
    ///     <see cref="Aas.DataTypeIec61360.RealCurrency" />, then <see cref="Aas.DataSpecificationIec61360.Unit" /> or
    ///     <see cref="Aas.DataSpecificationIec61360.UnitId" /> shall be defined.
    ///   </li>
    /// </ul>
    /// </remarks>
    public class DataSpecificationIec61360 : IDataSpecificationIec61360
    {
        /// <summary>
        /// Preferred name
        /// </summary>
        /// <remarks>
        /// <para>
        /// It is advised to keep the length of the name limited to 35 characters.
        /// </para>
        /// <para>
        /// Constraints:
        /// </para>
        /// <ul>
        ///   <li>
        ///     Constraint AASc-3a-002:
        ///     <see cref="Aas.DataSpecificationIec61360.PreferredName" /> shall be provided at least in English.
        ///   </li>
        /// </ul>
        /// </remarks>
        public List<ILangStringPreferredNameTypeIec61360> PreferredName { get; set; }

        /// <summary>
        /// Short name
        /// </summary>
        public List<ILangStringShortNameTypeIec61360>? ShortName { get; set; }

        /// <summary>
        /// Unit
        /// </summary>
        public string? Unit { get; set; }

        /// <summary>
        /// Unique unit id
        /// </summary>
        /// <remarks>
        /// <para>
        /// <see cref="Aas.DataSpecificationIec61360.Unit" /> and <see cref="Aas.DataSpecificationIec61360.UnitId" /> need to be consistent if both attributes
        /// are set
        /// </para>
        /// <para>
        /// It is recommended to use an external reference ID.
        /// </para>
        /// </remarks>
        public IReference? UnitId { get; set; }

        /// <summary>
        /// Source of definition
        /// </summary>
        public string? SourceOfDefinition { get; set; }

        /// <summary>
        /// Symbol
        /// </summary>
        public string? Symbol { get; set; }

        /// <summary>
        /// Data Type
        /// </summary>
        public DataTypeIec61360? DataType { get; set; }

        /// <summary>
        /// Definition in different languages
        /// </summary>
        public List<ILangStringDefinitionTypeIec61360>? Definition { get; set; }

        /// <summary>
        /// Value Format
        /// </summary>
        /// <remarks>
        /// The value format is based on ISO 13584-42 and IEC 61360-2.
        /// </remarks>
        public string? ValueFormat { get; set; }

        /// <summary>
        /// List of allowed values
        /// </summary>
        public IValueList? ValueList { get; set; }

        /// <summary>
        /// Value
        /// </summary>
        public string? Value { get; set; }

        /// <summary>
        /// Set of levels.
        /// </summary>
        public ILevelType? LevelType { get; set; }

        /// <summary>
        /// Iterate over ShortName, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringShortNameTypeIec61360> OverShortNameOrEmpty()
        {
            return ShortName
                ?? System.Linq.Enumerable.Empty<ILangStringShortNameTypeIec61360>();
        }

        /// <summary>
        /// Iterate over Definition, if set, and otherwise return an empty enumerable.
        /// </summary>
        public IEnumerable<ILangStringDefinitionTypeIec61360> OverDefinitionOrEmpty()
        {
            return Definition
                ?? System.Linq.Enumerable.Empty<ILangStringDefinitionTypeIec61360>();
        }

        /// <summary>
        /// Iterate over all the class instances referenced from this instance
        /// without further recursion.
        /// </summary>
        public IEnumerable<IClass> DescendOnce()
        {
            foreach (var anItem in PreferredName)
            {
                yield return anItem;
            }

            if (ShortName != null)
            {
                foreach (var anItem in ShortName)
                {
                    yield return anItem;
                }
            }

            if (UnitId != null)
            {
                yield return UnitId;
            }

            if (Definition != null)
            {
                foreach (var anItem in Definition)
                {
                    yield return anItem;
                }
            }

            if (ValueList != null)
            {
                yield return ValueList;
            }

            if (LevelType != null)
            {
                yield return LevelType;
            }
        }

        /// <summary>
        /// Iterate recursively over all the class instances referenced from this instance.
        /// </summary>
        public IEnumerable<IClass> Descend()
        {
            foreach (var anItem in PreferredName)
            {
                yield return anItem;

                // Recurse
                foreach (var anotherItem in anItem.Descend())
                {
                    yield return anotherItem;
                }
            }

            if (ShortName != null)
            {
                foreach (var anItem in ShortName)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (UnitId != null)
            {
                yield return UnitId;

                // Recurse
                foreach (var anItem in UnitId.Descend())
                {
                    yield return anItem;
                }
            }

            if (Definition != null)
            {
                foreach (var anItem in Definition)
                {
                    yield return anItem;

                    // Recurse
                    foreach (var anotherItem in anItem.Descend())
                    {
                        yield return anotherItem;
                    }
                }
            }

            if (ValueList != null)
            {
                yield return ValueList;

                // Recurse
                foreach (var anItem in ValueList.Descend())
                {
                    yield return anItem;
                }
            }

            if (LevelType != null)
            {
                yield return LevelType;

                // Recurse
                foreach (var anItem in LevelType.Descend())
                {
                    yield return anItem;
                }
            }
        }

        /// <summary>
        /// Accept the <paramref name="visitor" /> to visit this instance
        /// for double dispatch.
        /// </summary>
        public void Accept(Visitation.IVisitor visitor)
        {
            visitor.VisitDataSpecificationIec61360(this);
        }

        /// <summary>
        /// Accept the visitor to visit this instance for double dispatch
        /// with the <paramref name="context" />.
        /// </summary>
        public void Accept<TContext>(
            Visitation.IVisitorWithContext<TContext> visitor,
            TContext context)
        {
            visitor.VisitDataSpecificationIec61360(this, context);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to transform this instance
        /// for double dispatch.
        /// </summary>
        public T Transform<T>(Visitation.ITransformer<T> transformer)
        {
            return transformer.TransformDataSpecificationIec61360(this);
        }

        /// <summary>
        /// Accept the <paramref name="transformer" /> to visit this instance
        /// for double dispatch with the <paramref name="context" />.
        /// </summary>
        public T Transform<TContext, T>(
            Visitation.ITransformerWithContext<TContext, T> transformer,
            TContext context)
        {
            return transformer.TransformDataSpecificationIec61360(this, context);
        }

        public DataSpecificationIec61360(
            List<ILangStringPreferredNameTypeIec61360> preferredName,
            List<ILangStringShortNameTypeIec61360>? shortName = null,
            string? unit = null,
            IReference? unitId = null,
            string? sourceOfDefinition = null,
            string? symbol = null,
            DataTypeIec61360? dataType = null,
            List<ILangStringDefinitionTypeIec61360>? definition = null,
            string? valueFormat = null,
            IValueList? valueList = null,
            string? value = null,
            ILevelType? levelType = null)
        {
            PreferredName = preferredName;
            ShortName = shortName;
            Unit = unit;
            UnitId = unitId;
            SourceOfDefinition = sourceOfDefinition;
            Symbol = symbol;
            DataType = dataType;
            Definition = definition;
            ValueFormat = valueFormat;
            ValueList = valueList;
            Value = value;
            LevelType = levelType;
        }
    }
}  // namespace AasCore.Aas3_0

/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */
